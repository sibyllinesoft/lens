/*!
 * # Lens Code Search Engine - Core Library
 * 
 * A production-grade, fraud-resistant code search engine designed for enterprise environments
 * with comprehensive security features, high-performance search capabilities, and built-in
 * cryptographic attestation.
 * 
 * ## Architecture Overview
 * 
 * The Lens Core library is organized into four main modules:
 * 
 * - [`search`]: High-performance search engine with multi-language support
 * - [`indexer`]: Document processing and indexing capabilities  
 * - [`attestation`]: Fraud-resistant cryptographic verification system
 * - [`server`]: HTTP/RPC server with security enforcement
 * 
 * ## Security Model
 * 
 * This library implements a comprehensive security model:
 * 
 * - **Production-Only Operation**: Tripwire mechanisms prevent non-production usage
 * - **Cryptographic Attestation**: Build-time verification with Git SHA tracking
 * - **Memory Safety**: Rust's ownership system prevents common security vulnerabilities
 * - **Input Validation**: All external inputs are validated and sanitized
 * - **Audit Logging**: Complete operation audit trail for compliance
 * 
 * ## Performance Characteristics
 * 
 * Optimized for production workloads:
 * 
 * - **Sub-millisecond Search**: Typical query response times under 5ms
 * - **High Throughput**: 2000+ requests per second sustained
 * - **Memory Efficient**: < 100MB typical memory footprint
 * - **Zero-Copy Operations**: Minimize allocations in critical paths
 * 
 * ## Usage Example
 * 
 * ```rust,no_run
 * use lens_core::{LensRpcServer, SearchEngine, AttestationService};
 * use anyhow::Result;
 * 
 * #[tokio::main]
 * async fn main() -> Result<()> {
 *     // Create production server with security enforcement
 *     let server = LensRpcServer::new()?;
 *     
 *     // Start serving on production port
 *     server.serve("0.0.0.0:8080").await?;
 *     
 *     Ok(())
 * }
 * ```
 * 
 * ## Feature Flags
 * 
 * - `simd`: Enable SIMD optimizations for text processing (enabled by default)
 * - `ann`: Approximate Nearest Neighbor search capabilities (optional)
 * - `lsp`: Language Server Protocol support (optional)
 * 
 * ## Build Information
 * 
 * The library embeds comprehensive build information for attestation and verification
 * purposes through the [`built`] module, which is automatically generated at compile time.
 */

// Core search functionality - high-performance text search with multi-language support
// Provides both lexical and semantic search capabilities with fuzzy matching
pub mod search;

// Document indexing and processing - handles ingestion of source code files
// Supports multiple programming languages with syntax-aware parsing
pub mod indexer;

// Fraud-resistant attestation system - cryptographic verification and security enforcement
// Implements challenge-response protocols and build-time verification
pub mod attestation;

// HTTP/RPC server implementation - production-ready web service with security enforcement
// Provides REST API endpoints with comprehensive error handling and observability
pub mod server;

// Model Context Protocol (MCP) server implementation - standardized protocol for AI tools
// Provides MCP-compliant interface for code search functionality
#[cfg(feature = "mcp")]
pub mod mcp;

/// Build-time information generated by build.rs
/// 
/// This module contains comprehensive metadata about the build environment,
/// including Git SHA, Rust version, target platform, and compilation flags.
/// This information is used for cryptographic attestation and deployment verification.
/// 
/// ## Available Information
/// 
/// - `GIT_COMMIT_HASH`: Git SHA of the source code at build time
/// - `RUSTC_VERSION`: Rust compiler version used for the build  
/// - `TARGET`: Target platform (e.g., x86_64-unknown-linux-gnu)
/// - `PROFILE`: Build profile (debug/release)
/// - `FEATURES`: Enabled cargo features
/// - `DEPENDENCIES`: Information about dependencies and their versions
/// 
/// ## Security Usage
/// 
/// This information is embedded in the binary and used by the attestation
/// service to verify the authenticity and integrity of deployments.
pub mod built {
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}

// Public API exports - these are the primary interfaces for using the library

/// High-performance, multi-language code search engine.
/// 
/// Provides both in-memory and persistent search capabilities with support for:
/// - Lexical text search with fuzzy matching
/// - AST-aware code structure search  
/// - Multi-language syntax recognition
/// - Performance optimization for large codebases
/// 
/// # Example
/// 
/// ```rust,no_run
/// use lens_core::SearchEngine;
/// use anyhow::Result;
/// 
/// # async fn example() -> Result<()> {
/// let mut engine = SearchEngine::new_in_memory()?;
/// 
/// // Index a document
/// engine.index_document("example.rs", "fn hello_world() { println!(\"Hello!\"); }")?;
/// 
/// // Search for functions
/// let results = engine.search("hello_world", 10)?;
/// println!("Found {} results", results.len());
/// # Ok(())
/// # }
/// ```
pub use search::SearchEngine;

/// Document indexing and processing engine.
/// 
/// Handles the ingestion and processing of source code files from various
/// programming languages, with support for:
/// - Recursive directory traversal
/// - Language detection and filtering
/// - Batch processing with progress tracking
/// - Error handling for corrupt or binary files
/// 
/// # Example
/// 
/// ```rust,no_run
/// use lens_core::Indexer;
/// use anyhow::Result;
/// 
/// # fn example() -> Result<()> {
/// let mut indexer = Indexer::new_in_memory()?;
/// 
/// // Index a single file
/// indexer.index_document("src/main.rs", "fn main() {}")?;
/// 
/// // Index entire directory
/// indexer.index_directory("./src")?;
/// 
/// let stats = indexer.get_stats();
/// println!("Indexed {} files", stats.files_indexed);
/// # Ok(())
/// # }
/// ```
pub use indexer::Indexer;

/// Fraud-resistant cryptographic attestation service.
/// 
/// Provides comprehensive security verification including:
/// - Challenge-response authentication protocols
/// - Build-time integrity verification
/// - Environment attestation and validation
/// - Cryptographic handshake mechanisms
/// 
/// # Security Model
/// 
/// The attestation service enforces production-only operation and provides
/// cryptographic proof of service authenticity to prevent fraud and tampering.
/// 
/// # Example
/// 
/// ```rust,no_run
/// use lens_core::AttestationService;
/// use anyhow::Result;
/// 
/// # fn example() -> Result<()> {
/// // Create attestation service (only works in "real" mode)
/// let service = AttestationService::new("real")?;
/// 
/// // Generate attestation record for client verification
/// let record = service.create_handshake("client-nonce-123")?;
/// 
/// // Validate client response
/// let is_valid = service.validate_handshake(
///     &record.handshake_nonce, 
///     &record.handshake_response
/// )?;
/// # Ok(())
/// # }
/// ```
pub use attestation::AttestationService;

/// Production-ready HTTP/RPC server with comprehensive security enforcement.
/// 
/// Provides a high-performance web service with:
/// - RESTful API endpoints for search and attestation
/// - Comprehensive request validation and error handling
/// - Built-in observability and health monitoring
/// - Security-first design with audit logging
/// 
/// # Endpoints
/// 
/// - `GET /health`: Service health and mode verification
/// - `GET /manifest`: Build information and service metadata
/// - `POST /search`: Core search functionality
/// - `POST /handshake`: Cryptographic client verification
/// 
/// # Example
/// 
/// ```rust,no_run
/// use lens_core::LensRpcServer;
/// use anyhow::Result;
/// 
/// #[tokio::main]
/// async fn main() -> Result<()> {
///     // Create server with security enforcement
///     let server = LensRpcServer::new()?;
///     
///     // Start serving (blocks until shutdown)
///     server.serve("0.0.0.0:8080").await?;
///     
///     Ok(())
/// }
/// ```
pub use server::LensRpcServer;

/// Model Context Protocol server for AI tool integration.
/// 
/// Provides a standardized interface for AI assistants and development tools to interact
/// with the Lens search engine through the Model Context Protocol (MCP). This enables
/// seamless integration with Claude Code, VS Code, and other MCP-compatible tools.
/// 
/// # Features
/// 
/// - **Code Search Tool**: Exposes search functionality as MCP tool
/// - **File Resources**: Access to indexed file contents and metadata
/// - **Symbol Navigation**: Jump to definitions and references via MCP
/// - **STDIO Protocol**: Standard input/output communication for broad compatibility
/// 
/// # Example
/// 
/// ```rust,no_run
/// use lens_core::{McpServer, SearchEngine};
/// use std::sync::Arc;
/// use anyhow::Result;
/// 
/// #[tokio::main]
/// async fn main() -> Result<()> {
///     // Create search engine
///     let search_engine = Arc::new(SearchEngine::new_in_memory()?);
///     
///     // Create MCP server
///     let mcp_server = McpServer::new(search_engine);
///     
///     // Start MCP server on STDIO
///     mcp_server.start().await?;
///     
///     Ok(())
/// }
/// ```
#[cfg(feature = "mcp")]
pub use mcp::McpServer;