version: '3.8'

# Lens Competitor Systems Benchmark Infrastructure
# Based on existing .env configuration and previous benchmark setups

services:
  # Core Lens system
  lens-core:
    build: ../
    container_name: lens-core
    ports:
      - "50051:50051"
    environment:
      - NODE_ENV=benchmark
      - SLA_TIMEOUT_MS=150
    volumes:
      - ../src:/app/src:ro
      - ../configs:/app/configs:ro
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:50051/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - benchmark-net

  # Zoekt - Google's code search engine
  zoekt-indexserver:
    image: sourcegraph/zoekt-indexserver:latest
    container_name: zoekt-indexserver  
    volumes:
      - zoekt-data:/data
      - ./corpus:/corpus:ro
    command: >
      zoekt-indexserver
      -index /data
      -interval 5m
      /corpus
    networks:
      - benchmark-net

  zoekt-webserver:
    image: sourcegraph/zoekt-webserver:latest
    container_name: zoekt-webserver
    ports:
      - "6070:6070"
    volumes:
      - zoekt-data:/data
    command: >
      zoekt-webserver
      -index /data
      -listen :6070
    depends_on:
      - zoekt-indexserver
    networks:
      - benchmark-net

  # Livegrep - Fast regex search over large codebases
  livegrep:
    image: alpine:latest
    container_name: livegrep
    ports:
      - "9898:9898"
    volumes:
      - ./corpus:/corpus:ro
    command: >
      livegrep
      -docroot /usr/share/livegrep/web
      -listen 0.0.0.0:9898
      /corpus
    networks:
      - benchmark-net

  # Ripgrep server - Fast grep implementation
  ripgrep-server:
    image: alpine:latest
    container_name: ripgrep-server
    ports:
      - "8080:8080"
    volumes:
      - ./corpus:/corpus:ro
    command: >
      sh -c "
      apk add --no-cache ripgrep python3 py3-pip &&
      pip3 install flask requests &&
      python3 -c \"
      from flask import Flask, request, jsonify
      import subprocess
      import json
      app = Flask(__name__)
      @app.route('/search', methods=['POST'])
      def search():
          query = request.json.get('query', '')
          try:
              result = subprocess.run(['rg', '--json', query, '/corpus'], 
                                     capture_output=True, text=True, timeout=30)
              lines = [json.loads(line) for line in result.stdout.strip().split('\\n') if line]
              matches = [line for line in lines if line.get('type') == 'match']
              return jsonify({'matches': matches[:100], 'total': len(matches)})
          except Exception as e:
              return jsonify({'error': str(e)}), 500
      @app.route('/health')
      def health():
          return jsonify({'status': 'ok'})
      app.run(host='0.0.0.0', port=8080)
      \"
      "
    networks:
      - benchmark-net

  # Comby - Structural code search and replace
  comby-server:
    image: comby/comby:latest
    container_name: comby-server
    ports:
      - "8081:8081"
    volumes:
      - ./corpus:/corpus:ro
    command: >
      sh -c "
      apk add --no-cache python3 py3-pip &&
      pip3 install flask requests &&
      python3 -c \"
      from flask import Flask, request, jsonify
      import subprocess
      import os
      app = Flask(__name__)
      @app.route('/search', methods=['POST'])
      def search():
          pattern = request.json.get('pattern', '')
          language = request.json.get('language', 'generic')
          try:
              result = subprocess.run(['comby', pattern, '', '/corpus', 
                                     '-matcher', language, '-json-lines', '-count', '100'], 
                                     capture_output=True, text=True, timeout=30)
              if result.returncode == 0:
                  lines = [line for line in result.stdout.strip().split('\\n') if line]
                  matches = [json.loads(line) for line in lines]
                  return jsonify({'matches': matches, 'total': len(matches)})
              else:
                  return jsonify({'matches': [], 'total': 0})
          except Exception as e:
              return jsonify({'error': str(e)}), 500
      @app.route('/health')
      def health():
          return jsonify({'status': 'ok'})
      app.run(host='0.0.0.0', port=8081)
      \"
      "
    networks:
      - benchmark-net

  # AST-grep - Structural search using AST patterns
  ast-grep-server:
    image: alpine:latest
    container_name: ast-grep-server
    ports:
      - "8082:8082"
    volumes:
      - ./corpus:/corpus:ro
    command: >
      sh -c "
      apk add --no-cache python3 py3-pip &&
      pip3 install flask requests &&
      python3 -c \"
      from flask import Flask, request, jsonify
      import subprocess
      import json
      app = Flask(__name__)
      @app.route('/search', methods=['POST'])
      def search():
          pattern = request.json.get('pattern', '')
          language = request.json.get('language', 'python')
          try:
              result = subprocess.run(['ast-grep', '--pattern', pattern, 
                                     '--lang', language, '/corpus', '--json'], 
                                     capture_output=True, text=True, timeout=30)
              if result.returncode == 0:
                  matches = json.loads(result.stdout) if result.stdout else []
                  return jsonify({'matches': matches[:100], 'total': len(matches)})
              else:
                  return jsonify({'matches': [], 'total': 0})
          except Exception as e:
              return jsonify({'error': str(e)}), 500
      @app.route('/health')
      def health():
          return jsonify({'status': 'ok'})
      app.run(host='0.0.0.0', port=8082)
      \"
      "
    networks:
      - benchmark-net

  # OpenSearch - Elasticsearch-compatible search engine
  opensearch:
    image: opensearchproject/opensearch:2
    container_name: opensearch
    ports:
      - "9200:9200"
      - "9600:9600"
    environment:
      - cluster.name=opensearch-cluster
      - node.name=opensearch-node1
      - discovery.type=single-node
      - bootstrap.memory_lock=true
      - "OPENSEARCH_JAVA_OPTS=-Xms512m -Xmx512m"
      - "DISABLE_INSTALL_DEMO_CONFIG=true"
      - "DISABLE_SECURITY_PLUGIN=true"
    ulimits:
      memlock:
        soft: -1
        hard: -1
      nofile:
        soft: 65536
        hard: 65536
    volumes:
      - opensearch-data:/usr/share/opensearch/data
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9200 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
    networks:
      - benchmark-net

  # Qdrant - Vector database for dense retrieval
  qdrant:
    image: qdrant/qdrant:latest
    container_name: qdrant
    ports:
      - "6333:6333"
    environment:
      - QDRANT__SERVICE__HTTP_PORT=6333
      - QDRANT__SERVICE__GRPC_PORT=6334
    volumes:
      - qdrant-data:/qdrant/storage
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:6333/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - benchmark-net

  # Vespa - Yahoo's search engine for large-scale applications  
  vespa:
    image: vespaengine/vespa:latest
    container_name: vespa
    ports:
      - "8080:8080"
      - "19071:19071"
    environment:
      - VESPA_CONFIGSERVERS=localhost
    volumes:
      - vespa-data:/opt/vespa/var
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/ApplicationStatus"]
      interval: 30s
      timeout: 10s
      retries: 5
    networks:
      - benchmark-net

  # FAISS server - Facebook's similarity search library
  faiss-server:
    image: python:3.11-slim
    container_name: faiss-server
    ports:
      - "8084:8084"
    volumes:
      - ./corpus:/corpus:ro
      - faiss-data:/data
    command: >
      sh -c "
      pip install faiss-cpu flask requests numpy sentence-transformers &&
      python3 -c \"
      from flask import Flask, request, jsonify
      import faiss
      import numpy as np
      import json
      import os
      from sentence_transformers import SentenceTransformer
      
      app = Flask(__name__)
      
      # Initialize model and index
      model = None
      index = None
      
      def init_model():
          global model, index
          if model is None:
              model = SentenceTransformer('all-MiniLM-L6-v2')
              # Create or load FAISS index
              index_path = '/data/faiss.index'
              if os.path.exists(index_path):
                  index = faiss.read_index(index_path)
              else:
                  # Create empty index for 384-dimensional vectors
                  index = faiss.IndexFlatIP(384)
                  faiss.write_index(index, index_path)
      
      @app.route('/search', methods=['POST'])
      def search():
          try:
              init_model()
              query = request.json.get('query', '')
              k = request.json.get('k', 10)
              
              # Encode query
              query_vector = model.encode([query])
              
              # Search
              scores, indices = index.search(query_vector, k)
              
              # Return mock results for now
              results = []
              for i, (score, idx) in enumerate(zip(scores[0], indices[0])):
                  if idx >= 0:  # Valid index
                      results.append({
                          'id': int(idx),
                          'score': float(score),
                          'file': f'mock/file{idx}.py',
                          'content': f'Mock content for index {idx}'
                      })
              
              return jsonify({'matches': results, 'total': len(results)})
          except Exception as e:
              return jsonify({'error': str(e)}), 500
              
      @app.route('/health')
      def health():
          return jsonify({'status': 'ok'})
          
      app.run(host='0.0.0.0', port=8084)
      \"
      "
    networks:
      - benchmark-net

  # Milvus - Open-source vector database
  milvus-etcd:
    image: quay.io/coreos/etcd:v3.5.5
    container_name: milvus-etcd
    environment:
      - ETCD_AUTO_COMPACTION_MODE=revision
      - ETCD_AUTO_COMPACTION_RETENTION=1000
      - ETCD_QUOTA_BACKEND_BYTES=4294967296
      - ETCD_SNAPSHOT_COUNT=50000
    command: etcd -advertise-client-urls=http://127.0.0.1:2379 -listen-client-urls http://0.0.0.0:2379 --data-dir /etcd
    volumes:
      - etcd-data:/etcd
    healthcheck:
      test: ["CMD", "etcdctl", "endpoint", "health"]
      interval: 30s
      timeout: 20s
      retries: 3
    networks:
      - benchmark-net

  milvus-minio:
    image: minio/minio:RELEASE.2023-03-20T20-16-18Z
    container_name: milvus-minio
    environment:
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadmin
    ports:
      - "9001:9001"
      - "9000:9000"
    command: minio server /minio_data --console-address ":9001"
    volumes:
      - minio-data:/minio_data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    networks:
      - benchmark-net

  milvus:
    image: milvusdb/milvus:v2.3.2
    container_name: milvus
    ports:
      - "19530:19530"
      - "9091:9091"
    command: ["milvus", "run", "standalone"]
    environment:
      ETCD_ENDPOINTS: milvus-etcd:2379
      MINIO_ADDRESS: milvus-minio:9000
    volumes:
      - milvus-data:/var/lib/milvus
    depends_on:
      - milvus-etcd
      - milvus-minio
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9091/healthz"]
      interval: 30s
      timeout: 20s
      retries: 5
    networks:
      - benchmark-net

  # ctags indexing service
  ctags-server:
    image: alpine:latest
    container_name: ctags-server
    ports:
      - "8083:8083"
    volumes:
      - ./corpus:/corpus:ro
      - ctags-data:/data
    command: >
      sh -c "
      apk add --no-cache ctags python3 py3-pip &&
      pip3 install flask requests &&
      
      # Generate ctags index
      cd /corpus && ctags -R --fields=+n --output-format=json . > /data/tags.json &&
      
      python3 -c \"
      from flask import Flask, request, jsonify
      import json
      import os
      
      app = Flask(__name__)
      
      # Load tags
      tags = []
      if os.path.exists('/data/tags.json'):
          with open('/data/tags.json', 'r') as f:
              for line in f:
                  if line.strip():
                      try:
                          tags.append(json.loads(line))
                      except:
                          pass
      
      @app.route('/search', methods=['POST'])
      def search():
          query = request.json.get('query', '').lower()
          tag_type = request.json.get('type', None)
          
          matches = []
          for tag in tags:
              name = tag.get('name', '').lower()
              kind = tag.get('kind', '')
              if query in name:
                  if tag_type is None or kind == tag_type:
                      matches.append({
                          'name': tag.get('name'),
                          'file': tag.get('path', ''),
                          'line': tag.get('line', 0),
                          'kind': kind,
                          'language': tag.get('language', '')
                      })
              if len(matches) >= 100:
                  break
          
          return jsonify({'matches': matches, 'total': len(matches)})
          
      @app.route('/health')
      def health():
          return jsonify({'status': 'ok', 'tags_loaded': len(tags)})
          
      app.run(host='0.0.0.0', port=8083)
      \"
      "
    networks:
      - benchmark-net

volumes:
  zoekt-data:
  opensearch-data:
  qdrant-data:
  vespa-data:
  faiss-data:
  etcd-data:
  minio-data:
  milvus-data:
  ctags-data:

networks:
  benchmark-net:
    driver: bridge