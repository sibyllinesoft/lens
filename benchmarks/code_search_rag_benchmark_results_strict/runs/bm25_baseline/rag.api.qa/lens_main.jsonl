{"qid": "lens_main_rag_api_0", "query": "How do I authenticate API requests?", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.12302873279942675, "span_start": null, "span_end": null, "passage": "import ast import re from functools import partial from pathlib import Path from typing import Tuple from griffe.dataclasses import Object as Griffe Object from griffe.extensions import Visitor Extens..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.09996058573799665, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.09339377125307277, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 4, "path": "docs/plugins/using_update.py", "score": 0.07500322848080587, "span_start": null, "span_end": null, "passage": "from pathlib import Path from time import sleep import requests import tomli THIS DIR = Path(  file  ).parent session = requests.Session() def update lib(lib, *, retry=0): repo = lib['repo'] url = f'h..."}, {"qid": "", "rank": 5, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/metaclass_args.py", "score": 0.06935169104602742, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 6, "path": "tests/mypy/outputs/1.0.1/mypy-plugin-very-strict_ini/metaclass_args.py", "score": 0.06935169104602742, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 7, "path": "tests/mypy/modules/metaclass_args.py", "score": 0.06935169104602742, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/mypy.py", "score": 0.049269732396787565, "span_start": null, "span_end": null, "passage": "import sys from configparser import Config Parser from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as Typing Type, Union from mypy.errorcodes import Error Code from mypy.nodes ..."}, {"qid": "", "rank": 9, "path": "release/make_history.py", "score": 0.0440051586093327, "span_start": null, "span_end": null, "passage": "from   future   import annotations as  annotations import argparse import json import re import subprocess import sys from datetime import date from pathlib import Path import requests def main(): roo..."}, {"qid": "", "rank": 10, "path": "pydantic/config.py", "score": 0.022849061121122716, "span_start": null, "span_end": null, "passage": "title: str | None field title generator: Callable[[str, Field Info | Computed Field Info], str] | None str to upper: bool str min length: int extra: Extra Values | None 1 validation error for User age..."}, {"qid": "", "rank": 11, "path": ".github/actions/people/people.py", "score": 0.021723309302124696, "span_start": null, "span_end": null, "passage": "import requests import logging import subprocess import sys from collections import Counter from datetime import datetime, timedelta, timezone from pathlib import Path from typing import Any, Containe..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_typing_extra.py", "score": 0.02104071012170667, "span_start": null, "span_end": null, "passage": "Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedt..."}, {"qid": "", "rank": 13, "path": "tests/test_edge_cases.py", "score": 0.017148367631636505, "span_start": null, "span_end": null, "passage": "import functools import importlib.util import re import sys from abc import ABC, abstractmethod from collections.abc import Hashable from decimal import Decimal from enum import Enum, auto from typing..."}, {"qid": "", "rank": 14, "path": "pydantic/type_adapter.py", "score": 0.01600719327596246, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 15, "path": "tests/mypy/test_mypy.py", "score": 0.014198650120953109, "span_start": null, "span_end": null, "passage": "import dataclasses import importlib import os import re import sys from bisect import insort from pathlib import Path from typing import Any, List, Optional, Tuple, Union import pytest try: from mypy ..."}, {"qid": "", "rank": 16, "path": "pydantic/dataclasses.py", "score": 0.00950430796485661, "span_start": null, "span_end": null, "passage": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.009354081072278747, "span_start": null, "span_end": null, "passage": "A field metadata class to indicate that a field should be validated in strict mode. Attributes: strict: Whether to validate the field in strict mode. Example: ```python from typing extensions import A..."}, {"qid": "", "rank": 18, "path": "tests/benchmarks/test_discriminated_unions.py", "score": 0.009225378515424893, "span_start": null, "span_end": null, "passage": "from   future   import annotations from typing import Literal, Union import pytest from typing extensions import Annotated from pydantic import Base Model, Field, Type Adapter class Nested State(Base ..."}, {"qid": "", "rank": 19, "path": "pydantic/functional_serializers.py", "score": 0.00893664953276648, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 20, "path": "tests/test_docs.py", "score": 0.008815754896770382, "span_start": null, "span_end": null, "passage": "from   future   import annotations as  annotations import os import platform import re import subprocess import sys from datetime import datetime from pathlib import Path from tempfile import Named Te..."}], "latency_ms": 3.670215606689453, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_1", "query": "What are the rate limits for API calls?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.15109331788959973, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 2, "path": "docs/plugins/griffe_doclinks.py", "score": 0.14190271176477326, "span_start": null, "span_end": null, "passage": "....extensions import Visitor Extension from pymdownx.slugs import slugify DOCS PATH = Path(  file  ).parent.parent slugifier = slugify(case='lower') def find heading(content: str, slug: str, file path: ..."}, {"qid": "", "rank": 3, "path": "pydantic/root_model.py", "score": 0.13270932070093167, "span_start": null, "span_end": null, "passage": "A Pydantic `Base Model` for the root object of the model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fiel..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.12990038013348412, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 5, "path": "pydantic/warnings.py", "score": 0.1292192652767728, "span_start": null, "span_end": null, "passage": "This warning is raised when using deprecated functionality in Pydantic. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_typing_extra.py", "score": 0.12873874093949075, "span_start": null, "span_end": null, "passage": "...ython.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_dataclasses.py", "score": 0.12250840271361328, "span_start": null, "span_end": null, "passage": "Attributes:   pydantic config  : Pydantic-specific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   p..."}, {"qid": "", "rank": 8, "path": "pydantic/functional_serializers.py", "score": 0.11860000252879489, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.11661486515412958, "span_start": null, "span_end": null, "passage": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args..."}, {"qid": "", "rank": 10, "path": "pydantic/config.py", "score": 0.11639304313246304, "span_start": null, "span_end": null, "passage": "...], str] | None str to upper: bool str min length: int extra: Extra Values | None 1 validation error for User age Extra inputs are not permitted [type=extra forbidden, input value=20, input type=int] f..."}, {"qid": "", "rank": 11, "path": "pydantic/fields.py", "score": 0.11028955482083186, "span_start": null, "span_end": null, "passage": "...t: bool | None class  Field Info Inputs( From Field Info Inputs, total=False): `Field Info` is used for any field definition regardless of whether the [`Field()`][pydantic.fields.Field] function is ex..."}, {"qid": "", "rank": 12, "path": "pydantic/json_schema.py", "score": 0.10832923745444789, "span_start": null, "span_end": null, "passage": "...  core metadata,  core utils,  decorators,  internal dataclass,  mock val ser,  schema generation shared,  typing extra, ) from .annotated handlers import Get Json Schema Handler from .config import J..."}, {"qid": "", "rank": 13, "path": "pydantic/validate_call_decorator.py", "score": 0.10403540986969184, "span_start": null, "span_end": null, "passage": "Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value. Usage may be either as a plain decorator `@validate call` or with arguments `@validate c..."}, {"qid": "", "rank": 14, "path": "tests/test_pipeline.py", "score": 0.09047413934438565, "span_start": null, "span_end": null, "passage": "ta = Type Adapter[int](Annotated[int, transform(lambda x: x + 1)]) assert ta.validate python('1') == 2 def test not eq() -> None: ta = Type Adapter[int](Annotated[str, validate as(str).not eq('potato'..."}, {"qid": "", "rank": 15, "path": "pydantic/type_adapter.py", "score": 0.08535212608681327, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.08288769924426778, "span_start": null, "span_end": null, "passage": "Args: cls: The class of the Pydantic model to inspect. use inspect: Whether to skip usage of frames to find the object and use the `inspect` module instead. Returns: A mapping containing attribute nam..."}, {"qid": "", "rank": 17, "path": "pydantic/alias_generators.py", "score": 0.07867537381426985, "span_start": null, "span_end": null, "passage": "Args: snake: The string to convert. Returns: The Pascal Case string. Args: snake: The string to convert. Returns: The converted camel Case string. Args: camel: The string to convert. Returns: The conv..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.07685151106794162, "span_start": null, "span_end": null, "passage": "...ping extensions import deprecated from . internal import  repr from . internal. schema generation shared import Get Json Schema Handler as  Get Json Schema Handler from .json schema import Json Schema..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/mypy.py", "score": 0.0688835498257058, "span_start": null, "span_end": null, "passage": "...instance(sym.node, Type Info):  # pragma: no branch if any(get fullname(base) == BASEMODEL FULLNAME for base in sym.node.mro): return self. pydantic model class maker callback return None def get meta..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_validators.py", "score": 0.0677464072534503, "span_start": null, "span_end": null, "passage": "...> typing.Sequence[Any]: (This is necessary to distinguish between a submodule and an attribute when there is a conflict.). If the dotted path does not include a colon and the final item is not a valid..."}], "latency_ms": 6.479740142822266, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_2", "query": "How do I handle API errors properly?", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.1281374779749593, "span_start": null, "span_end": null, "passage": "import ast import re from functools import partial from pathlib import Path from typing import Tuple from griffe.dataclasses import Object as Griffe Object from griffe.extensions import Visitor Extens..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.10411143041071995, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.09727193017950647, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 4, "path": "tests/test_fastapi_json_schema.py", "score": 0.09210655911788776, "span_start": null, "span_end": null, "passage": "from   future   import annotations from dataclasses import dataclass from typing import Any from dirty equals import Has Repr, Is Instance, Is Str from pydantic import Base Model, Config Dict from pyd..."}, {"qid": "", "rank": 5, "path": "pydantic/_migration.py", "score": 0.07412281649977617, "span_start": null, "span_end": null, "passage": "import sys from typing import Any, Callable, Dict from .version import version short MOVED IN V2 = { 'pydantic.utils:version info': 'pydantic.version:version info', 'pydantic.error wrappers:Validation..."}, {"qid": "", "rank": 6, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/metaclass_args.py", "score": 0.07223150707749083, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 7, "path": "tests/mypy/outputs/1.0.1/mypy-plugin-very-strict_ini/metaclass_args.py", "score": 0.07223150707749083, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 8, "path": "tests/mypy/modules/metaclass_args.py", "score": 0.07223150707749083, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/error_wrappers.py", "score": 0.06189505331998419, "span_start": null, "span_end": null, "passage": "import json from typing import TYPE CHECKING, Any, Dict, Generator, List, Optional, Sequence, Tuple, Type, Union from pydantic.v1.json import pydantic encoder from pydantic.v1.utils import Representat..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/mypy.py", "score": 0.05131564884211277, "span_start": null, "span_end": null, "passage": "import sys from configparser import Config Parser from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as Typing Type, Union from mypy.errorcodes import Error Code from mypy.nodes ..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/validators.py", "score": 0.0340116984112755, "span_start": null, "span_end": null, "passage": "import math import re from collections import Ordered Dict, deque from collections.abc import Hashable as Collections Hashable from datetime import date, datetime, time, timedelta from decimal import ..."}, {"qid": "", "rank": 12, "path": "tests/test_edge_cases.py", "score": 0.03146275936569264, "span_start": null, "span_end": null, "passage": "import functools import importlib.util import re import sys from abc import ABC, abstractmethod from collections.abc import Hashable from decimal import Decimal from enum import Enum, auto from typing..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_typing_extra.py", "score": 0.03130976960545394, "span_start": null, "span_end": null, "passage": "Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedt..."}, {"qid": "", "rank": 14, "path": "pydantic/config.py", "score": 0.029179553844345372, "span_start": null, "span_end": null, "passage": "title: str | None field title generator: Callable[[str, Field Info | Computed Field Info], str] | None str to upper: bool str min length: int extra: Extra Values | None 1 validation error for User age..."}, {"qid": "", "rank": 15, "path": "tests/test_utils.py", "score": 0.02705915209493052, "span_start": null, "span_end": null, "passage": "import collections.abc import json import os import pickle import sys from copy import copy, deepcopy from typing import Callable, Dict, Generic, List, New Type, Tuple, Type Var, Union import pytest f..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/fields.py", "score": 0.02436690271990361, "span_start": null, "span_end": null, "passage": "import copy import re from collections import Counter as Collection Counter, defaultdict, deque from collections.abc import Callable, Hashable as Collections Hashable, Iterable as Collections Iterable..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_core_utils.py", "score": 0.02287834181869548, "span_start": null, "span_end": null, "passage": "from   future   import annotations import os from collections import defaultdict from typing import ( Any, Callable, Hashable, Type Var, Union, ) from pydantic core import Core Schema, core schema fro..."}, {"qid": "", "rank": 18, "path": "tests/test_types.py", "score": 0.02186484828831187, "span_start": null, "span_end": null, "passage": "import collections import itertools import json import math import os import re import sys import typing import uuid from collections import Ordered Dict, defaultdict, deque from dataclasses import da..."}, {"qid": "", "rank": 19, "path": "pydantic/type_adapter.py", "score": 0.019686444688651217, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/datetime_parse.py", "score": 0.018828661667291278, "span_start": null, "span_end": null, "passage": "import re from datetime import date, datetime, time, timedelta, timezone from typing import Dict, Optional, Type, Union from pydantic.v1 import errors date expr = r'(?P<year>\\d{4})-(?P<month>\\d{1,2})-..."}], "latency_ms": 12.059450149536133, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_3", "query": "What response format does the API use?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.13238058279344833, "span_start": null, "span_end": null, "passage": "Args: cls: The class of the Pydantic model to inspect. use inspect: Whether to skip usage of frames to find the object and use the `inspect` module instead. Returns: A mapping containing attribute nam..."}, {"qid": "", "rank": 2, "path": "docs/plugins/griffe_doclinks.py", "score": 0.130770899575594, "span_start": null, "span_end": null, "passage": "...se Value Error(f'heading with slug {slug!r} not found in {file path}') def insert at top(path: str, api link: str) -> str: rel file = path.rstrip('/') + '.md' file path = DOCS PATH / rel file content ..."}, {"qid": "", "rank": 3, "path": "pydantic/warnings.py", "score": 0.121937596906805, "span_start": null, "span_end": null, "passage": "This warning is raised when using deprecated functionality in Pydantic. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.1173824059113219, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.11679925585986864, "span_start": null, "span_end": null, "passage": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_dataclasses.py", "score": 0.11629923613401796, "span_start": null, "span_end": null, "passage": "Attributes:   pydantic config  : Pydantic-specific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   p..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.11299784984061406, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 8, "path": "pydantic/config.py", "score": 0.102980774774141, "span_start": null, "span_end": null, "passage": "...f [`Alias Generator`][pydantic.aliases.Alias Generator]. Defaults to `None`. When using a callable, the alias generator is used for both validation and serialization. If you want to use different alia..."}, {"qid": "", "rank": 9, "path": "pydantic/validate_call_decorator.py", "score": 0.09817288347486841, "span_start": null, "span_end": null, "passage": "Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value. Usage may be either as a plain decorator `@validate call` or with arguments `@validate c..."}, {"qid": "", "rank": 10, "path": "pydantic/fields.py", "score": 0.09390601107625748, "span_start": null, "span_end": null, "passage": "...rom Field Info Inputs, total=False): `Field Info` is used for any field definition regardless of whether the [`Field()`][pydantic.fields.Field] function is explicitly used. !!! warning You generally s..."}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.09277633644403083, "span_start": null, "span_end": null, "passage": "...TE = '#/$defs/{model}' This function should produce a remapping that replaces complex Defs Ref with the simpler ones from the prioritized choices such that applying the name remapping would result in ..."}, {"qid": "", "rank": 12, "path": "pydantic/root_model.py", "score": 0.09004264545966162, "span_start": null, "span_end": null, "passage": "A Pydantic `Base Model` for the root object of the model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fiel..."}, {"qid": "", "rank": 13, "path": "pydantic/functional_serializers.py", "score": 0.08656937936719487, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_typing_extra.py", "score": 0.0809312746452088, "span_start": null, "span_end": null, "passage": "...ython.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10..."}, {"qid": "", "rank": 15, "path": "pydantic/alias_generators.py", "score": 0.07424191739605156, "span_start": null, "span_end": null, "passage": "Args: snake: The string to convert. Returns: The Pascal Case string. Args: snake: The string to convert. Returns: The converted camel Case string. Args: camel: The string to convert. Returns: The conv..."}, {"qid": "", "rank": 16, "path": "tests/mypy/modules/generics.py", "score": 0.0718808146819163, "span_start": null, "span_end": null, "passage": "..., Dict, Generic, Optional, Type Var from pydantic import Base Model Tbody = Type Var('Tbody') class Response(Base Model, Generic[Tbody]): url: str body: Tbody class Json Body(Base Model): raw: str dat..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_validators.py", "score": 0.0704404123085032, "span_start": null, "span_end": null, "passage": "...> typing.Sequence[Any]: (This is necessary to distinguish between a submodule and an attribute when there is a conflict.). If the dotted path does not include a colon and the final item is not a valid..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.0699533446041375, "span_start": null, "span_end": null, "passage": "...et Json Schema Handler ) -> Json Schema Value: field schema = {} field schema.update(type='string', format='color') return field schema def original(self) -> Color Type: otherwise returns the hexadeci..."}, {"qid": "", "rank": 19, "path": "pydantic/type_adapter.py", "score": 0.06853468006928314, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/mypy.py", "score": 0.06449294495589095, "span_start": null, "span_end": null, "passage": "...x.args[1] if default args and default factory args: error default and default factory specified(ctx.api, ctx.context) return default any type if default args: default type = ctx.arg types[0][0] defaul..."}], "latency_ms": 6.886482238769531, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "docs/contributing.md"]}
{"qid": "lens_main_rag_api_4", "query": "How do I paginate through API results?", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.14907263171803095, "span_start": null, "span_end": null, "passage": "import ast import re from functools import partial from pathlib import Path from typing import Tuple from griffe.dataclasses import Object as Griffe Object from griffe.extensions import Visitor Extens..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.12112119864172466, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.11316425805559635, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 4, "path": "tests/mypy/outputs/1.0.1/mypy-plugin-very-strict_ini/metaclass_args.py", "score": 0.08403272034982125, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 5, "path": "tests/mypy/modules/metaclass_args.py", "score": 0.08403272034982125, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 6, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/metaclass_args.py", "score": 0.08403272034982125, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/mypy.py", "score": 0.059699620611442024, "span_start": null, "span_end": null, "passage": "import sys from configparser import Config Parser from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as Typing Type, Union from mypy.errorcodes import Error Code from mypy.nodes ..."}, {"qid": "", "rank": 8, "path": "pydantic/config.py", "score": 0.027685968928615814, "span_start": null, "span_end": null, "passage": "title: str | None field title generator: Callable[[str, Field Info | Computed Field Info], str] | None str to upper: bool str min length: int extra: Extra Values | None 1 validation error for User age..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_typing_extra.py", "score": 0.025494808892916103, "span_start": null, "span_end": null, "passage": "Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedt..."}, {"qid": "", "rank": 10, "path": "docs/plugins/using_update.py", "score": 0.021057110319336308, "span_start": null, "span_end": null, "passage": "from pathlib import Path from time import sleep import requests import tomli THIS DIR = Path(  file  ).parent session = requests.Session() def update lib(lib, *, retry=0): repo = lib['repo'] url = f'h..."}, {"qid": "", "rank": 11, "path": "tests/test_edge_cases.py", "score": 0.020778498114614914, "span_start": null, "span_end": null, "passage": "import functools import importlib.util import re import sys from abc import ABC, abstractmethod from collections.abc import Hashable from decimal import Decimal from enum import Enum, auto from typing..."}, {"qid": "", "rank": 12, "path": "release/make_history.py", "score": 0.020060751293556573, "span_start": null, "span_end": null, "passage": "from   future   import annotations as  annotations import argparse import json import re import subprocess import sys from datetime import date from pathlib import Path import requests def main(): roo..."}, {"qid": "", "rank": 13, "path": "pydantic/type_adapter.py", "score": 0.019395749056093762, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 14, "path": "tests/mypy/test_mypy.py", "score": 0.01720435618746681, "span_start": null, "span_end": null, "passage": "import dataclasses import importlib import os import re import sys from bisect import insort from pathlib import Path from typing import Any, List, Optional, Tuple, Union import pytest try: from mypy ..."}, {"qid": "", "rank": 15, "path": "pydantic/dataclasses.py", "score": 0.011516270782774568, "span_start": null, "span_end": null, "passage": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args..."}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.01133424242466806, "span_start": null, "span_end": null, "passage": "A field metadata class to indicate that a field should be validated in strict mode. Attributes: strict: Whether to validate the field in strict mode. Example: ```python from typing extensions import A..."}, {"qid": "", "rank": 17, "path": "tests/benchmarks/test_discriminated_unions.py", "score": 0.011178294879550105, "span_start": null, "span_end": null, "passage": "from   future   import annotations from typing import Literal, Union import pytest from typing extensions import Annotated from pydantic import Base Model, Field, Type Adapter class Nested State(Base ..."}, {"qid": "", "rank": 18, "path": "pydantic/functional_serializers.py", "score": 0.010828444984173798, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 19, "path": "tests/test_docs.py", "score": 0.01068195821528288, "span_start": null, "span_end": null, "passage": "from   future   import annotations as  annotations import os import platform import re import subprocess import sys from datetime import datetime from pathlib import Path from tempfile import Named Te..."}, {"qid": "", "rank": 20, "path": "tests/test_generics.py", "score": 0.010131217811329078, "span_start": null, "span_end": null, "passage": "import gc import itertools import json import platform import re import sys from collections import deque from enum import Enum, Int Enum from typing import ( Any, Callable, Class Var, Counter, Defaul..."}], "latency_ms": 3.701448440551758, "gold_paths": ["docs/migration.md", "docs/api/standard_library_types.md"]}
{"qid": "lens_main_rag_api_5", "query": "What headers are required for API calls?", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.13772516485073216, "span_start": null, "span_end": null, "passage": "....extensions import Visitor Extension from pymdownx.slugs import slugify DOCS PATH = Path(  file  ).parent.parent slugifier = slugify(case='lower') def find heading(content: str, slug: str, file path: ..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.12865231661969484, "span_start": null, "span_end": null, "passage": "...f. plugin data def  pydantic model class maker callback(self, ctx: Class Def Context) -> bool: transformer = Pydantic Model Transformer(ctx.cls, ctx.reason, ctx.api, self.plugin config) return transfo..."}, {"qid": "", "rank": 3, "path": "tests/test_pipeline.py", "score": 0.0891107559391015, "span_start": null, "span_end": null, "passage": "ta = Type Adapter[int](Annotated[int, transform(lambda x: x + 1)]) assert ta.validate python('1') == 2 def test not eq() -> None: ta = Type Adapter[int](Annotated[str, validate as(str).not eq('potato'..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.08725289582526746, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/mypy.py", "score": 0.07782627810747823, "span_start": null, "span_end": null, "passage": "...instance(sym.node, Type Info):  # pragma: no branch if any(get fullname(base) == BASEMODEL FULLNAME for base in sym.node.mro): return self. pydantic model class maker callback return None def get meta..."}, {"qid": "", "rank": 6, "path": "pydantic/networks.py", "score": 0.07390975029737255, "span_start": null, "span_end": null, "passage": "...ngth of the url. Defaults to `None`. allowed schemes: The allowed schemes. Defaults to `None`. host required: Whether the host is required. Defaults to `None`. default host: The default host. Defaults..."}, {"qid": "", "rank": 7, "path": "pydantic/warnings.py", "score": 0.07052607998092114, "span_start": null, "span_end": null, "passage": "This warning is raised when using deprecated functionality in Pydantic. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/annotated_types.py", "score": 0.06671811023612363, "span_start": null, "span_end": null, "passage": "...yping import TYPE CHECKING, Any, Dict, Frozen Set, Named Tuple, Type from pydantic.v1.fields import Required from pydantic.v1.main import Base Model, create model from pydantic.v1.typing import is typ..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_typing_extra.py", "score": 0.06487423825437703, "span_start": null, "span_end": null, "passage": "... type: Any) -> bool: return  check finalvar(ann type) or  check finalvar(get origin(ann type)) def parent frame namespace(*, parent depth: int = 2) -> dict[str, Any] | None: frame = sys. getframe(pare..."}, {"qid": "", "rank": 10, "path": "pydantic/config.py", "score": 0.058762928903851035, "span_start": null, "span_end": null, "passage": "...], str] | None str to upper: bool str min length: int extra: Extra Values | None 1 validation error for User age Extra inputs are not permitted [type=extra forbidden, input value=20, input type=int] f..."}, {"qid": "", "rank": 11, "path": "tests/test_annotated.py", "score": 0.053022197214885394, "span_start": null, "span_end": null, "passage": "...e( 'hint fn,value,expected repr', [ ( lambda: Annotated[int, Gt(0)], 5, 'Field Info(annotation=int, required=False, default=5, metadata=[Gt(gt=0)])', ), ( lambda: Annotated[int, Field(gt=0)], 5, 'Fiel..."}, {"qid": "", "rank": 12, "path": "tests/test_model_validator.py", "score": 0.05165588632113146, "span_start": null, "span_end": null, "passage": "...st.mark.parametrize('classmethod decorator', [classmethod, lambda x: x]) def test model validator before(classmethod decorator: Any) -> None: class Model(Base Model): x: int y: int @model validator(mo..."}, {"qid": "", "rank": 13, "path": "tests/test_decorators.py", "score": 0.04996143285300356, "span_start": null, "span_end": null, "passage": "... pydantic. internal. decorators import inspect annotated serializer, inspect validator def  two pos required args(a, b): pass def  two pos required args extra optional(a, b, c=1, d=2, *, e=3): pass de..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/utils.py", "score": 0.04368834385681424, "span_start": null, "span_end": null, "passage": "...mart deepcopy', 'Py Object Str', 'Representation', 'Getter Dict', 'Value Items', 'version info',  # required here to match behaviour in v1.3 'Class Attribute', 'path type', 'ROOT KEY', 'get unique dis..."}, {"qid": "", "rank": 15, "path": "tests/test_create_model.py", "score": 0.043237397213542465, "span_start": null, "span_end": null, "passage": "import platform import re from typing import Generic, Optional, Tuple, Type Var import pytest from typing extensions import Annotated from pydantic import ( Base Model, Config Dict, Field, Private Att..."}, {"qid": "", "rank": 16, "path": "tests/test_json_schema.py", "score": 0.04315538772592897, "span_start": null, "span_end": null, "passage": "...Config Dict from pydantic.dataclasses import dataclass from pydantic.errors import Pydantic Invalid For Json Schema from pydantic.json schema import ( DEFAULT REF TEMPLATE, Examples, Generate Json Sch..."}, {"qid": "", "rank": 17, "path": "tests/test_main.py", "score": 0.04049373526663564, "span_start": null, "span_end": null, "passage": "import json import platform import re import warnings from collections import defaultdict from copy import deepcopy from dataclasses import dataclass from datetime import date, datetime from enum impo..."}, {"qid": "", "rank": 18, "path": "tests/test_type_adapter.py", "score": 0.03881405797177849, "span_start": null, "span_end": null, "passage": "...from dataclasses import dataclass from datetime import date, datetime from typing import Any, Dict, Forward Ref, Generic, List, Named Tuple, Optional, Tuple, Type Var, Union import pytest from pydanti..."}, {"qid": "", "rank": 19, "path": "pydantic/root_model.py", "score": 0.03672772736688818, "span_start": null, "span_end": null, "passage": "A Pydantic `Base Model` for the root object of the model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fiel..."}, {"qid": "", "rank": 20, "path": "tests/test_config.py", "score": 0.03653267451227205, "span_start": null, "span_end": null, "passage": "...place(' ', '') elif isinstance(a, Iterable) and isinstance(b, Iterable): return all( equals(a , b ) for a , b  in zip(a, b)) else: raise Type Error(f'arguments must be both strings or both lists, not ..."}], "latency_ms": 3.7660598754882812, "gold_paths": ["docs/contributing.md", "docs/migration.md", "docs/api/standard_library_types.md"]}
{"qid": "lens_main_rag_api_6", "query": "How do I upload files via the API?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.14484158788111215, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 2, "path": "docs/plugins/griffe_doclinks.py", "score": 0.12170287861188478, "span_start": null, "span_end": null, "passage": "import ast import re from functools import partial from pathlib import Path from typing import Tuple from griffe.dataclasses import Object as Griffe Object from griffe.extensions import Visitor Extens..."}, {"qid": "", "rank": 3, "path": "pydantic/mypy.py", "score": 0.10206235928208271, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_dataclasses.py", "score": 0.09450972421956982, "span_start": null, "span_end": null, "passage": "Attributes:   pydantic config  : Pydantic-specific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   p..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.09282257455262102, "span_start": null, "span_end": null, "passage": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args..."}, {"qid": "", "rank": 6, "path": "pydantic/validate_call_decorator.py", "score": 0.0895579230763985, "span_start": null, "span_end": null, "passage": "Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value. Usage may be either as a plain decorator `@validate call` or with arguments `@validate c..."}, {"qid": "", "rank": 7, "path": "pydantic/functional_serializers.py", "score": 0.08768354094797623, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 8, "path": "pydantic/fields.py", "score": 0.08357851796398949, "span_start": null, "span_end": null, "passage": "annotation: type[Any] | None default factory: typing.Callable[[], Any] | None alias: str | None alias priority: int | None validation alias: str | Alias Path | Alias Choices | None serialization alias..."}, {"qid": "", "rank": 9, "path": "pydantic/root_model.py", "score": 0.08214113745305378, "span_start": null, "span_end": null, "passage": "A Pydantic `Base Model` for the root object of the model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fiel..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.07921020073039248, "span_start": null, "span_end": null, "passage": "from   future   import annotations as  annotations import dataclasses import inspect import math import re import warnings from collections import defaultdict from copy import deepcopy from dataclasse..."}, {"qid": "", "rank": 11, "path": "pydantic/config.py", "score": 0.07736772365200875, "span_start": null, "span_end": null, "passage": "title: str | None field title generator: Callable[[str, Field Info | Computed Field Info], str] | None str to upper: bool str min length: int extra: Extra Values | None 1 validation error for User age..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_typing_extra.py", "score": 0.07463187760201098, "span_start": null, "span_end": null, "passage": "Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedt..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.07135311142807704, "span_start": null, "span_end": null, "passage": "Args: cls: The class of the Pydantic model to inspect. use inspect: Whether to skip usage of frames to find the object and use the `inspect` module instead. Returns: A mapping containing attribute nam..."}, {"qid": "", "rank": 14, "path": "pydantic/alias_generators.py", "score": 0.06772696993159015, "span_start": null, "span_end": null, "passage": "Args: snake: The string to convert. Returns: The Pascal Case string. Args: snake: The string to convert. Returns: The converted camel Case string. Args: camel: The string to convert. Returns: The conv..."}, {"qid": "", "rank": 15, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/metaclass_args.py", "score": 0.06759963814129076, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 16, "path": "tests/mypy/outputs/1.0.1/mypy-plugin-very-strict_ini/metaclass_args.py", "score": 0.06759963814129076, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 17, "path": "tests/mypy/modules/metaclass_args.py", "score": 0.06759963814129076, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 18, "path": "tests/test_exports.py", "score": 0.06275046830537048, "span_start": null, "span_end": null, "passage": "import importlib import importlib.util import json import platform import sys from pathlib import Path from types import Module Type import pytest import pydantic @pytest.mark.filterwarnings('ignore::..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.06048243458607063, "span_start": null, "span_end": null, "passage": "import math import re from colorsys import hls to rgb, rgb to hls from typing import Any, Callable, Optional, Tuple, Type, Union, cast from pydantic core import Core Schema, Pydantic Custom Error, cor..."}, {"qid": "", "rank": 20, "path": "pydantic/type_adapter.py", "score": 0.06009216649021851, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}], "latency_ms": 3.1325817108154297, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_7", "query": "What is the API versioning strategy?", "results": [{"qid": "", "rank": 1, "path": "pydantic/warnings.py", "score": 0.12246316032797058, "span_start": null, "span_end": null, "passage": "This warning is raised when using deprecated functionality in Pydantic. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.12150161394856084, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.1186911090506837, "span_start": null, "span_end": null, "passage": "...fractions import Fraction from typing import Callable, Dict, Type, Union, cast, overload import hypothesis.strategies as st import pydantic import pydantic.color import pydantic.types from pydantic.v1..."}, {"qid": "", "rank": 4, "path": "docs/plugins/griffe_doclinks.py", "score": 0.1179282639444155, "span_start": null, "span_end": null, "passage": "... import Tuple from griffe.dataclasses import Object as Griffe Object from griffe.extensions import Visitor Extension from pymdownx.slugs import slugify DOCS PATH = Path(  file  ).parent.parent slugifi..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.10950027974464326, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_dataclasses.py", "score": 0.10783091060039102, "span_start": null, "span_end": null, "passage": "Attributes:   pydantic config  : Pydantic-specific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   p..."}, {"qid": "", "rank": 7, "path": "pydantic/fields.py", "score": 0.10226189175714248, "span_start": null, "span_end": null, "passage": "...rator: typing extensions.Callable[[str, Field Info], str] | None description: str | None examples: list[Any] | None exclude: bool | None gt: annotated types.Supports Gt | None ge: annotated types.Supp..."}, {"qid": "", "rank": 8, "path": "pydantic/root_model.py", "score": 0.10199558559062835, "span_start": null, "span_end": null, "passage": "A Pydantic `Base Model` for the root object of the model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fiel..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.09703568977275355, "span_start": null, "span_end": null, "passage": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args..."}, {"qid": "", "rank": 10, "path": "pydantic/config.py", "score": 0.08941985421778766, "span_start": null, "span_end": null, "passage": "...trary types allowed: bool 1 validation error for Model pet Input should be an instance of Pet [type=is instance of, input value='Hedwig', input type=str] from attributes: bool loc by alias: bool A cal..."}, {"qid": "", "rank": 11, "path": "pydantic/validate_call_decorator.py", "score": 0.0876779818632084, "span_start": null, "span_end": null, "passage": "Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value. Usage may be either as a plain decorator `@validate call` or with arguments `@validate c..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_typing_extra.py", "score": 0.08751650099838174, "span_start": null, "span_end": null, "passage": "...ython.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10..."}, {"qid": "", "rank": 13, "path": "pydantic/functional_serializers.py", "score": 0.08189527774843157, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.0813025532281681, "span_start": null, "span_end": null, "passage": "...port warnings from collections import defaultdict from copy import deepcopy from dataclasses import is dataclass from enum import Enum from typing import ( TYPE CHECKING, Any, Callable, Counter, Dict,..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_validators.py", "score": 0.0709535704999809, "span_start": null, "span_end": null, "passage": "...ence[Any], /, validator: core schema.Validator Function Wrap Handler, ) -> typing.Sequence[Any]: (This is necessary to distinguish between a submodule and an attribute when there is a conflict.). If t..."}, {"qid": "", "rank": 16, "path": "pydantic/color.py", "score": 0.0699813842381132, "span_start": null, "span_end": null, "passage": "...rgba' def   init  (self, value: Color Type) -> None: self. rgba: RGBA self. original: Color Type if isinstance(value, (tuple, list)): self. rgba = parse tuple(value) elif isinstance(value, str): self...."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.06985531368718306, "span_start": null, "span_end": null, "passage": "Args: cls: The class of the Pydantic model to inspect. use inspect: Whether to skip usage of frames to find the object and use the `inspect` module instead. Returns: A mapping containing attribute nam..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/mypy.py", "score": 0.06794710312574427, "span_start": null, "span_end": null, "passage": "import sys from configparser import Config Parser from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as Typing Type, Union from mypy.errorcodes import Error Code from mypy.nodes ..."}, {"qid": "", "rank": 19, "path": "pydantic/alias_generators.py", "score": 0.06630528977594084, "span_start": null, "span_end": null, "passage": "Args: snake: The string to convert. Returns: The Pascal Case string. Args: snake: The string to convert. Returns: The converted camel Case string. Args: camel: The string to convert. Returns: The conv..."}, {"qid": "", "rank": 20, "path": "pydantic/type_adapter.py", "score": 0.06602940858600431, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}], "latency_ms": 5.504608154296875, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_8", "query": "How do I filter API query results?", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.10909455915878458, "span_start": null, "span_end": null, "passage": "import ast import re from functools import partial from pathlib import Path from typing import Tuple from griffe.dataclasses import Object as Griffe Object from griffe.extensions import Visitor Extens..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.08863909906411267, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.08281603875121613, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 4, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/metaclass_args.py", "score": 0.06149695269898645, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 5, "path": "tests/mypy/modules/metaclass_args.py", "score": 0.06149695269898645, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 6, "path": "tests/mypy/outputs/1.0.1/mypy-plugin-very-strict_ini/metaclass_args.py", "score": 0.06149695269898645, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De..."}, {"qid": "", "rank": 7, "path": "pydantic/plugin/_schema_validator.py", "score": 0.056608411239161945, "span_start": null, "span_end": null, "passage": "Returns: If plugins are installed then return `Pluggable Schema Validator`, otherwise return `Schema Validator`.   slots   = ' schema validator', 'validate json', 'validate python', 'validate strings'..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/mypy.py", "score": 0.04368946678871971, "span_start": null, "span_end": null, "passage": "import sys from configparser import Config Parser from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as Typing Type, Union from mypy.errorcodes import Error Code from mypy.nodes ..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/networks.py", "score": 0.04285400021139551, "span_start": null, "span_end": null, "passage": "import re from ipaddress import ( IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network,  Base Address,  Base Network, ) from typing import ( TYPE CHECKING, Any, Collection,..."}, {"qid": "", "rank": 10, "path": "docs/extra/feedback.js", "score": 0.04169451621162902, "span_start": null, "span_end": null, "passage": "var feedback = document.forms.feedback feedback.hidden = false feedback.add Event Listener(\"submit\", function(ev) { ev.prevent Default() var data = ev.submitter.get Attribute(\"data-md-value\") feedback..."}, {"qid": "", "rank": 11, "path": ".github/actions/people/people.py", "score": 0.024134719033934313, "span_start": null, "span_end": null, "passage": "import requests import logging import subprocess import sys from collections import Counter from datetime import datetime, timedelta, timezone from pathlib import Path from typing import Any, Containe..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.02165708392885965, "span_start": null, "span_end": null, "passage": "import contextlib import datetime import ipaddress import json import math from fractions import Fraction from typing import Callable, Dict, Type, Union, cast, overload import hypothesis.strategies as..."}, {"qid": "", "rank": 13, "path": "pydantic/networks.py", "score": 0.02046735952521431, "span_start": null, "span_end": null, "passage": "Attributes: max length: The maximum length of the url. Defaults to `None`. allowed schemes: The allowed schemes. Defaults to `None`. host required: Whether the host is required. Defaults to `None`. de..."}, {"qid": "", "rank": 14, "path": "pydantic/config.py", "score": 0.02026118771998456, "span_start": null, "span_end": null, "passage": "title: str | None field title generator: Callable[[str, Field Info | Computed Field Info], str] | None str to upper: bool str min length: int extra: Extra Values | None 1 validation error for User age..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_typing_extra.py", "score": 0.01865764966349439, "span_start": null, "span_end": null, "passage": "Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedt..."}, {"qid": "", "rank": 16, "path": "docs/plugins/using_update.py", "score": 0.015410046371161168, "span_start": null, "span_end": null, "passage": "from pathlib import Path from time import sleep import requests import tomli THIS DIR = Path(  file  ).parent session = requests.Session() def update lib(lib, *, retry=0): repo = lib['repo'] url = f'h..."}, {"qid": "", "rank": 17, "path": "tests/test_edge_cases.py", "score": 0.015206151965460804, "span_start": null, "span_end": null, "passage": "import functools import importlib.util import re import sys from abc import ABC, abstractmethod from collections.abc import Hashable from decimal import Decimal from enum import Enum, auto from typing..."}, {"qid": "", "rank": 18, "path": "release/make_history.py", "score": 0.014680889399632578, "span_start": null, "span_end": null, "passage": "from   future   import annotations as  annotations import argparse import json import re import subprocess import sys from datetime import date from pathlib import Path import requests def main(): roo..."}, {"qid": "", "rank": 19, "path": "pydantic/type_adapter.py", "score": 0.014194226454868616, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 20, "path": "tests/mypy/test_mypy.py", "score": 0.012590518006232933, "span_start": null, "span_end": null, "passage": "import dataclasses import importlib import os import re import sys from bisect import insort from pathlib import Path from typing import Any, List, Optional, Tuple, Union import pytest try: from mypy ..."}], "latency_ms": 7.6656341552734375, "gold_paths": ["docs/help_with_pydantic.md", "docs/index.md", "docs/migration.md"]}
{"qid": "lens_main_rag_api_9", "query": "What are the API timeout recommendations?", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.16373955866087866, "span_start": null, "span_end": null, "passage": "....extensions import Visitor Extension from pymdownx.slugs import slugify DOCS PATH = Path(  file  ).parent.parent slugifier = slugify(case='lower') def find heading(content: str, slug: str, file path: ..."}, {"qid": "", "rank": 2, "path": "pydantic/warnings.py", "score": 0.15267929154335086, "span_start": null, "span_end": null, "passage": "... warning is raised when using deprecated functionality in Pydantic. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality wil..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.14148574432521133, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_dataclasses.py", "score": 0.14029235262483544, "span_start": null, "span_end": null, "passage": "Attributes:   pydantic config  : Pydantic-specific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   p..."}, {"qid": "", "rank": 5, "path": "pydantic/mypy.py", "score": 0.1393279462433312, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 6, "path": "pydantic/root_model.py", "score": 0.12353339147031078, "span_start": null, "span_end": null, "passage": "A Pydantic `Base Model` for the root object of the model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fiel..."}, {"qid": "", "rank": 7, "path": "pydantic/validate_call_decorator.py", "score": 0.12292325482817804, "span_start": null, "span_end": null, "passage": "Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value. Usage may be either as a plain decorator `@validate call` or with arguments `@validate c..."}, {"qid": "", "rank": 8, "path": "pydantic/dataclasses.py", "score": 0.12135269922249944, "span_start": null, "span_end": null, "passage": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args..."}, {"qid": "", "rank": 9, "path": "pydantic/functional_serializers.py", "score": 0.11641056845377316, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 10, "path": "pydantic/config.py", "score": 0.11545844072023437, "span_start": null, "span_end": null, "passage": "...r: bool str min length: int extra: Extra Values | None 1 validation error for User age Extra inputs are not permitted [type=extra forbidden, input value=20, input type=int] frozen: bool populate by na..."}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.11426672245215676, "span_start": null, "span_end": null, "passage": "...  core metadata,  core utils,  decorators,  internal dataclass,  mock val ser,  schema generation shared,  typing extra, ) from .annotated handlers import Get Json Schema Handler from .config import J..."}, {"qid": "", "rank": 12, "path": "pydantic/fields.py", "score": 0.10973865793059558, "span_start": null, "span_end": null, "passage": "...rom Field Info Inputs, total=False): `Field Info` is used for any field definition regardless of whether the [`Field()`][pydantic.fields.Field] function is explicitly used. !!! warning You generally s..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_typing_extra.py", "score": 0.1088187146772634, "span_start": null, "span_end": null, "passage": "...ython.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.09793613337118955, "span_start": null, "span_end": null, "passage": "Args: cls: The class of the Pydantic model to inspect. use inspect: Whether to skip usage of frames to find the object and use the `inspect` module instead. Returns: A mapping containing attribute nam..."}, {"qid": "", "rank": 15, "path": "pydantic/alias_generators.py", "score": 0.09295905150166642, "span_start": null, "span_end": null, "passage": "Args: snake: The string to convert. Returns: The Pascal Case string. Args: snake: The string to convert. Returns: The converted camel Case string. Args: camel: The string to convert. Returns: The conv..."}, {"qid": "", "rank": 16, "path": "pydantic/color.py", "score": 0.08615656614609778, "span_start": null, "span_end": null, "passage": "...ping extensions import deprecated from . internal import  repr from . internal. schema generation shared import Get Json Schema Handler as  Get Json Schema Handler from .json schema import Json Schema..."}, {"qid": "", "rank": 17, "path": "pydantic/type_adapter.py", "score": 0.07965893112598516, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_validators.py", "score": 0.07502879730993155, "span_start": null, "span_end": null, "passage": "...> typing.Sequence[Any]: (This is necessary to distinguish between a submodule and an attribute when there is a conflict.). If the dotted path does not include a colon and the final item is not a valid..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/mypy.py", "score": 0.06730782639498711, "span_start": null, "span_end": null, "passage": "... -> None: if self.plugin config.debug dataclass transform: return info metaclass = ctx.cls.info.declared metaclass assert info metaclass, \"callback not passed from 'get metaclass hook'\" if getattr(inf..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_model_construction.py", "score": 0.05650299473965047, "span_start": null, "span_end": null, "passage": "warns about overriding of decorators. Args: cls name: The name of the class to be created. bases: The base classes of the class to be created. namespace: The attribute dictionary of the class to be cr..."}], "latency_ms": 8.793354034423828, "gold_paths": ["tests/benchmarks/test_fastapi_startup_generics.py", "docs/contributing.md", "docs/index.md"]}
