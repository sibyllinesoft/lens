{"qid": "lens_main_rag_code_0", "query": "How does the authentication system work?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_dataclasses.py", "score": 0.13538358946122556, "span_start": null, "span_end": null, "passage": "Attributes:   pydantic config  : Pydantic-specific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   p..."}, {"qid": "", "rank": 2, "path": "pydantic/dataclasses.py", "score": 0.13069158218576776, "span_start": null, "span_end": null, "passage": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args..."}, {"qid": "", "rank": 3, "path": "pydantic/validate_call_decorator.py", "score": 0.11428275708767664, "span_start": null, "span_end": null, "passage": "Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value. Usage may be either as a plain decorator `@validate call` or with arguments `@validate c..."}, {"qid": "", "rank": 4, "path": "pydantic/functional_serializers.py", "score": 0.11189090218401579, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 5, "path": "pydantic/fields.py", "score": 0.10866108507880021, "span_start": null, "span_end": null, "passage": "...rom Field Info Inputs, total=False): `Field Info` is used for any field definition regardless of whether the [`Field()`][pydantic.fields.Field] function is explicitly used. !!! warning You generally s..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_typing_extra.py", "score": 0.10626002190851379, "span_start": null, "span_end": null, "passage": "...ython.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10..."}, {"qid": "", "rank": 7, "path": "pydantic/root_model.py", "score": 0.10481837157439255, "span_start": null, "span_end": null, "passage": "A Pydantic `Base Model` for the root object of the model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fiel..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.10014418762806072, "span_start": null, "span_end": null, "passage": "...TE = '#/$defs/{model}' This function should produce a remapping that replaces complex Defs Ref with the simpler ones from the prioritized choices such that applying the name remapping would result in ..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.09865308738308157, "span_start": null, "span_end": null, "passage": "...f [`Alias Generator`][pydantic.aliases.Alias Generator]. Defaults to `None`. When using a callable, the alias generator is used for both validation and serialization. If you want to use different alia..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.09105202555700868, "span_start": null, "span_end": null, "passage": "Args: cls: The class of the Pydantic model to inspect. use inspect: Whether to skip usage of frames to find the object and use the `inspect` module instead. Returns: A mapping containing attribute nam..."}, {"qid": "", "rank": 11, "path": "pydantic/alias_generators.py", "score": 0.08642479176715133, "span_start": null, "span_end": null, "passage": "Args: snake: The string to convert. Returns: The Pascal Case string. Args: snake: The string to convert. Returns: The converted camel Case string. Args: camel: The string to convert. Returns: The conv..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_validators.py", "score": 0.08199947117850762, "span_start": null, "span_end": null, "passage": "...> typing.Sequence[Any]: (This is necessary to distinguish between a submodule and an attribute when there is a conflict.). If the dotted path does not include a colon and the final item is not a valid..."}, {"qid": "", "rank": 13, "path": "pydantic/color.py", "score": 0.07718021077794257, "span_start": null, "span_end": null, "passage": "...schema.update(type='string', format='color') return field schema def original(self) -> Color Type: otherwise returns the hexadecimal representation of the color or raises `Value Error`. Args: fallback..."}, {"qid": "", "rank": 14, "path": "pydantic/type_adapter.py", "score": 0.07658485152250846, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.06866216735281631, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 16, "path": "pydantic/warnings.py", "score": 0.06328906050457658, "span_start": null, "span_end": null, "passage": "... warning is raised when using deprecated functionality in Pydantic. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality wil..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.053759364794959616, "span_start": null, "span_end": null, "passage": "... metadata class to indicate that a field should be validated in strict mode. Attributes: strict: Whether to validate the field in strict mode. Example: ```python from typing extensions import Annotate..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_model_construction.py", "score": 0.05364443041655459, "span_start": null, "span_end": null, "passage": "warns about overriding of decorators. Args: cls name: The name of the class to be created. bases: The base classes of the class to be created. namespace: The attribute dictionary of the class to be cr..."}, {"qid": "", "rank": 19, "path": "pydantic/deprecated/class_validators.py", "score": 0.05127848941288538, "span_start": null, "span_end": null, "passage": "Args:   field (str): The first field the validator should be called on; this is separate from `fields` to ensure an error is raised if you don't pass at least one. *fields (str): Additional field(s) t..."}, {"qid": "", "rank": 20, "path": "pydantic/main.py", "score": 0.046107589602142444, "span_start": null, "span_end": null, "passage": "A base class for creating Pydantic models. Attributes:   class vars  : The names of classvars defined on the model.   private attributes  : Metadata about the private attributes of the model.   signat..."}], "latency_ms": 10.601997375488281, "gold_paths": ["release/make_history.py", "tests/conftest.py", "tests/test_config.py"]}
{"qid": "lens_main_rag_code_1", "query": "What is the error handling strategy?", "results": [{"qid": "", "rank": 1, "path": "pydantic/warnings.py", "score": 0.13299405188493268, "span_start": null, "span_end": null, "passage": "This warning is raised when using deprecated functionality in Pydantic. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality..."}, {"qid": "", "rank": 2, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.13004594051134077, "span_start": null, "span_end": null, "passage": "...fractions import Fraction from typing import Callable, Dict, Type, Union, cast, overload import hypothesis.strategies as st import pydantic import pydantic.color import pydantic.types from pydantic.v1..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_dataclasses.py", "score": 0.11917843514882571, "span_start": null, "span_end": null, "passage": "Attributes:   pydantic config  : Pydantic-specific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   p..."}, {"qid": "", "rank": 4, "path": "pydantic/fields.py", "score": 0.11335399261261803, "span_start": null, "span_end": null, "passage": "...rator: typing extensions.Callable[[str, Field Info], str] | None description: str | None examples: list[Any] | None exclude: bool | None gt: annotated types.Supports Gt | None ge: annotated types.Supp..."}, {"qid": "", "rank": 5, "path": "pydantic/root_model.py", "score": 0.11076642286338183, "span_start": null, "span_end": null, "passage": "A Pydantic `Base Model` for the root object of the model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fiel..."}, {"qid": "", "rank": 6, "path": "pydantic/dataclasses.py", "score": 0.10843974727558552, "span_start": null, "span_end": null, "passage": "A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_typing_extra.py", "score": 0.09768472966835318, "span_start": null, "span_end": null, "passage": "...ython.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10..."}, {"qid": "", "rank": 8, "path": "pydantic/validate_call_decorator.py", "score": 0.09521761514118322, "span_start": null, "span_end": null, "passage": "Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value. Usage may be either as a plain decorator `@validate call` or with arguments `@validate c..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.09051229254635645, "span_start": null, "span_end": null, "passage": "...d Info], str] | None str to upper: bool str min length: int extra: Extra Values | None 1 validation error for User age Extra inputs are not permitted [type=extra forbidden, input value=20, input type=..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.09037094498547446, "span_start": null, "span_end": null, "passage": "...port warnings from collections import defaultdict from copy import deepcopy from dataclasses import is dataclass from enum import Enum from typing import ( TYPE CHECKING, Any, Callable, Counter, Dict,..."}, {"qid": "", "rank": 11, "path": "pydantic/functional_serializers.py", "score": 0.0889376428702064, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_validators.py", "score": 0.08406086214751789, "span_start": null, "span_end": null, "passage": "...ddress, IPv6Interface, IPv6Network from typing import Any from pydantic core import Pydantic Custom Error, core schema from pydantic core. pydantic core import Pydantic Known Error def sequence valida..."}, {"qid": "", "rank": 13, "path": "pydantic/color.py", "score": 0.08393110694010796, "span_start": null, "span_end": null, "passage": "...Callable, Optional, Tuple, Type, Union, cast from pydantic core import Core Schema, Pydantic Custom Error, core schema from typing extensions import deprecated from . internal import  repr from . inte..."}, {"qid": "", "rank": 14, "path": "tests/test_typing.py", "score": 0.07611683295308241, "span_start": null, "span_end": null, "passage": "...om pydantic. internal. typing extra import ( None Type, eval type lenient, get function type hints, is classvar, is literal type, is namedtuple, is none type, origin is union, parent frame namespace, ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.07586233433851335, "span_start": null, "span_end": null, "passage": "Args: cls: The class of the Pydantic model to inspect. use inspect: Whether to skip usage of frames to find the object and use the `inspect` module instead. Returns: A mapping containing attribute nam..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.07342388380899689, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 17, "path": "pydantic/alias_generators.py", "score": 0.07200703562680222, "span_start": null, "span_end": null, "passage": "Args: snake: The string to convert. Returns: The Pascal Case string. Args: snake: The string to convert. Returns: The converted camel Case string. Args: camel: The string to convert. Returns: The conv..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/errors.py", "score": 0.07162540306923092, "span_start": null, "span_end": null, "passage": "...ort TYPE CHECKING, Any, Callable, Sequence, Set, Tuple, Type, Union from pydantic.v1.typing import display as type if TYPE CHECKING: from pydantic.v1.typing import Dict Str Any   all   = ( 'Pydantic T..."}, {"qid": "", "rank": 19, "path": "pydantic/type_adapter.py", "score": 0.07072308753470918, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 20, "path": "pydantic/types.py", "score": 0.06613810289432845, "span_start": null, "span_end": null, "passage": "... metadata class to indicate that a field should be validated in strict mode. Attributes: strict: Whether to validate the field in strict mode. Example: ```python from typing extensions import Annotate..."}], "latency_ms": 7.842063903808594, "gold_paths": ["pydantic/error_wrappers.py", "pydantic/__init__.py", "pydantic/_migration.py"]}
{"qid": "lens_main_rag_code_2", "query": "How are database connections managed?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_typing_extra.py", "score": 0.06624734467116322, "span_start": null, "span_end": null, "passage": "... type: Any) -> bool: return  check finalvar(ann type) or  check finalvar(get origin(ann type)) def parent frame namespace(*, parent depth: int = 2) -> dict[str, Any] | None: frame = sys. getframe(pare..."}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.034737199540272296, "span_start": null, "span_end": null, "passage": "...r: bool str min length: int extra: Extra Values | None 1 validation error for User age Extra inputs are not permitted [type=extra forbidden, input value=20, input type=int] frozen: bool populate by na..."}, {"qid": "", "rank": 3, "path": "pydantic/functional_serializers.py", "score": 0.02559187399154258, "span_start": null, "span_end": null, "passage": "...serializers](../concepts/serialization.md#custom-serializers) for more information. Four signatures are supported: - `(self, value: Any, info: Field Serialization Info)` - `(self, value: Any, nxt: Ser..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_dataclasses.py", "score": 0.023162773505982448, "span_start": null, "span_end": null, "passage": "...ings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   pydantic core schema  : The pydantic-core schema used to build the Sch..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_utils.py", "score": 0.017848649799102435, "span_start": null, "span_end": null, "passage": "...alize indexes({'  all  ': True}, 4) {0: True, 1: True, 2: True, 3: True} Both `base` and `override` are converted to dictionaries if possible. Sets are converted to dictionaries with the sets entries ..."}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.017805268315270836, "span_start": null, "span_end": null, "passage": "...  core metadata,  core utils,  decorators,  internal dataclass,  mock val ser,  schema generation shared,  typing extra, ) from .annotated handlers import Get Json Schema Handler from .config import J..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/utils.py", "score": 0.014738649439390628, "span_start": null, "span_end": null, "passage": "...continue merged params[param.name] = param if var kw:  # if custom init has no var kw, fields which are not declared in it cannot be passed through allow names = config.allow population by field name ..."}, {"qid": "", "rank": 8, "path": "pydantic/root_model.py", "score": 0.013826046490374057, "span_start": null, "span_end": null, "passage": "... `Base Model` subclass, then the return type will likely be `dict[str, Any]`, as `model dump` calls are recursive. The return type could even be something different, in the case of a custom serializer..."}, {"qid": "", "rank": 9, "path": "tests/test_type_hints.py", "score": 0.012697635477964946, "span_start": null, "span_end": null, "passage": "... info < (3, 10), reason='requires python3.10 or higher to work properly'), ] @pytest.fixture(name='Parent Model', scope='session') def parent sub model fixture(): class Ultra Simple Model(Base Model):..."}, {"qid": "", "rank": 10, "path": "tests/test_deprecated_validate_arguments.py", "score": 0.011618877446129399, "span_start": null, "span_end": null, "passage": "... Pydantic User Error, match='\"v  args\", \"v  kwargs\", \"v  positional only\" and \"v  duplicate kwargs\" are not permitted', ): @validate arguments def foo1(v  args: int): pass with pytest.raises( Pydantic..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/config.py", "score": 0.011277633028942182, "span_start": null, "span_end": null, "passage": "...le[..., None]   all   = 'Base Config', 'Config Dict', 'get config', 'Extra', 'inherit config', 'prepare config' class Extra(str, Enum): allow = 'allow' ignore = 'ignore' forbid = 'forbid' if not compi..."}, {"qid": "", "rank": 12, "path": "pydantic/main.py", "score": 0.010495384125464882, "span_start": null, "span_end": null, "passage": "...or instantiating the model.   pydantic complete  : Whether model building is completed, or if there are still undefined fields.   pydantic core schema  : The pydantic-core schema used to build the Sch..."}, {"qid": "", "rank": 13, "path": "tests/test_utils.py", "score": 0.009938760933589794, "span_start": null, "span_end": null, "passage": "...t issubclass(A, str) is True @pytest.mark.skipif(sys.version info < (3, 9), reason='generic aliases are not available in python < 3.9') def test lenient issubclass with generic aliases(): from collect..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.008958220523254299, "span_start": null, "span_end": null, "passage": "... param name in ('field', 'config'): raise Pydantic User Error( 'The `field` and `config` parameters are not available in Pydantic V2, ' 'please use the `info` parameter instead.', code='validator-fiel..."}, {"qid": "", "rank": 15, "path": "pydantic/dataclasses.py", "score": 0.008539219659782948, "span_start": null, "span_end": null, "passage": "... init: A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses are validated on init. kw only: Determines if `  init  ` method parameters must be specified by keyw..."}, {"qid": "", "rank": 16, "path": "tests/test_deprecated.py", "score": 0.007064137090605326, "span_start": null, "span_end": null, "passage": "...th pytest.warns( Pydantic Deprecated Since20, match='Pydantic V1 style `@root validator` validators are deprecated.' ): class Pokemon List(Base Model): root: List[Pokemon] @root validator(pre=True) @c..."}, {"qid": "", "rank": 17, "path": "pydantic/type_adapter.py", "score": 0.0068813037393620595, "span_start": null, "span_end": null, "passage": "...s, where `  module  ` (always `typing.py`) is not useful. So instead we look at the globals in our parent stack frame. This works for the case where this function is called in a module that has the ta..."}, {"qid": "", "rank": 18, "path": "tests/test_validators.py", "score": 0.006433949707979163, "span_start": null, "span_end": null, "passage": "...idator, Wrap Validator V1 VALIDATOR DEPRECATION MATCH = r'Pydantic V1 style `@validator` validators are deprecated' def test annotated validator after() -> None: My Int = Annotated[int, After Validato..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/class_validators.py", "score": 0.006419662594760739, "span_start": null, "span_end": null, "passage": "...ction Type): raise Config Error( \"validators should be used with fields and keyword arguments, not bare. \"  # noqa: Q000 \"E.g. usage should be `@validator('<field name>', ...)`\" ) elif not all(isinsta..."}, {"qid": "", "rank": 20, "path": "pydantic/fields.py", "score": 0.006378033325210816, "span_start": null, "span_end": null, "passage": "...as a keyword argument. Returns: A new Field Info object with the given parameters. Example: This is how you can create a field with default value like this: ```python import pydantic class My Model(py..."}], "latency_ms": 7.139921188354492, "gold_paths": ["pydantic/__init__.py", "pydantic/_migration.py", "pydantic/networks.py"]}
{"qid": "lens_main_rag_code_3", "query": "What caching mechanisms are used?", "results": [{"qid": "", "rank": 1, "path": "pydantic/warnings.py", "score": 0.0996031902602644, "span_start": null, "span_end": null, "passage": "...nality will be removed. Attributes: message: Description of the warning. since: Pydantic version in what the deprecation was introduced. expected removal: Pydantic version in what the corresponding fu..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.07605269104736334, "span_start": null, "span_end": null, "passage": "... type: Any) -> bool: return  check finalvar(ann type) or  check finalvar(get origin(ann type)) def parent frame namespace(*, parent depth: int = 2) -> dict[str, Any] | None: frame = sys. getframe(pare..."}, {"qid": "", "rank": 3, "path": "pydantic/functional_serializers.py", "score": 0.0636717608387119, "span_start": null, "span_end": null, "passage": "...serializers](../concepts/serialization.md#custom-serializers) for more information. Four signatures are supported: - `(self, value: Any, info: Field Serialization Info)` - `(self, value: Any, nxt: Ser..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.05542827258692611, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_dataclasses.py", "score": 0.05463562408687604, "span_start": null, "span_end": null, "passage": "...ings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   pydantic core schema  : The pydantic-core schema used to build the Sch..."}, {"qid": "", "rank": 6, "path": "pydantic/config.py", "score": 0.0434119226051023, "span_start": null, "span_end": null, "passage": "...r: bool str min length: int extra: Extra Values | None 1 validation error for User age Extra inputs are not permitted [type=extra forbidden, input value=20, input type=int] frozen: bool populate by na..."}, {"qid": "", "rank": 7, "path": "pydantic/aliases.py", "score": 0.04149717354399611, "span_start": null, "span_end": null, "passage": "A data class used by `validation alias` as a convenience to create aliases. Attributes: path: A list of string or integer aliases. Returns: The list of aliases. Returns: The value at the specified pat"}, {"qid": "", "rank": 8, "path": "pydantic/deprecated/class_validators.py", "score": 0.04014071440243951, "span_start": null, "span_end": null, "passage": "Args:   field (str): The first field the validator should be called on; this is separate from `fields` to ensure an error is raised if you don't pass at least one. *fields (str): Additional field(s) t"}, {"qid": "", "rank": 9, "path": "tests/mypy/outputs/1.0.1/mypy-plugin-very-strict_ini/metaclass_args.py", "score": 0.03436733629276421, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De"}, {"qid": "", "rank": 10, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/metaclass_args.py", "score": 0.03436733629276421, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De"}, {"qid": "", "rank": 11, "path": "tests/mypy/modules/metaclass_args.py", "score": 0.03436733629276421, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De"}, {"qid": "", "rank": 12, "path": "pydantic/functional_validators.py", "score": 0.028241557263161177, "span_start": null, "span_end": null, "passage": "...tion to be used as a field validator. Raises: Pydantic User Error: - If `@field validator` is used bare (with no fields). - If the args passed to `@field validator` as fields are not strings. - If `@f..."}, {"qid": "", "rank": 13, "path": "pydantic/root_model.py", "score": 0.025975915105728407, "span_start": null, "span_end": null, "passage": "... `Base Model` subclass, then the return type will likely be `dict[str, Any]`, as `model dump` calls are recursive. The return type could even be something different, in the case of a custom serializer..."}, {"qid": "", "rank": 14, "path": "pydantic/dataclasses.py", "score": 0.024240886177354818, "span_start": null, "span_end": null, "passage": "... init: A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses are validated on init. kw only: Determines if `  init  ` method parameters must be specified by keyw..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/utils.py", "score": 0.023612024050858795, "span_start": null, "span_end": null, "passage": "...continue merged params[param.name] = param if var kw:  # if custom init has no var kw, fields which are not declared in it cannot be passed through allow names = config.allow population by field name ..."}, {"qid": "", "rank": 16, "path": "pydantic/type_adapter.py", "score": 0.021380059679845187, "span_start": null, "span_end": null, "passage": "...s, where `  module  ` (always `typing.py`) is not useful. So instead we look at the globals in our parent stack frame. This works for the case where this function is called in a module that has the ta..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.021366243108089995, "span_start": null, "span_end": null, "passage": "...  core metadata,  core utils,  decorators,  internal dataclass,  mock val ser,  schema generation shared,  typing extra, ) from .annotated handlers import Get Json Schema Handler from .config import J..."}, {"qid": "", "rank": 18, "path": "pydantic/fields.py", "score": 0.018473432699359298, "span_start": null, "span_end": null, "passage": "... foo: int = pydantic.Field(4) ``` This function is used internally to create a `Field Info` from a bare annotation like this: ```python import pydantic class My Model(pydantic.Base Model): foo: int  #..."}, {"qid": "", "rank": 19, "path": "pydantic/main.py", "score": 0.0180391092616523, "span_start": null, "span_end": null, "passage": "...or instantiating the model.   pydantic complete  : Whether model building is completed, or if there are still undefined fields.   pydantic core schema  : The pydantic-core schema used to build the Sch..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_utils.py", "score": 0.016398672869256694, "span_start": null, "span_end": null, "passage": "...alize indexes({'  all  ': True}, 4) {0: True, 1: True, 2: True, 3: True} Both `base` and `override` are converted to dictionaries if possible. Sets are converted to dictionaries with the sets entries ..."}], "latency_ms": 6.112813949584961, "gold_paths": ["pydantic/__init__.py", "pydantic/color.py", "pydantic/config.py"]}
{"qid": "lens_main_rag_code_4", "query": "How is input validation implemented?", "results": [{"qid": "", "rank": 1, "path": "tests/test_errors.py", "score": 0.18360385440309696, "span_start": null, "span_end": null, "passage": "import re import pytest from pydantic import Base Model, Pydantic User Error, Validation Error from pydantic.version import version short def test user error url(): with pytest.raises(Pydantic User Er..."}, {"qid": "", "rank": 2, "path": "tests/test_types.py", "score": 0.11614483519032218, "span_start": null, "span_end": null, "passage": "...Path from typing import ( Any, Callable, Counter, Default Dict, Deque, Dict, Frozen Set, Iterable, List, New Type, Optional, Pattern, Sequence, Set, Tuple, Type Var, Union, ) from uuid import UUID imp..."}, {"qid": "", "rank": 3, "path": "pydantic/config.py", "score": 0.101389377186896, "span_start": null, "span_end": null, "passage": "...mputed Field Info], str] | None str to upper: bool str min length: int extra: Extra Values | None 1 validation error for User age Extra inputs are not permitted [type=extra forbidden, input value=20, ..."}, {"qid": "", "rank": 4, "path": "tests/test_typing.py", "score": 0.08420947812140028, "span_start": null, "span_end": null, "passage": "...om pydantic. internal. typing extra import ( None Type, eval type lenient, get function type hints, is classvar, is literal type, is namedtuple, is none type, origin is union, parent frame namespace, ..."}, {"qid": "", "rank": 5, "path": "pydantic/annotated_handlers.py", "score": 0.0817884741617935, "span_start": null, "span_end": null, "passage": "Attributes: mode: Json schema mode, can be `validation` or `serialization`. This will call the next JSON schema modifying function up until it calls into `pydantic.json schema.Generate Json Schema`, w..."}, {"qid": "", "rank": 6, "path": "pydantic/plugin/__init__.py", "score": 0.07619195431108694, "span_start": null, "span_end": null, "passage": "...s from typing import Any, Callable, Named Tuple from pydantic core import Core Config, Core Schema, Validation Error from typing extensions import Literal, Protocol, Type Alias   all   = ( 'Pydantic P..."}, {"qid": "", "rank": 7, "path": "pydantic/functional_validators.py", "score": 0.07536132133731238, "span_start": null, "span_end": null, "passage": "A metadata class that indicates that a validation should be applied **after** the inner validation logic. Attributes: func: The validator function. Example: ```py from typing extensions import Annotat..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_typing_extra.py", "score": 0.07429462038470304, "span_start": null, "span_end": null, "passage": "..., \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10. if v is None: return False return v.  class   == Final.  class   ..."}, {"qid": "", "rank": 9, "path": "tests/test_type_alias_type.py", "score": 0.07429060774018026, "span_start": null, "span_end": null, "passage": "import datetime from dataclasses import dataclass from typing import Dict, Generic, List, Tuple, Type Var, Union import pytest from annotated types import Max Len from typing extensions import Annotat..."}, {"qid": "", "rank": 10, "path": "tests/test_datetime.py", "score": 0.0690987141662909, "span_start": null, "span_end": null, "passage": "...Aware Datetime, Base Model, Future Date, Future Datetime, Naive Datetime, Past Date, Past Datetime, Validation Error, condate, ) from .conftest import Err def create tz(minutes): return timezone(timed..."}, {"qid": "", "rank": 11, "path": "docs/plugins/conversion_table.py", "score": 0.06782443998106887, "span_start": null, "span_end": null, "passage": "... Dict from pydantic import Byte Size, Instance Of @dataclass class Row: field type: type[Any] | str input type: type[Any] | str python input: bool = False json input: bool = False strict: bool = False..."}, {"qid": "", "rank": 12, "path": "tests/test_validate_call.py", "score": 0.06656788919832789, "span_start": null, "span_end": null, "passage": "... sys from datetime import datetime, timezone from functools import partial from typing import Any, List, Tuple import pytest from pydantic core import Args Kwargs from typing extensions import Annotat..."}, {"qid": "", "rank": 13, "path": "tests/test_edge_cases.py", "score": 0.06580734774070432, "span_start": null, "span_end": null, "passage": "...imal from enum import Enum, auto from typing import ( Any, Dict, Forward Ref, Frozen Set, Generic, List, Optional, Sequence, Set, Tuple, Type, Type Var, Union, ) import pytest from dirty equals import..."}, {"qid": "", "rank": 14, "path": "tests/test_types_namedtuple.py", "score": 0.06113469706347863, "span_start": null, "span_end": null, "passage": "...ng Extensions Named Tuple from pydantic import Base Model, Config Dict, Positive Int, Type Adapter, Validation Error from pydantic.errors import Pydantic Schema Generation Error def test namedtuple si..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.05815771084432147, "span_start": null, "span_end": null, "passage": "...int | None = None, ) -> type[int]: [ { 'type': 'greater than', 'loc': ('constrained int',), 'msg': 'Input should be greater than 1', 'input': 0, 'ctx': {'gt': 1}, 'url': 'https://errors.pydantic.dev/2..."}, {"qid": "", "rank": 16, "path": "tests/test_aliases.py", "score": 0.058059769632692326, "span_start": null, "span_end": null, "passage": "from contextlib import nullcontext as does not raise from inspect import signature from typing import Any, Context Manager, List, Optional import pytest from dirty equals import Is Str from pydantic c..."}, {"qid": "", "rank": 17, "path": "tests/test_type_adapter.py", "score": 0.0570405166185119, "span_start": null, "span_end": null, "passage": "... dataclass from datetime import date, datetime from typing import Any, Dict, Forward Ref, Generic, List, Named Tuple, Optional, Tuple, Type Var, Union import pytest from pydantic core import Validatio..."}, {"qid": "", "rank": 18, "path": "tests/test_assert_in_validators.py", "score": 0.05397501082612793, "span_start": null, "span_end": null, "passage": "...flib import pprint import pytest from dirty equals import Has Repr from pydantic import Base Model, Validation Error, field validator def  pformat lines(obj): return pprint.pformat(obj).splitlines(kee..."}, {"qid": "", "rank": 19, "path": "tests/test_main.py", "score": 0.05111419435283765, "span_start": null, "span_end": null, "passage": "...from functools import partial from typing import ( Any, Callable, Class Var, Dict, Final, Generic, List, Mapping, Optional, Set, Type, Type Var, Union, get type hints, ) from uuid import UUID, uuid4 i..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.05106906317927056, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}], "latency_ms": 6.158113479614258, "gold_paths": ["pydantic/__init__.py", "pydantic/_migration.py", "pydantic/aliases.py"]}
{"qid": "lens_main_rag_code_5", "query": "What logging framework is configured?", "results": [{"qid": "", "rank": 1, "path": "pydantic/warnings.py", "score": 0.09858046141830742, "span_start": null, "span_end": null, "passage": "This warning is raised when using deprecated functionality in Pydantic. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality..."}, {"qid": "", "rank": 2, "path": ".github/actions/people/people.py", "score": 0.08381694242715981, "span_start": null, "span_end": null, "passage": "import requests import logging import subprocess import sys from collections import Counter from datetime import datetime, timedelta, timezone from pathlib import Path from typing import Any, Containe..."}, {"qid": "", "rank": 3, "path": "tests/test_typing.py", "score": 0.08222219719114489, "span_start": null, "span_end": null, "passage": "...om pydantic. internal. typing extra import ( None Type, eval type lenient, get function type hints, is classvar, is literal type, is namedtuple, is none type, origin is union, parent frame namespace, ..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_typing_extra.py", "score": 0.04605709611852545, "span_start": null, "span_end": null, "passage": "..., \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10. if v is None: return False return v.  class   == Final.  class   ..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/utils.py", "score": 0.034780495403725645, "span_start": null, "span_end": null, "passage": "...collections import Ordered Dict, defaultdict, deque from copy import deepcopy from itertools import islice, zip longest from types import Builtin Function Type, Code Type, Function Type, Generator Typ..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/typing.py", "score": 0.03308888808608139, "span_start": null, "span_end": null, "passage": "...Abstract Set, Any, Callable as Typing Callable, Class Var, Dict, Forward Ref, Generator, Iterable, List, Mapping, New Type, Optional, Sequence, Set, Tuple, Type, Type Var, Union,  eval type, cast, get..."}, {"qid": "", "rank": 7, "path": "pydantic/root_model.py", "score": 0.028782381553730724, "span_start": null, "span_end": null, "passage": "...e model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fields in the model.   pydantic extra  : Extra fields..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_dataclasses.py", "score": 0.027553782445782892, "span_start": null, "span_end": null, "passage": "...pecific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   pydantic core schema  : The pydantic-core sc..."}, {"qid": "", "rank": 9, "path": "pydantic/mypy.py", "score": 0.027125374194463404, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 10, "path": "tests/test_validators_dataclass.py", "score": 0.02677283696665089, "span_start": null, "span_end": null, "passage": "from dataclasses import asdict, is dataclass from typing import Any, List import pytest from dirty equals import Has Repr from pydantic import Validation Error, field validator, model validator from p..."}, {"qid": "", "rank": 11, "path": "pydantic/fields.py", "score": 0.026070333137447676, "span_start": null, "span_end": null, "passage": "...rator: typing extensions.Callable[[str, Field Info], str] | None description: str | None examples: list[Any] | None exclude: bool | None gt: annotated types.Supports Gt | None ge: annotated types.Supp..."}, {"qid": "", "rank": 12, "path": "pydantic/config.py", "score": 0.025375905574820116, "span_start": null, "span_end": null, "passage": "...trary types allowed: bool 1 validation error for Model pet Input should be an instance of Pet [type=is instance of, input value='Hedwig', input type=str] from attributes: bool loc by alias: bool A cal..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/annotated_types.py", "score": 0.025104354995363502, "span_start": null, "span_end": null, "passage": "...mport Required from pydantic.v1.main import Base Model, create model from pydantic.v1.typing import is typeddict, is typeddict special if TYPE CHECKING: from typing extensions import Typed Dict if sys..."}, {"qid": "", "rank": 14, "path": "pydantic/type_adapter.py", "score": 0.024224910490648587, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/fields.py", "score": 0.023623591172039392, "span_start": null, "span_end": null, "passage": "..., Any, Counter, Default Dict, Deque, Dict, Forward Ref, Frozen Set, Generator, Iterable, Iterator, List, Mapping, Optional, Pattern, Sequence, Set, Tuple, Type, Type Var, Union, ) from typing extensio..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_validators.py", "score": 0.0232586683682351, "span_start": null, "span_end": null, "passage": "...ence[Any], /, validator: core schema.Validator Function Wrap Handler, ) -> typing.Sequence[Any]: (This is necessary to distinguish between a submodule and an attribute when there is a conflict.). If t..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_model_construction.py", "score": 0.02322324574825251, "span_start": null, "span_end": null, "passage": "...ributes  ') if private attributes and item in private attributes: return private attributes[item] raise Attribute Error(item) @classmethod def   prepare  (cls, *args: Any, **kwargs: Any) -> dict[str, ..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_utils.py", "score": 0.023001604902975686, "span_start": null, "span_end": null, "passage": "...n Function Type, Lambda Type, weakref.ref, Code Type, Module Type, Not Implemented.  class  , Ellipsis.  class  , } BUILTIN COLLECTIONS: set[type[Any]] = { list, set, tuple, frozenset, dict, Ordered D..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/main.py", "score": 0.022431080647707786, "span_start": null, "span_end": null, "passage": "...s, resolve bases from typing import ( TYPE CHECKING, Abstract Set, Any, Callable, Class Var, Dict, List, Mapping, Optional, Tuple, Type, Type Var, Union, cast, no type check, overload, ) from typing e..."}, {"qid": "", "rank": 20, "path": "tests/test_deprecated_fields.py", "score": 0.020881453721186417, "span_start": null, "span_end": null, "passage": "...ss Model(Base Model): a: Annotated[int, Field(deprecated='')] b: Annotated[int, Field(deprecated='This is deprecated')] c: Annotated[int, Field(deprecated=None)] assert Model.model json schema() == { ..."}], "latency_ms": 8.714914321899414, "gold_paths": ["pydantic/config.py", "pydantic/dataclasses.py", "pydantic/fields.py"]}
{"qid": "lens_main_rag_code_6", "query": "How are API responses formatted?", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.16519466693363366, "span_start": null, "span_end": null, "passage": "....extensions import Visitor Extension from pymdownx.slugs import slugify DOCS PATH = Path(  file  ).parent.parent slugifier = slugify(case='lower') def find heading(content: str, slug: str, file path: ..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.1361934243421957, "span_start": null, "span_end": null, "passage": "... ctx: Class Def Context) -> bool: transformer = Pydantic Model Transformer(ctx.cls, ctx.reason, ctx.api, self.plugin config) return transformer.transform() def  pydantic model metaclass marker callbac..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.06926817119448134, "span_start": null, "span_end": null, "passage": "... Pydantic, please do not rely on this implementation. See `Get Json Schema Handler` for the handler API. This returns the input json schema if there is no `$ref` in json schema. Args: maybe ref json s..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/mypy.py", "score": 0.06583702680500966, "span_start": null, "span_end": null, "passage": "... -> None: if self.plugin config.debug dataclass transform: return info metaclass = ctx.cls.info.declared metaclass assert info metaclass, \"callback not passed from 'get metaclass hook'\" if getattr(inf..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_typing_extra.py", "score": 0.05295112311825956, "span_start": null, "span_end": null, "passage": "... type: Any) -> bool: return  check finalvar(ann type) or  check finalvar(get origin(ann type)) def parent frame namespace(*, parent depth: int = 2) -> dict[str, Any] | None: frame = sys. getframe(pare..."}, {"qid": "", "rank": 6, "path": "pydantic/config.py", "score": 0.04618786926075844, "span_start": null, "span_end": null, "passage": "...r: bool str min length: int extra: Extra Values | None 1 validation error for User age Extra inputs are not permitted [type=extra forbidden, input value=20, input type=int] frozen: bool populate by na..."}, {"qid": "", "rank": 7, "path": "docs/plugins/using_update.py", "score": 0.023812468994017403, "span_start": null, "span_end": null, "passage": "... pathlib import Path from time import sleep import requests import tomli THIS DIR = Path(  file  ).parent session = requests.Session() def update lib(lib, *, retry=0): repo = lib['repo'] url = f'https..."}, {"qid": "", "rank": 8, "path": "tests/mypy/test_mypy.py", "score": 0.022912135383069993, "span_start": null, "span_end": null, "passage": "...mport Path from typing import Any, List, Optional, Tuple, Union import pytest try: from mypy import api as mypy api from mypy.version import   version   as mypy version from pydantic.version import pa..."}, {"qid": "", "rank": 9, "path": "release/make_history.py", "score": 0.02268573469626799, "span_start": null, "span_end": null, "passage": "...atetime import date from pathlib import Path import requests def main(): root dir = Path(  file  ).parent.parent parser = argparse.Argument Parser() parser.add argument('--preview', help='print previe..."}, {"qid": "", "rank": 10, "path": "pydantic/functional_serializers.py", "score": 0.020455438286314055, "span_start": null, "span_end": null, "passage": "...serializers](../concepts/serialization.md#custom-serializers) for more information. Four signatures are supported: - `(self, value: Any, info: Field Serialization Info)` - `(self, value: Any, nxt: Ser..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_dataclasses.py", "score": 0.018513872182555832, "span_start": null, "span_end": null, "passage": "...ings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   pydantic core schema  : The pydantic-core schema used to build the Sch..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_utils.py", "score": 0.014266323543958834, "span_start": null, "span_end": null, "passage": "...alize indexes({'  all  ': True}, 4) {0: True, 1: True, 2: True, 3: True} Both `base` and `override` are converted to dictionaries if possible. Sets are converted to dictionaries with the sets entries ..."}, {"qid": "", "rank": 13, "path": "pydantic/json_schema.py", "score": 0.014231648972429635, "span_start": null, "span_end": null, "passage": "...  core metadata,  core utils,  decorators,  internal dataclass,  mock val ser,  schema generation shared,  typing extra, ) from .annotated handlers import Get Json Schema Handler from .config import J..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/utils.py", "score": 0.01178051807111527, "span_start": null, "span_end": null, "passage": "...continue merged params[param.name] = param if var kw:  # if custom init has no var kw, fields which are not declared in it cannot be passed through allow names = config.allow population by field name ..."}, {"qid": "", "rank": 15, "path": "pydantic/type_adapter.py", "score": 0.011691851098487183, "span_start": null, "span_end": null, "passage": "...s, where `  module  ` (always `typing.py`) is not useful. So instead we look at the globals in our parent stack frame. This works for the case where this function is called in a module that has the ta..."}, {"qid": "", "rank": 16, "path": "tests/test_exports.py", "score": 0.011159242247546067, "span_start": null, "span_end": null, "passage": "...t.mark.parametrize(('attr name', 'value'), list(pydantic. dynamic imports.items())) def test public api dynamic imports(attr name, value): package, module name = value if module name == '  module  ': ..."}, {"qid": "", "rank": 17, "path": "pydantic/root_model.py", "score": 0.011051079761529742, "span_start": null, "span_end": null, "passage": "... `Base Model` subclass, then the return type will likely be `dict[str, Any]`, as `model dump` calls are recursive. The return type could even be something different, in the case of a custom serializer..."}, {"qid": "", "rank": 18, "path": "tests/test_type_hints.py", "score": 0.010149147303064224, "span_start": null, "span_end": null, "passage": "... info < (3, 10), reason='requires python3.10 or higher to work properly'), ] @pytest.fixture(name='Parent Model', scope='session') def parent sub model fixture(): class Ultra Simple Model(Base Model):..."}, {"qid": "", "rank": 19, "path": "tests/test_deprecated_validate_arguments.py", "score": 0.009286902187549432, "span_start": null, "span_end": null, "passage": "... Pydantic User Error, match='\"v  args\", \"v  kwargs\", \"v  positional only\" and \"v  duplicate kwargs\" are not permitted', ): @validate arguments def foo1(v  args: int): pass with pytest.raises( Pydantic..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/config.py", "score": 0.00901414747960467, "span_start": null, "span_end": null, "passage": "...le[..., None]   all   = 'Base Config', 'Config Dict', 'get config', 'Extra', 'inherit config', 'prepare config' class Extra(str, Enum): allow = 'allow' ignore = 'ignore' forbid = 'forbid' if not compi..."}], "latency_ms": 4.018306732177734, "gold_paths": ["pydantic/json.py", "pydantic/__init__.py", "pydantic/_migration.py"]}
{"qid": "lens_main_rag_code_8", "query": "How is configuration managed?", "results": [{"qid": "", "rank": 1, "path": "tests/test_typing.py", "score": 0.09159315258713972, "span_start": null, "span_end": null, "passage": "...om pydantic. internal. typing extra import ( None Type, eval type lenient, get function type hints, is classvar, is literal type, is namedtuple, is none type, origin is union, parent frame namespace, ..."}, {"qid": "", "rank": 2, "path": "pydantic/validate_call_decorator.py", "score": 0.07384415768196213, "span_start": null, "span_end": null, "passage": "...all` or with arguments `@validate call(...)`. Args: func: The function to be decorated. config: The configuration dictionary. validate return: Whether to validate the return value. Returns: The decora..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_typing_extra.py", "score": 0.06950161569914509, "span_start": null, "span_end": null, "passage": "..., \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10. if v is None: return False return v.  class   == Final.  class   ..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_dataclasses.py", "score": 0.054054745561851955, "span_start": null, "span_end": null, "passage": "Attributes:   pydantic config  : Pydantic-specific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   p..."}, {"qid": "", "rank": 5, "path": "pydantic/config.py", "score": 0.042103342418150856, "span_start": null, "span_end": null, "passage": "...trary types allowed: bool 1 validation error for Model pet Input should be an instance of Pet [type=is instance of, input value='Hedwig', input type=str] from attributes: bool loc by alias: bool A cal..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/typing.py", "score": 0.03686006551687775, "span_start": null, "span_end": null, "passage": "...Abstract Set, Any, Callable as Typing Callable, Class Var, Dict, Forward Ref, Generator, Iterable, List, Mapping, New Type, Optional, Sequence, Set, Tuple, Type, Type Var, Union,  eval type, cast, get..."}, {"qid": "", "rank": 7, "path": "pydantic/fields.py", "score": 0.03431687987073344, "span_start": null, "span_end": null, "passage": "...rator: typing extensions.Callable[[str, Field Info], str] | None description: str | None examples: list[Any] | None exclude: bool | None gt: annotated types.Supports Gt | None ge: annotated types.Supp..."}, {"qid": "", "rank": 8, "path": "pydantic/mypy.py", "score": 0.03318429170045903, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/utils.py", "score": 0.03222598698612494, "span_start": null, "span_end": null, "passage": "...collections import Ordered Dict, defaultdict, deque from copy import deepcopy from itertools import islice, zip longest from types import Builtin Function Type, Code Type, Function Type, Generator Typ..."}, {"qid": "", "rank": 10, "path": "pydantic/root_model.py", "score": 0.032062741638289045, "span_start": null, "span_end": null, "passage": "...e model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fields in the model.   pydantic extra  : Extra fields..."}, {"qid": "", "rank": 11, "path": "tests/test_validators_dataclass.py", "score": 0.02982416701631474, "span_start": null, "span_end": null, "passage": "from dataclasses import asdict, is dataclass from typing import Any, List import pytest from dirty equals import Has Repr from pydantic import Validation Error, field validator, model validator from p..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.028075815393384218, "span_start": null, "span_end": null, "passage": "import sys from configparser import Config Parser from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as Typing Type, Union from mypy.errorcodes import Error Code from mypy.nodes ..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/annotated_types.py", "score": 0.027965526296342885, "span_start": null, "span_end": null, "passage": "...mport Required from pydantic.v1.main import Base Model, create model from pydantic.v1.typing import is typeddict, is typeddict special if TYPE CHECKING: from typing extensions import Typed Dict if sys..."}, {"qid": "", "rank": 14, "path": "pydantic/type_adapter.py", "score": 0.026317427532718617, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/fields.py", "score": 0.026315998170745092, "span_start": null, "span_end": null, "passage": "..., Any, Counter, Default Dict, Deque, Dict, Forward Ref, Frozen Set, Generator, Iterable, Iterator, List, Mapping, Optional, Pattern, Sequence, Set, Tuple, Type, Type Var, Union, ) from typing extensio..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_validators.py", "score": 0.025909484708526727, "span_start": null, "span_end": null, "passage": "...ence[Any], /, validator: core schema.Validator Function Wrap Handler, ) -> typing.Sequence[Any]: (This is necessary to distinguish between a submodule and an attribute when there is a conflict.). If t..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_model_construction.py", "score": 0.025870024933089698, "span_start": null, "span_end": null, "passage": "...ributes  ') if private attributes and item in private attributes: return private attributes[item] raise Attribute Error(item) @classmethod def   prepare  (cls, *args: Any, **kwargs: Any) -> dict[str, ..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_utils.py", "score": 0.025623123433804917, "span_start": null, "span_end": null, "passage": "...n Function Type, Lambda Type, weakref.ref, Code Type, Module Type, Not Implemented.  class  , Ellipsis.  class  , } BUILTIN COLLECTIONS: set[type[Any]] = { list, set, tuple, frozenset, dict, Ordered D..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/main.py", "score": 0.024987575893693145, "span_start": null, "span_end": null, "passage": "...s, resolve bases from typing import ( TYPE CHECKING, Abstract Set, Any, Callable, Class Var, Dict, List, Mapping, Optional, Tuple, Type, Type Var, Union, cast, no type check, overload, ) from typing e..."}, {"qid": "", "rank": 20, "path": "tests/test_deprecated_fields.py", "score": 0.023261336260324433, "span_start": null, "span_end": null, "passage": "...ss Model(Base Model): a: Annotated[int, Field(deprecated='')] b: Annotated[int, Field(deprecated='This is deprecated')] c: Annotated[int, Field(deprecated=None)] assert Model.model json schema() == { ..."}], "latency_ms": 4.237890243530273, "gold_paths": ["pydantic/env_settings.py", "pydantic/__init__.py", "pydantic/_migration.py"]}
{"qid": "lens_main_rag_code_9", "query": "What testing strategy is used?", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.1269724367520945, "span_start": null, "span_end": null, "passage": "...tions import Fraction from typing import Callable, Dict, Type, Union, cast, overload import hypothesis.strategies as st import pydantic import pydantic.color import pydantic.types from pydantic.v1.uti..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.07965744774333416, "span_start": null, "span_end": null, "passage": "..., \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10. if v is None: return False return v.  class   == Final.  class   ..."}, {"qid": "", "rank": 3, "path": "pydantic/warnings.py", "score": 0.07906434641938735, "span_start": null, "span_end": null, "passage": "This warning is raised when using deprecated functionality in Pydantic. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.07090954288382054, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting modifications to the definition schema. Used internally by Pydantic, please do not rely on this implementation. See `Ge..."}, {"qid": "", "rank": 5, "path": "tests/test_typing.py", "score": 0.07016848709067453, "span_start": null, "span_end": null, "passage": "...om pydantic. internal. typing extra import ( None Type, eval type lenient, get function type hints, is classvar, is literal type, is namedtuple, is none type, origin is union, parent frame namespace, ..."}, {"qid": "", "rank": 6, "path": "pydantic/functional_serializers.py", "score": 0.053823039665187214, "span_start": null, "span_end": null, "passage": "This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of `list`, which will be serialized into a space-delimited string. ```python from typin..."}, {"qid": "", "rank": 7, "path": "pydantic/root_model.py", "score": 0.050223860944917605, "span_start": null, "span_end": null, "passage": "...e model. Attributes: root: The root object of the model.   pydantic root model  : Whether the model is a Root Model.   pydantic private  : Private fields in the model.   pydantic extra  : Extra fields..."}, {"qid": "", "rank": 8, "path": "pydantic/fields.py", "score": 0.04910168121984181, "span_start": null, "span_end": null, "passage": "...rator: typing extensions.Callable[[str, Field Info], str] | None description: str | None examples: list[Any] | None exclude: bool | None gt: annotated types.Supports Gt | None ge: annotated types.Supp..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_dataclasses.py", "score": 0.043717458669450204, "span_start": null, "span_end": null, "passage": "...pecific configuration settings for the dataclass.   pydantic complete  : Whether dataclass building is completed, or if there are still undefined fields.   pydantic core schema  : The pydantic-core sc..."}, {"qid": "", "rank": 10, "path": "pydantic/functional_validators.py", "score": 0.04288012273934306, "span_start": null, "span_end": null, "passage": "...: a: str @field validator('a') @classmethod def ensure foobar(cls, v: Any): if 'foobar' not in v: raise Value Error('\"foobar\" not found in a') return v print(repr(Model(a='this is foobar good'))) try:..."}, {"qid": "", "rank": 11, "path": "pydantic/deprecated/class_validators.py", "score": 0.03848340405669157, "span_start": null, "span_end": null, "passage": "Args:   field (str): The first field the validator should be called on; this is separate from `fields` to ensure an error is raised if you don't pass at least one. *fields (str): Additional field(s) t..."}, {"qid": "", "rank": 12, "path": "pydantic/config.py", "score": 0.03456298015977128, "span_start": null, "span_end": null, "passage": "...trary types allowed: bool 1 validation error for Model pet Input should be an instance of Pet [type=is instance of, input value='Hedwig', input type=str] from attributes: bool loc by alias: bool A cal..."}, {"qid": "", "rank": 13, "path": "pydantic/aliases.py", "score": 0.0303328657181366, "span_start": null, "span_end": null, "passage": "A data class used by `validation alias` as a convenience to create aliases. Attributes: path: A list of string or integer aliases. Returns: The list of aliases. Returns: The value at the specified pat..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/utils.py", "score": 0.029729089708114245, "span_start": null, "span_end": null, "passage": "...collections import Ordered Dict, defaultdict, deque from copy import deepcopy from itertools import islice, zip longest from types import Builtin Function Type, Code Type, Function Type, Generator Typ..."}, {"qid": "", "rank": 15, "path": "pydantic/dataclasses.py", "score": 0.026920596045741457, "span_start": null, "span_end": null, "passage": "...dantic-enhanced dataclass, similar to the standard Python `dataclass`, but with added validation. This function should be used similarly to `dataclasses.dataclass`. Args:  cls: The target `dataclass`...."}, {"qid": "", "rank": 16, "path": "pydantic/v1/typing.py", "score": 0.026538233567087274, "span_start": null, "span_end": null, "passage": "...Abstract Set, Any, Callable as Typing Callable, Class Var, Dict, Forward Ref, Generator, Iterable, List, Mapping, New Type, Optional, Sequence, Set, Tuple, Type, Type Var, Union,  eval type, cast, get..."}, {"qid": "", "rank": 17, "path": "pydantic/type_adapter.py", "score": 0.023710760372733845, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ..."}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.022670697583652043, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 19, "path": "tests/mypy/outputs/1.0.1/mypy-plugin-very-strict_ini/metaclass_args.py", "score": 0.02227498038551269, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De"}, {"qid": "", "rank": 20, "path": "tests/mypy/modules/metaclass_args.py", "score": 0.02227498038551269, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model, Field class Config Class Used(Base Model): i: int = Field(2, alias='j') class Config: populate by name = True Config Class Used(i=None) class Metaclass Arguments No De"}], "latency_ms": 3.1518936157226562, "gold_paths": ["pydantic/_migration.py", "pydantic/color.py", "pydantic/dataclasses.py"]}
