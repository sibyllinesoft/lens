{"qid": "lens_main_regex_0", "query": "import requests", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/using_update.py", "score": 0.1092687947104744, "span_start": null, "span_end": null, "passage": "from pathlib import Path from time import sleep import requests import tomli THIS DIR = Path(  file  ).parent session = requests.Session() def update lib(lib, *, retry=0): repo = lib['repo'] url = f'h..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_validate_call.py", "score": 0.07021851217929723, "span_start": null, "span_end": null, "passage": "from   future   import annotations as  annotations import inspect from functools import partial from typing import Any, Awaitable, Callable import pydantic core from ..config import Config Dict from ...."}, {"qid": "", "rank": 3, "path": "release/make_history.py", "score": 0.05776220960051813, "span_start": null, "span_end": null, "passage": "from   future   import annotations as  annotations import argparse import json import re import subprocess import sys from datetime import date from pathlib import Path import requests def main(): roo..."}, {"qid": "", "rank": 4, "path": ".github/actions/people/people.py", "score": 0.0374293000306713, "span_start": null, "span_end": null, "passage": "import requests import logging import subprocess import sys from collections import Counter from datetime import datetime, timedelta, timezone from pathlib import Path from typing import Any, Containe..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/version.py", "score": 0.03403644094102113, "span_start": null, "span_end": null, "passage": "  all   = 'compiled', 'VERSION', 'version info' VERSION = '1.10.17' try: import cython  # type: ignore except Import Error: compiled: bool = False else:  # pragma: no cover try: compiled = cython.comp..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/__init__.py", "score": 0.027775241342871824, "span_start": null, "span_end": null, "passage": "from pydantic.v1 import dataclasses from pydantic.v1.annotated types import create model from namedtuple, create model from typeddict from pydantic.v1.class validators import root validator, validator..."}, {"qid": "", "rank": 7, "path": "pydantic/deprecated/decorator.py", "score": 0.027747180446025258, "span_start": null, "span_end": null, "passage": "import warnings from functools import wraps from typing import TYPE CHECKING, Any, Callable, Dict, List, Mapping, Optional, Tuple, Type, Type Var, Union, overload from typing extensions import depreca..."}, {"qid": "", "rank": 8, "path": "tests/test_migration.py", "score": 0.026289646659736616, "span_start": null, "span_end": null, "passage": "import importlib import pytest from pydantic. migration import DEPRECATED MOVED IN V2, MOVED IN V2, REDIRECT TO V1, REMOVED IN V2, getattr migration from pydantic.errors import Pydantic Import Error d..."}, {"qid": "", "rank": 9, "path": "pydantic/deprecated/json.py", "score": 0.026147273545057304, "span_start": null, "span_end": null, "passage": "import datetime import warnings from collections import deque from decimal import Decimal from enum import Enum from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interfac..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/json.py", "score": 0.025754072235315534, "span_start": null, "span_end": null, "passage": "import datetime from collections import deque from decimal import Decimal from enum import Enum from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network f..."}, {"qid": "", "rank": 11, "path": "tests/mypy/modules/covariant_typevar.py", "score": 0.02355155864967583, "span_start": null, "span_end": null, "passage": "from typing import Generic, Type Var from pydantic import Base Model T = Type Var(\"T\", covariant=True) class Foo(Base Model, Generic[T]): value: T class Bar(Foo[T]): ..."}, {"qid": "", "rank": 12, "path": "tests/mypy/outputs/1.1.1/pyproject-default_toml/fail2.py", "score": 0.022301923435871274, "span_start": null, "span_end": null, "passage": "from datetime import datetime from typing import List, Optional from pydantic import Base Model class Model(Base Model): age: int first name = 'John' last name: Optional[str] = None signup ts: Optiona..."}, {"qid": "", "rank": 13, "path": "tests/mypy/modules/fail2.py", "score": 0.022301923435871274, "span_start": null, "span_end": null, "passage": "from datetime import datetime from typing import List, Optional from pydantic import Base Model class Model(Base Model): age: int first name = 'John' last name: Optional[str] = None signup ts: Optiona..."}, {"qid": "", "rank": 14, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/fail2.py", "score": 0.022301923435871274, "span_start": null, "span_end": null, "passage": "from datetime import datetime from typing import List, Optional from pydantic import Base Model class Model(Base Model): age: int first name = 'John' last name: Optional[str] = None signup ts: Optiona..."}, {"qid": "", "rank": 15, "path": "tests/mypy/outputs/1.0.1/pyproject-default_toml/fail2.py", "score": 0.022301923435871274, "span_start": null, "span_end": null, "passage": "from datetime import datetime from typing import List, Optional from pydantic import Base Model class Model(Base Model): age: int first name = 'John' last name: Optional[str] = None signup ts: Optiona..."}, {"qid": "", "rank": 16, "path": "tests/mypy/outputs/1.0.1/mypy-default_ini/fail2.py", "score": 0.022301923435871274, "span_start": null, "span_end": null, "passage": "from datetime import datetime from typing import List, Optional from pydantic import Base Model class Model(Base Model): age: int first name = 'John' last name: Optional[str] = None signup ts: Optiona..."}, {"qid": "", "rank": 17, "path": "tests/test_validate_call.py", "score": 0.02162921640410095, "span_start": null, "span_end": null, "passage": "import asyncio import inspect import re import sys from datetime import datetime, timezone from functools import partial from typing import Any, List, Tuple import pytest from pydantic core import Arg..."}, {"qid": "", "rank": 18, "path": "tests/mypy/modules/with_config_decorator.py", "score": 0.021246434329980596, "span_start": null, "span_end": null, "passage": "from typing import Typed Dict from pydantic import Config Dict, with config @with config(Config Dict(str to lower=True)) class Model(Typed Dict): a: str model = Model(a='ABC')"}, {"qid": "", "rank": 19, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/fail1.py", "score": 0.02066767912098533, "span_start": null, "span_end": null, "passage": "from datetime import datetime from typing import List, Optional from pydantic import Base Model from pydantic.types import Json class Model(Base Model): age: int first name = 'John' last name: Optiona..."}, {"qid": "", "rank": 20, "path": "tests/mypy/modules/fail1.py", "score": 0.02066767912098533, "span_start": null, "span_end": null, "passage": "from datetime import datetime from typing import List, Optional from pydantic import Base Model from pydantic.types import Json class Model(Base Model): age: int first name = 'John' last name: Optiona..."}], "latency_ms": 8.62264633178711, "gold_paths": ["release/make_history.py"]}
{"qid": "lens_main_regex_1", "query": "def __init__", "results": [{"qid": "", "rank": 1, "path": "pydantic/errors.py", "score": 0.2245005658920159, "span_start": null, "span_end": null, "passage": "...describing the error. code: An optional error code from Pydantic Error Codes enum. class Pydantic Undefined Annotation(Pydantic Error Mixin, Name Error): def   init  (self, name: str, message: str) ->..."}, {"qid": "", "rank": 2, "path": "tests/mypy/outputs/1.0.1/mypy-plugin_ini/custom_constructor.py", "score": 0.17140325834959422, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model class Person(Base Model): id: int name: str birth year: int def   init  (self, id: int) -> None: super().  init  (id=id, name='Patrick', birth year=1991) Person(1) Pers..."}, {"qid": "", "rank": 3, "path": "tests/mypy/modules/custom_constructor.py", "score": 0.17140325834959422, "span_start": null, "span_end": null, "passage": "from pydantic import Base Model class Person(Base Model): id: int name: str birth year: int def   init  (self, id: int) -> None: super().  init  (id=id, name='Patrick', birth year=1991) Person(1) Pers..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/dataclasses.py", "score": 0.16026783765531444, "span_start": null, "span_end": null, "passage": "...v1.errors import Dataclass Type Error from pydantic.v1.fields import Field, Field Info, Required, Undefined from pydantic.v1.main import create model, validate model from pydantic.v1.utils import Clas..."}, {"qid": "", "rank": 5, "path": "tests/test_dataclasses.py", "score": 0.12952434302020305, "span_start": null, "span_end": null, "passage": "...Base Model, Before Validator, Config Dict, Generate Schema, Pydantic Deprecated Since20, Pydantic Undefined Annotation, Pydantic User Error, Root Model, Type Adapter, Validation Error, Validation Info..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/errors.py", "score": 0.09260801459392898, "span_start": null, "span_end": null, "passage": "... 'Invalid Byte Size', 'Invalid Byte Size Unit', 'Missing Discriminator', 'Invalid Discriminator', ) def cls kwargs(cls: Type['Pydantic Error Mixin'], ctx: 'Dict Str Any') -> 'Pydantic Error Mixin': re..."}, {"qid": "", "rank": 7, "path": "pydantic/dataclasses.py", "score": 0.08424040301800523, "span_start": null, "span_end": null, "passage": "...ted on init. kw only: Determines if `  init  ` method parameters must be specified by keyword only. Defaults to `False`. slots: Determines if the generated class should be a 'slots' `dataclass`, which..."}, {"qid": "", "rank": 8, "path": "pydantic/warnings.py", "score": 0.07979964443359752, "span_start": null, "span_end": null, "passage": "... expected removal: Pydantic version in what the corresponding functionality expected to be removed. def   init  (self, message: str, *args: object) -> None: super().  init  (message, *args, since=(2, ..."}, {"qid": "", "rank": 9, "path": "tests/test_model_signature.py", "score": 0.07933402322068432, "span_start": null, "span_end": null, "passage": "...e Model, Config Dict, Field, create model from pydantic. internal. typing extra import is annotated def  equals(a: Union[str, Iterable[str]], b: Union[str, Iterable[str]]) -> bool: if isinstance(a, st..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.07847361994633198, "span_start": null, "span_end": null, "passage": "...we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy plugin type. def   init  (self, options: Options) -> None: self.plugin config = Pydantic Plugin Config(options) s..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_model_construction.py", "score": 0.07177692478527042, "span_start": null, "span_end": null, "passage": "...tem in private attributes: return private attributes[item] raise Attribute Error(item) @classmethod def   prepare  (cls, *args: Any, **kwargs: Any) -> dict[str, object]: return  Model Namespace Dict()..."}, {"qid": "", "rank": 12, "path": "tests/test_main.py", "score": 0.06962298015325585, "span_start": null, "span_end": null, "passage": "import json import platform import re import warnings from collections import defaultdict from copy import deepcopy from dataclasses import dataclass from datetime import date, datetime from enum impo..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.06399097210130253, "span_start": null, "span_end": null, "passage": "... import Error Code from mypy.nodes import ( ARG NAMED, ARG NAMED OPT, ARG OPT, ARG POS, ARG STAR2, MDEF, Argument, Assignment Stmt, Block, Call Expr, Class Def, Context, Decorator, Ellipsis Expr, Func..."}, {"qid": "", "rank": 14, "path": "pydantic/deprecated/config.py", "score": 0.06296406889715725, "span_start": null, "span_end": null, "passage": "...rning = Pydantic Deprecated Since20   all   = 'Base Config', 'Extra' class  Config Metaclass(type): def   getattr  (self, item: str) -> Any: try: obj =  config.config defaults[item] warnings.warn( con..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/env_settings.py", "score": 0.0579028182533289, "span_start": null, "span_end": null, "passage": "...th], Tuple[Str Path, ...]] class Settings Error(Value Error): pass class Base Settings(Base Model): def   init  (   pydantic self  ,  env file: Optional[Dotenv Type] = env file sentinel,  env file enc..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/error_wrappers.py", "score": 0.05155102869388376, "span_start": null, "span_end": null, "passage": "... 'Error Wrapper', 'Validation Error' class Error Wrapper(Representation):   slots   = 'exc', ' loc' def   init  (self, exc: Exception, loc: Union[str, 'Loc']) -> None: self.exc = exc self. loc = loc d..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.05137258366821813, "span_start": null, "span_end": null, "passage": "A base class for creating Pydantic models. Attributes:   class vars  : The names of classvars defined on the model.   private attributes  : Metadata about the private attributes of the model.   signat..."}, {"qid": "", "rank": 18, "path": "tests/test_plugin_loader.py", "score": 0.049967580779333, "span_start": null, "span_end": null, "passage": "...nittest.mock import patch import pytest import pydantic.plugin. loader as loader class Entry Point: def   init  (self, name, value, group): self.name = name self.value = value self.group = group def l..."}, {"qid": "", "rank": 19, "path": "tests/test_deprecated.py", "score": 0.049529967117342415, "span_start": null, "span_end": null, "passage": "...r from pydantic.json schema import Json Schema Value from pydantic.type adapter import Type Adapter def deprecated from orm(model type: Type[Base Model], obj: Any) -> Any: with pytest.warns( Pydantic ..."}, {"qid": "", "rank": 20, "path": "tests/benchmarks/generate_north_star_data.py", "score": 0.04708758767503499, "span_start": null, "span_end": null, "passage": "... Faker f = Faker() Faker.seed(0) T = Type Var('T')  END DATETIME = datetime(2023, 1, 1, 0, 0, 0, 0) def one of(*callables: Callable[[], Any]) -> Any: return f.random.choice(callables)() def list of(ca..."}], "latency_ms": 6.656169891357422, "gold_paths": ["pydantic/aliases.py", "pydantic/color.py", "pydantic/config.py"]}
{"qid": "lens_main_regex_3", "query": "if __name__", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/main.py", "score": 0.12674473146985268, "span_start": null, "span_end": null, "passage": "...rivate name, lenient issubclass, sequence like, smart deepcopy, unique list, validate field name, ) if TYPE CHECKING: from inspect import Signature from pydantic.v1.class validators import Validator L..."}, {"qid": "", "rank": 2, "path": "pydantic/v1/decorator.py", "score": 0.11822729706063231, "span_start": null, "span_end": null, "passage": "... import get all type hints from pydantic.v1.utils import to camel   all   = ('validate arguments',) if TYPE CHECKING: from pydantic.v1.typing import Any Callable Any Callable T = Type Var('Any Callabl..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_signature.py", "score": 0.11764650450803005, "span_start": null, "span_end": null, "passage": "...ore import Pydantic Undefined from . config import Config Wrapper from . utils import is valid identifier if TYPE CHECKING: from ..fields import Field Info def  field name for signature(field name: st..."}, {"qid": "", "rank": 4, "path": "pydantic/main.py", "score": 0.11719887345258378, "span_start": null, "span_end": null, "passage": "...gnature for instantiating the model.   pydantic complete  : Whether model building is completed, or if there are still undefined fields.   pydantic core schema  : The pydantic-core schema used to buil..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/mypy.py", "score": 0.1162894786841101, "span_start": null, "span_end": null, "passage": "...')[0].split('.'))) MYPY VERSION TUPLE = parse mypy version(mypy version) BUILTINS NAME = 'builtins' if MYPY VERSION TUPLE >= (0, 930) else '  builtins  '   version   = 2 def plugin(version: str) -> 'T..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.11500769549333206, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy p..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/utils.py", "score": 0.11357887750801407, "span_start": null, "span_end": null, "passage": "...pe, get args, get origin, is literal type, is union, ) from pydantic.v1.version import version info if TYPE CHECKING: from inspect import Signature from pathlib import Path from pydantic.v1.config imp..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.10488438042552668, "span_start": null, "span_end": null, "passage": "....get type hints`, The only thing that we do here is fetching global namespace from `obj.  module  ` if it is not `None`. Args: obj: The object to get its type hints. localns: The local namespaces. inc..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_repr.py", "score": 0.0896476342127083, "span_start": null, "span_end": null, "passage": "... self.  class  .  name   def   repr str  (self, join str: str) -> str: return join str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.  repr args  ()) def   pretty  (self, fmt: typing.Ca..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_model_construction.py", "score": 0.08698935540347812, "span_start": null, "span_end": null, "passage": "...t namespace  : Reset parent namespace.  create model module: The module of the class to be created, if created by `create model`. **kwargs: Catch-all for any other keyword arguments. Returns: The new ..."}, {"qid": "", "rank": 11, "path": "pydantic/errors.py", "score": 0.08278123405697284, "span_start": null, "span_end": null, "passage": "Attributes: message: A message describing the error. code: An optional error code from Pydantic Error Codes enum. class Pydantic Undefined Annotation(Pydantic Error Mixin, Name Error): def   init  (se"}, {"qid": "", "rank": 12, "path": "pydantic/v1/tools.py", "score": 0.0770169237597095, "span_start": null, "span_end": null, "passage": "...parse raw as', 'schema of', 'schema json of') Name Factory = Union[str, Callable[[Type[Any]], str]] if TYPE CHECKING: from pydantic.v1.typing import Dict Str Any def  generate parsing type name(type :..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_decorators.py", "score": 0.07627568034615925, "span_start": null, "span_end": null, "passage": "...ather than the whole object. always: Whether this method and other validators should be called even if the value is missing. check fields: Whether to check that the fields actually exist on the model...."}, {"qid": "", "rank": 14, "path": "pydantic/v1/schema.py", "score": 0.0748452299975847, "span_start": null, "span_end": null, "passage": "...le, is none type, is union, ) from pydantic.v1.utils import ROOT KEY, get model, lenient issubclass if TYPE CHECKING: from pydantic.v1.dataclasses import Dataclass from pydantic.v1.main import Base Mo..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/generics.py", "score": 0.07282359179461283, "span_start": null, "span_end": null, "passage": "..., get args, get origin, typing base from pydantic.v1.utils import all identical, lenient issubclass if sys.version info >= (3, 10): from typing import  Union Generic Alias if sys.version info >= (3, 8..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_utils.py", "score": 0.07125669078101046, "span_start": null, "span_end": null, "passage": "...g, Type Var from typing extensions import Type Alias, Type Guard from . import  repr,  typing extra if typing.TYPE CHECKING: Mapping Int Str Any: Type Alias = 'typing.Mapping[int, Any] | typing.Mappin..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_typing_extra.py", "score": 0.0699961906979291, "span_start": null, "span_end": null, "passage": "...er a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance because it fails <3.10. if v is None: return False return v.  class   == Final.  class   and (sys.version info < (3, 8) or g..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generics.py", "score": 0.06799684833584682, "span_start": null, "span_end": null, "passage": "... . typing extra import Type Var Type, typing base from . utils import all identical, is model class if sys.version info >= (3, 10): from typing import  Union Generic Alias  # type: ignore[attr-defined..."}, {"qid": "", "rank": 19, "path": "tests/test_exports.py", "score": 0.06690070284103132, "span_start": null, "span_end": null, "passage": "...ports.items())) def test public api dynamic imports(attr name, value): package, module name = value if module name == '  module  ': module = importlib.import module(attr name, package=package) assert ..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/typing.py", "score": 0.0667343116537145, "span_start": null, "span_end": null, "passage": "...es import Union Type as Types Union Type  # type: ignore except Import Error: Types Union Type = () if sys.version info < (3, 9): def evaluate forwardref(type : Forward Ref, globalns: Any, localns: An..."}], "latency_ms": 7.893800735473633, "gold_paths": ["release/make_history.py"]}
{"qid": "lens_main_regex_6", "query": "@property", "results": [{"qid": "", "rank": 1, "path": "tests/test_private_attributes.py", "score": 0.1347066718259899, "span_start": null, "span_end": null, "passage": "...operties not included in iter property() -> None: class Model(Base Model): foo: int @computed field @property def  foo(self) -> int: return -self.foo m = Model(foo=1) assert ' foo' not in list(k for k..."}, {"qid": "", "rank": 2, "path": "tests/test_computed_fields.py", "score": 0.13213592681523453, "span_start": null, "span_end": null, "passage": "... title='Pikarea', description='Another area', examples=[100, 200], json schema extra={'foo': 42}, ) @property def area2(self) -> int: return self.width * self.length @property def double width(self) -..."}, {"qid": "", "rank": 3, "path": "tests/test_abc.py", "score": 0.11131356698123338, "span_start": null, "span_end": null, "passage": "...tract classmethod(cls): pass @staticmethod @abc.abstractmethod def my abstract staticmethod(): pass @property @abc.abstractmethod def my abstract property(self): pass @my abstract property.setter @abc..."}, {"qid": "", "rank": 4, "path": "pydantic/fields.py", "score": 0.09005410978610319, "span_start": null, "span_end": null, "passage": "...ist[Any] | None json schema extra: Json Dict | typing.Callable[[Json Dict], None] | None repr: bool @property def deprecation message(self) -> str | None: wrapped name: str = '' if isinstance(property..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_model_construction.py", "score": 0.08969997062622406, "span_start": null, "span_end": null, "passage": "...e attributes.update(base.  private attributes  ) return field names, class vars, private attributes @property @deprecated('The `  fields  ` attribute is deprecated, use `model fields` instead.', categ..."}, {"qid": "", "rank": 6, "path": "tests/mypy/modules/computed_fields.py", "score": 0.08546960835871073, "span_start": null, "span_end": null, "passage": "...om pydantic import Base Model, computed field class Square(Base Model): side: float @computed field @property def area(self) -> float: return self.side**2 @area.setter def area(self, area: float) -> N..."}, {"qid": "", "rank": 7, "path": "tests/mypy/outputs/1.0.1/pyproject-default_toml/computed_fields.py", "score": 0.08546960835871073, "span_start": null, "span_end": null, "passage": "...om pydantic import Base Model, computed field class Square(Base Model): side: float @computed field @property def area(self) -> float: return self.side**2 @area.setter def area(self, area: float) -> N..."}, {"qid": "", "rank": 8, "path": "tests/pyright/pyright_example.py", "score": 0.07810761283473873, "span_start": null, "span_end": null, "passage": "...r for pyright k = Knight()  # pyright: ignore class Square(Base Model): side: float @computed field @property def area(self) -> float: return self.side**2 @area.setter def area(self, area: float) -> N..."}, {"qid": "", "rank": 9, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.06483805289699662, "span_start": null, "span_end": null, "passage": "from   future   import annotations import dataclasses import enum import gc import itertools import operator import sys import textwrap import timeit from importlib import metadata from typing import "}, {"qid": "", "rank": 10, "path": "tests/test_deprecated_fields.py", "score": 0.040911845117826154, "span_start": null, "span_end": null, "passage": "...sert instance.x == 2 def test computed field deprecated(): class Model(Base Model): @computed field @property @deprecated('This is deprecated') def p1(self) -> int: return 1 @computed field(deprecated..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.024208092366509983, "span_start": null, "span_end": null, "passage": "import copy import dataclasses import sys from contextlib import contextmanager from functools import wraps try: from functools import cached property except Import Error: pass from typing import TYPE"}, {"qid": "", "rank": 12, "path": "pydantic/annotated_handlers.py", "score": 0.021972763396156003, "span_start": null, "span_end": null, "passage": "...ybe ref schema: core schema.Core Schema, /) -> core schema.Core Schema: raise Not Implemented Error @property def field name(self) -> str | None: raise Not Implemented Error"}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_decorators.py", "score": 0.020956572141173326, "span_start": null, "span_end": null, "passage": "while building the pydantic-core schema. Attributes: decorator repr: A class variable representing the decorator string, '@validator'. fields: A tuple of field names the validator should be called on."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generate_schema.py", "score": 0.019107506417484824, "span_start": null, "span_end": null, "passage": "...namespace: Types Namespace): self. types namespace stack: list[Types Namespace] = [types namespace] @property def tail(self) -> Types Namespace: return self. types namespace stack[-1] @contextmanager ..."}, {"qid": "", "rank": 15, "path": "tests/test_deprecated.py", "score": 0.013524086024567646, "span_start": null, "span_end": null, "passage": "...ion Error): deprecated from orm(Model Invalid, foo) def test properties(): class Xy Property: x = 4 @property def y(self): return '5' class Model(Base Model): model config = Config Dict(from attribute..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_core_metadata.py", "score": 0.013318229687761265, "span_start": null, "span_end": null, "passage": "...ance(metadata, dict): raise Type Error(f'Core Schema metadata should be a dict; got {metadata!r}.') @property def metadata(self) -> Core Metadata: metadata = self. schema.get('metadata') if metadata i..."}, {"qid": "", "rank": 17, "path": "pydantic/type_adapter.py", "score": 0.013174056864790673, "span_start": null, "span_end": null, "passage": "and then looks for symbols to resolve forward references in those globals. On the other hand this function can be called with arbitrary objects, including type aliases, where `  module  ` (always `typ"}, {"qid": "", "rank": 18, "path": "tests/test_serialize.py", "score": 0.011972342938166349, "span_start": null, "span_end": null, "passage": "...ect', } def test forward ref for computed fields(): class Model(Base Model): x: int @computed field @property def two x(self) -> 'Int Alias':  # noqa F821 return self.x * 2 Model.model rebuild( types ..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_config.py", "score": 0.010893738969491099, "span_start": null, "span_end": null, "passage": "...onfig wrapper: Config Wrapper): self. config wrapper stack: list[Config Wrapper] = [config wrapper] @property def tail(self) -> Config Wrapper: return self. config wrapper stack[-1] @contextmanager de..."}, {"qid": "", "rank": 20, "path": "pydantic/main.py", "score": 0.010046554586436107, "span_start": null, "span_end": null, "passage": "...ance=self)   init  .  pydantic base init   = True  # pyright: ignore[report Function Member Access] @property def model extra(self) -> dict[str, Any] | None: return self.  pydantic extra   @property d..."}], "latency_ms": 5.016326904296875, "gold_paths": ["pydantic/annotated_handlers.py", "pydantic/fields.py", "pydantic/json_schema.py"]}
{"qid": "lens_main_regex_7", "query": "return None", "results": [{"qid": "", "rank": 1, "path": "pydantic/mypy.py", "score": 0.12658026306030754, "span_start": null, "span_end": null, "passage": "...ed is newer, or especially older, than we expect (or need). Args: version: The mypy version string. Return: The Pydantic mypy plugin type. def   init  (self, options: Options) -> None: self.plugin con..."}, {"qid": "", "rank": 2, "path": "pydantic/fields.py", "score": 0.11450892816016014, "span_start": null, "span_end": null, "passage": "annotation: type[Any] | None default factory: typing.Callable[[], Any] | None alias: str | None alias priority: int | None validation alias: str | Alias Path | Alias Choices | None serialization alias..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_typing_extra.py", "score": 0.10568277065041416, "span_start": null, "span_end": null, "passage": "...y (see https://www.python.org/dev/peps/pep-0586) e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`. It can be either a `typing.Named Tuple` or `collections.namedtuple`. Can't use isinstance be..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/mypy.py", "score": 0.10336815477370925, "span_start": null, "span_end": null, "passage": "...er.trigger import make wildcard trigger from mypy.types import ( Any Type, Callable Type, Instance, None Type, Overloaded, Proper Type, Type, Type Of Any, Type Type, Type Var Id, Type Var Type, Union ..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_model_construction.py", "score": 0.10274723417438633, "span_start": null, "span_end": null, "passage": "...s to be created, if created by `create model`. **kwargs: Catch-all for any other keyword arguments. Returns: The new class created by the metaclass. method. private attributes = self.  dict  .get('  p..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/typing.py", "score": 0.096645333555873, "span_start": null, "span_end": null, "passage": "...ion info < (3, 9): def evaluate forwardref(type : Forward Ref, globalns: Any, localns: Any) -> Any: return type . evaluate(globalns, localns) else: def evaluate forwardref(type : Forward Ref, globalns..."}, {"qid": "", "rank": 7, "path": "pydantic/type_adapter.py", "score": 0.09156107299045263, "span_start": null, "span_end": null, "passage": "...ry least this behavior is  subtly  different from `Base Model`'s. if hasattr(obj, '  dict  '): try: return obj.  dict  [attribute] except Key Error: pass slots = getattr(obj, '  slots  ', None) if slo..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/types.py", "score": 0.09047846392053759, "span_start": null, "span_end": null, "passage": "...ydantic.v1.datetime parse import parse date from pydantic.v1.utils import import string, update not none from pydantic.v1.validators import ( bytes validator, constr length validator, constr lower, co..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generics.py", "score": 0.08371515772780952, "span_start": null, "span_end": null, "passage": "...: self.size limit = size limit super().  init  () def   setitem  (self, key: Any, value: Any, /) -> None: super().  setitem  (key, value) if len(self) > self.size limit: excess = len(self) - self.size..."}, {"qid": "", "rank": 10, "path": "pydantic/main.py", "score": 0.08182753488136976, "span_start": null, "span_end": null, "passage": "... Var[ generics.Pydantic Generic Metadata]   pydantic parent namespace  : Class Var[dict[str, Any] | None]   pydantic post init  : Class Var[None | Literal['model post init']]   pydantic root model  : ..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/fields.py", "score": 0.08094488259655308, "span_start": null, "span_end": null, "passage": "... Wrapper from pydantic.v1.errors import Config Error, Invalid Discriminator, Missing Discriminator, None Is Not Allowed Error from pydantic.v1.types import Json, Json Wrapper from pydantic.v1.typing i..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_repr.py", "score": 0.07980898632965434, "span_start": null, "span_end": null, "passage": "representation of something that is valid (or pseudo-valid) python. Can either return: * name - value pairs, e.g.: `[('foo name', 'foo'), ('bar name', ['b', 'a', 'r'])]` * or, just values, e.g.: `[(No..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.07791769944061636, "span_start": null, "span_end": null, "passage": "...elf, error message: str, *, code: Pydantic Error Codes, attempt rebuild: Callable[[], Core Schema | None] | None = None, ) -> None: self. error message = error message self. code: Pydantic Error Codes..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generate_schema.py", "score": 0.07508299670061644, "span_start": null, "span_end": null, "passage": "Args: info: The field info. field: The field name to check. Returns: `True` if field name is in validator fields, `False` otherwise. It ignores the check for a decorator if the decorator has `*` as fi..."}, {"qid": "", "rank": 15, "path": "tests/test_plugins.py", "score": 0.07480767386181081, "span_start": null, "span_end": null, "passage": "...lugins @contextlib.contextmanager def install plugin(plugin: Pydantic Plugin Protocol) -> Generator[None, None, None]:  plugins[plugin.  class  .  qualname  ] = plugin try: yield finally:  plugins.cle..."}, {"qid": "", "rank": 16, "path": "pydantic/plugin/__init__.py", "score": 0.07327545383684589, "span_start": null, "span_end": null, "passage": "...ndler Protocol', 'Validate Json Handler Protocol', 'Validate Strings Handler Protocol', 'New Schema Returns', 'Schema Type Path', 'Schema Kind', ) New Schema Returns: Type Alias = 'tuple[Validate Pyth..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/datetime_parse.py", "score": 0.07144502360649808, "span_start": null, "span_end": null, "passage": "... bytes, int, float] def get numeric(value: Str Bytes Int Float, native expected type: str) -> Union[None, int, float]: if isinstance(value, (int, float)): return value try: return float(value) except ..."}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.0706425535665701, "span_start": null, "span_end": null, "passage": "...antic.types import Strict Strict Bool = Annotated[bool, Strict()] ``` def conint( *, strict: bool | None = None, gt: int | None = None, ge: int | None = None, lt: int | None = None, le: int | None = N..."}, {"qid": "", "rank": 19, "path": "pydantic/deprecated/copy_internals.py", "score": 0.07041194402672772, "span_start": null, "span_end": null, "passage": "...y Any Class Method = classmethod[Any, Any, Any] Tuple Generator = typing.Generator[Tuple[str, Any], None, None] Model = typing.Type Var('Model', bound='Base Model') Inc Ex: typing extensions.Type Alia..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/main.py", "score": 0.0678913364894835, "span_start": null, "span_end": null, "passage": "...alidate model'  T = Type Var(' T') def validate custom root type(fields: Dict[str, Model Field]) -> None: if len(fields) > 1: raise Value Error(f'{ROOT KEY} cannot be mixed with other fields') def gen..."}], "latency_ms": 5.264759063720703, "gold_paths": ["pydantic/color.py", "pydantic/dataclasses.py", "pydantic/fields.py"]}
{"qid": "lens_main_regex_8", "query": "raise ValueError", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/errors.py", "score": 0.2275427650352494, "span_start": null, "span_end": null, "passage": "from decimal import Decimal from pathlib import Path from typing import TYPE CHECKING, Any, Callable, Sequence, Set, Tuple, Type, Union from pydantic.v1.typing import display as type if TYPE CHECKING:"}, {"qid": "", "rank": 2, "path": "pydantic/v1/datetime_parse.py", "score": 0.16953583836050667, "span_start": null, "span_end": null, "passage": "..., float)): return value try: return float(value) except Value Error: return None except Type Error: raise Type Error(f'invalid type; expected {native expected type}, string, bytes, int or float') def ..."}, {"qid": "", "rank": 3, "path": "tests/test_validators_dataclass.py", "score": 0.1399438215980838, "span_start": null, "span_end": null, "passage": "... str b: str @field validator('a', 'b') @classmethod def check a and b(cls, v, info): if len(v) < 4: raise Value Error(f'{info.field name} is too short') return v + 'x' assert asdict(My Dataclass(a='12..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/error_wrappers.py", "score": 0.12507460482241717, "span_start": null, "span_end": null, "passage": "...g, error loc) elif isinstance(error, list): yield from flatten errors(error, config, loc=loc) else: raise Runtime Error(f'Unknown error object: {error}') def error dict(exc: Exception, config: Type['B..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/validators.py", "score": 0.12447370618698296, "span_start": null, "span_end": null, "passage": "...loat, int, Decimal)): return str(v) elif isinstance(v, (bytes, bytearray)): return v.decode() else: raise errors.Str Error() def strict str validator(v: Any) -> Union[str]: if isinstance(v, str) and n..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.11608350598957086, "span_start": null, "span_end": null, "passage": "...se str(value) elif isinstance(value, Color): self. rgba = value. rgba value = value. original else: raise Pydantic Custom Error( 'color error', 'value is not a valid color: value must be a tuple, list..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/main.py", "score": 0.11356064940290214, "span_start": null, "span_end": null, "passage": "...ar(' T') def validate custom root type(fields: Dict[str, Model Field]) -> None: if len(fields) > 1: raise Value Error(f'{ROOT KEY} cannot be mixed with other fields') def generate hash function(frozen..."}, {"qid": "", "rank": 8, "path": "tests/plugin/example_plugin.py", "score": 0.11102662600143169, "span_start": null, "span_end": null, "passage": "...om pydantic import Base Model class My Model(Base Model): x: int m = My Model(x='10') if m.x != 10: raise Value Error('m.x should be 10') log = [] class Validate Python Handler: def on enter(self, *ar..."}, {"qid": "", "rank": 9, "path": "tests/test_validators.py", "score": 0.10429835053577344, "span_start": null, "span_end": null, "passage": "... fields set as a list of strings, rather than just multiple string args. Expects Config Error to be raised. Attempts to create a validator with fields set as a list of strings, rather than just multip..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.09593532330974068, "span_start": null, "span_end": null, "passage": "...turn IPv4Address(value) except Value Error: pass try: return IPv6Address(value) except Value Error: raise Pydantic Custom Error('ip any address', 'value is not a valid IPv4 or IPv6 address') @classmet..."}, {"qid": "", "rank": 11, "path": "tests/test_generics.py", "score": 0.09336440454890253, "span_start": null, "span_end": null, "passage": "...e = Type Var('data type') class Result(Base Model, Generic[data type]): data: data type with pytest.raises(Type Error) as exc info: Result[int][int] assert str(exc info.value) == \"<class 'tests.test g..."}, {"qid": "", "rank": 12, "path": "pydantic/types.py", "score": 0.0843435090436471, "span_start": null, "span_end": null, "passage": "...date file(path: Path,  : core schema.Validation Info) -> Path: if path.is file(): return path else: raise Pydantic Custom Error('path not file', 'Path does not point to a file') @staticmethod def vali..."}, {"qid": "", "rank": 13, "path": "pydantic/annotated_handlers.py", "score": 0.07856075265703188, "span_start": null, "span_end": null, "passage": "...a modifying function up until it calls into `pydantic.json schema.Generate Json Schema`, which will raise a `pydantic.errors.Pydantic Invalid For Json Schema` error if it cannot generate a JSON schema..."}, {"qid": "", "rank": 14, "path": "pydantic/errors.py", "score": 0.07728925685314558, "span_start": null, "span_end": null, "passage": "Attributes: message: A message describing the error. code: An optional error code from Pydantic Error Codes enum. class Pydantic Undefined Annotation(Pydantic Error Mixin, Name Error): def   init  (se"}, {"qid": "", "rank": 15, "path": "pydantic/v1/types.py", "score": 0.07560573156111684, "span_start": null, "span_end": null, "passage": "...ed Int', type.  new  (cls, name, bases, dct)) if new cls.gt is not None and new cls.ge is not None: raise errors.Config Error('bounds gt and ge cannot be specified at the same time') if new cls.lt is ..."}, {"qid": "", "rank": 16, "path": "tests/test_errors.py", "score": 0.07484306978378141, "span_start": null, "span_end": null, "passage": "... Validation Error from pydantic.version import version short def test user error url(): with pytest.raises(Pydantic User Error) as exc info: Base Model() assert str(exc info.value) == ( 'Pydantic mode..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/color.py", "score": 0.07077491389252923, "span_start": null, "span_end": null, "passage": "...se str(value) elif isinstance(value, Color): self. rgba = value. rgba value = value. original else: raise Color Error(reason='value must be a tuple, list or string') self. original = value @classmetho..."}, {"qid": "", "rank": 18, "path": "tests/test_types.py", "score": 0.06825929919093028, "span_start": null, "span_end": null, "passage": "...(): class Model(Base Model): v: Annotated[str, Strict] assert Model(v='foo').v == 'foo' with pytest.raises(Validation Error, match=r'Input should be a valid string \\[type=string type,'): Model(v=b'fo'..."}, {"qid": "", "rank": 19, "path": "tests/test_exports.py", "score": 0.06718036092837669, "span_start": null, "span_end": null, "passage": "...antic.dataclasses.dataclass class Foo: a: int try: Foo('not an int') except Value Error: pass else: raise Assertion Error('Should have raised a Value Error') def test dataclass import2(subprocess run ..."}, {"qid": "", "rank": 20, "path": "tests/test_datetime.py", "score": 0.06347441902742355, "span_start": null, "span_end": null, "passage": "...')), ], ) def test date parsing(Date Model, value, result): if isinstance(result, Err): with pytest.raises(Validation Error, match=result.message escaped()): Date Model(d=value) else: assert Date Mode..."}], "latency_ms": 5.972385406494141, "gold_paths": ["pydantic/color.py", "pydantic/functional_validators.py", "pydantic/json_schema.py"]}
