{"qid": "lens_main_rag_design_0", "query": "What is the overall architecture of this system?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3333028554916382, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 2, "path": "pydantic/networks.py", "score": 0.3117196559906006, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 3, "path": "pydantic/v1/dataclasses.py", "score": 0.30696001648902893, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/typing.py", "score": 0.2512095272541046, "span_start": null, "span_end": null, "passage": "For unions, basic simplifications used by Union constructor are performed"}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.24568504095077515, "span_start": null, "span_end": null, "passage": "Args:\n            inputs: A sequence of tuples, where:\n\n                - The first element is a JSON schema key type - The second element is the JSON mode: either 'validation' or 'serialization' - Th..."}, {"qid": "", "rank": 6, "path": "pydantic/main.py", "score": 0.24035429954528809, "span_start": null, "span_end": null, "passage": "Attributes:\n        __class_vars__: The names of classvars defined on the model __private_attributes__: Metadata about the private attributes of the model __signature__: The signature for instantiatin..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.23849409818649292, "span_start": null, "span_end": null, "passage": "This is done by:\n    * Validating that the input schema is compatible with the provided discriminator\n    * Introspecting the schema to determine which discriminator values should map to which union c..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generate_schema.py", "score": 0.23736967146396637, "span_start": null, "span_end": null, "passage": "The general structure is a series of if statements starting with the simple cases\n        (non-generic primitive types) and then handling generics and other more complex cases Each case either generat..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_dataclasses.py", "score": 0.23577344417572021, "span_start": null, "span_end": null, "passage": "__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the dataclass __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the dataclas..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_config.py", "score": 0.2341015636920929, "span_start": null, "span_end": null, "passage": "The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        A..."}, {"qid": "", "rank": 11, "path": "pydantic/main.py", "score": 0.23069310188293457, "span_start": null, "span_end": null, "passage": "Args:\n        model_name: The name of the newly created model __config__: The configuration of the new model __doc__: The docstring of the new model __base__: The base class or classes for the new mod..."}, {"qid": "", "rank": 12, "path": "tests/benchmarks/test_north_star.py", "score": 0.23017551004886627, "span_start": null, "span_end": null, "passage": "\"\"\"\nAn integration-style benchmark of a model with a class of what should\n(hopefully) be some of the most common field types used in pydantic validation Used to gauge overall pydantic performance"}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_utils.py", "score": 0.22202767431735992, "span_start": null, "span_end": null, "passage": "Both `base` and `override` are converted to dictionaries if possible Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values Each key-value pair existing in `ba..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_model_construction.py", "score": 0.21987393498420715, "span_start": null, "span_end": null, "passage": "Args:\n        cls: BaseModel or dataclass bases: Parents of the class, generally `cls.__bases__` config_wrapper: The config wrapper instance types_namespace: Optional extra namespace to look for types..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.21796968579292297, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.21687006950378418, "span_start": null, "span_end": null, "passage": "This is used to\n        determine whether this TaggedUnionSchema choice should be \"coalesced\" into the top level,\n        or whether it should be treated as a separate (nested) choice"}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.21367591619491577, "span_start": null, "span_end": null, "passage": "During this recursion, we allow references to be resolved from the definitions\n    # that are originally present on the original, outermost `schema` Before `apply_discriminators` is called,\n    # `sim..."}, {"qid": "", "rank": 18, "path": "pydantic/type_adapter.py", "score": 0.20699557662010193, "span_start": null, "span_end": null, "passage": "(These schemas may have\n                    JsonRef references to definitions that are defined in the second returned element.)\n                - The second element is a JSON schema containing all def..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.20699557662010193, "span_start": null, "span_end": null, "passage": "(These schemas may have\n                JsonRef references to definitions that are defined in the second returned element.)\n            - The second element is a JSON schema containing all definitions..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/utils.py", "score": 0.20077431201934814, "span_start": null, "span_end": null, "passage": "Both ``base`` and ``override`` are converted to dictionaries if possible Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values Each key-value pair existing in..."}], "latency_ms": 3.6830902099609375, "gold_paths": ["docs/index.md", "docs/migration.md"]}
{"qid": "lens_main_rag_design_1", "query": "How are components organized and structured?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3394342064857483, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generate_schema.py", "score": 0.31567928194999695, "span_start": null, "span_end": null, "passage": "The general structure is a series of if statements starting with the simple cases\n        (non-generic primitive types) and then handling generics and other more complex cases Each case either generat..."}, {"qid": "", "rank": 3, "path": "pydantic/type_adapter.py", "score": 0.3111448884010315, "span_start": null, "span_end": null, "passage": "(These schemas may have\n                    JsonRef references to definitions that are defined in the second returned element.)\n                - The second element is a JSON schema containing all def..."}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.3111448884010315, "span_start": null, "span_end": null, "passage": "(These schemas may have\n                JsonRef references to definitions that are defined in the second returned element.)\n            - The second element is a JSON schema containing all definitions..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.2794581651687622, "span_start": null, "span_end": null, "passage": "With all the sub-models defined in the ``definitions`` top-level\n    JSON key :param model: a Pydantic model (a class that inherits from BaseModel)\n    :param by_alias: generate the schemas using the ..."}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.2778152823448181, "span_start": null, "span_end": null, "passage": "(These schemas may have\n                    JsonRef references to definitions that are defined in the second returned element.)\n                - The second element is a dictionary whose keys are defi..."}, {"qid": "", "rank": 7, "path": "pydantic/json_schema.py", "score": 0.2624107301235199, "span_start": null, "span_end": null, "passage": "This class generates JSON schemas based on configured parameters The default schema dialect\n    is [https://json-schema.org/draft/2020-12/schema](https://json-schema.org/draft/2020-12/schema) The clas..."}, {"qid": "", "rank": 8, "path": "pydantic/main.py", "score": 0.2603299915790558, "span_start": null, "span_end": null, "passage": "Attributes:\n        __class_vars__: The names of classvars defined on the model __private_attributes__: Metadata about the private attributes of the model __signature__: The signature for instantiatin..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/schema.py", "score": 0.25977373123168945, "span_start": null, "span_end": null, "passage": "Update it if you want the schemas to reference the definitions somewhere\n      else, e.g for OpenAPI use ``#/components/schemas/`` The resulting generated schemas will still be at the\n      top-level ..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/dataclasses.py", "score": 0.2561991810798645, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/schema.py", "score": 0.255013108253479, "span_start": null, "span_end": null, "passage": ":param models: a list of models to include in the generated JSON Schema\n    :param by_alias: generate the schemas using the aliases defined, if any\n    :param title: title for the generated schema tha..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.2534790635108948, "span_start": null, "span_end": null, "passage": "Attributes:\n        decorator_repr: A class variable representing the decorator string, '@validator' fields: A tuple of field names the validator should be called on mode: The proposed validator mode ..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_dataclasses.py", "score": 0.25282901525497437, "span_start": null, "span_end": null, "passage": "Attributes:\n            __pydantic_config__: Pydantic-specific configuration settings for the dataclass __pydantic_complete__: Whether dataclass building is completed, or if there are still undefined ..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.2521119713783264, "span_start": null, "span_end": null, "passage": "Args:\n            inputs: A sequence of tuples, where:\n\n                - The first element is a JSON schema key type - The second element is the JSON mode: either 'validation' or 'serialization' - Th..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_core_metadata.py", "score": 0.24817650020122528, "span_start": null, "span_end": null, "passage": "Attributes:\n        pydantic_js_functions: List of JSON schema functions pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n            prefer positional over keyword argument..."}, {"qid": "", "rank": 16, "path": "pydantic/main.py", "score": 0.2471453845500946, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n\n        __class_vars..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.23575398325920105, "span_start": null, "span_end": null, "passage": "self._prioritized_defsref_choices: dict[DefsRef, list[DefsRef]] = {}\n        self._collision_counter: dict[str, int] = defaultdict(int)\n        self._collision_index: dict[str, int] = {}\n\n        self..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/schema.py", "score": 0.23500555753707886, "span_start": null, "span_end": null, "passage": ":param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.23270300030708313, "span_start": null, "span_end": null, "passage": "# At the end of schema generation, we use these to produce a JSON schema with more human-readable\n        # definitions, which would also work better in a generated OpenAPI client, etc"}, {"qid": "", "rank": 20, "path": "pydantic/deprecated/class_validators.py", "score": 0.23266994953155518, "span_start": null, "span_end": null, "passage": "each_item (bool, optional): For complex objects (sets, lists etc.) whether to validate\n            individual elements rather than the whole object Defaults to False always (bool, optional): Whether t..."}], "latency_ms": 3.4406185150146484, "gold_paths": ["HISTORY.md", "docs/contributing.md"]}
{"qid": "lens_main_rag_design_2", "query": "What design patterns are implemented?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.34324899315834045, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3218367397785187, "span_start": null, "span_end": null, "passage": "The general structure is a series of if statements starting with the simple cases\n        (non-generic primitive types) and then handling generics and other more complex cases Each case either generat..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_decorators.py", "score": 0.31631040573120117, "span_start": null, "span_end": null, "passage": "Attributes:\n        cls_ref: The class ref cls_var_name: The decorated function name func: The decorated function shim: A wrapper function to wrap V1 style function info: The decorator info"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_config.py", "score": 0.3140259385108948, "span_start": null, "span_end": null, "passage": "The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        A..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.31059813499450684, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.3038864731788635, "span_start": null, "span_end": null, "passage": "Args:\n        cls: The model class to generate a JSON Schema for by_alias: If `True` (the default), fields will be serialized according to their alias If `False`, fields will be serialized according t..."}, {"qid": "", "rank": 7, "path": "pydantic/functional_serializers.py", "score": 0.29857730865478516, "span_start": null, "span_end": null, "passage": "Args:\n        f: The function to be decorated mode: The serialization mode - `'plain'` means the function will be called instead of the default serialization logic\n            - `'wrap'` means the fun..."}, {"qid": "", "rank": 8, "path": "pydantic/deprecated/class_validators.py", "score": 0.2984520196914673, "span_start": null, "span_end": null, "passage": "allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n            the decorated function Defaults to False Returns:\n        Callable: A decorator that can be..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/dataclasses.py", "score": 0.2973420321941376, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.29310911893844604, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.29294875264167786, "span_start": null, "span_end": null, "passage": "\"\"\"Types and utility functions used by various other internal tools.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import core_schema\nfrom..."}, {"qid": "", "rank": 12, "path": "pydantic/validate_call_decorator.py", "score": 0.2876722812652588, "span_start": null, "span_end": null, "passage": "Usage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)` Args:\n        func: The function to be decorated config: The configuration dictionary validate_return:..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_decorators.py", "score": 0.281245619058609, "span_start": null, "span_end": null, "passage": "info: The decorator info Returns:\n            The new decorator instance"}, {"qid": "", "rank": 14, "path": "pydantic/functional_serializers.py", "score": 0.27305135130882263, "span_start": null, "span_end": null, "passage": "An example would be to serialize temperature to the same temperature scale, such as degrees Celsius"}, {"qid": "", "rank": 15, "path": "pydantic/functional_serializers.py", "score": 0.2693888247013092, "span_start": null, "span_end": null, "passage": "\"\"\"This module contains related classes and functions for serialization.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom functools import partialmethod\nfrom typing import TYPE_CHECKING..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.2685154676437378, "span_start": null, "span_end": null, "passage": "Args:\n            inputs: A sequence of tuples, where:\n\n                - The first element is a JSON schema key type - The second element is the JSON mode: either 'validation' or 'serialization' - Th..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.26661810278892517, "span_start": null, "span_end": null, "passage": "# At the end of schema generation, we use these to produce a JSON schema with more human-readable\n        # definitions, which would also work better in a generated OpenAPI client, etc"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_decorators.py", "score": 0.26475298404693604, "span_start": null, "span_end": null, "passage": "This handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod Args:\n        func: The function to unwrap unwrap_partial: If True (default), unwrap partial and partia..."}, {"qid": "", "rank": 19, "path": "pydantic/deprecated/class_validators.py", "score": 0.2636178731918335, "span_start": null, "span_end": null, "passage": "Args:\n        pre (bool, optional): Whether this validator should be called before the standard\n            validators (else after) Defaults to False skip_on_failure (bool, optional): Whether to stop ..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/schema.py", "score": 0.2623884677886963, "span_start": null, "span_end": null, "passage": ":param models: a list of models to include in the generated JSON Schema\n    :param by_alias: generate the schemas using the aliases defined, if any\n    :param title: title for the generated schema tha..."}], "latency_ms": 4.154205322265625, "gold_paths": ["HISTORY.md", "docs/migration.md"]}
{"qid": "lens_main_rag_design_3", "query": "How does data flow through the system?", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/dataclasses.py", "score": 0.33279305696487427, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 2, "path": "pydantic/types.py", "score": 0.28697770833969116, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        return self.encoder.decode(data)\n\n    def encode(self, value: bytes) -> bytes:\n        \"\"\"Encode the data u..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.2703372538089752, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.2600563168525696, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 5, "path": "pydantic/types.py", "score": 0.23114830255508423, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        return data.decode()\n\n    def encode_str(self, value: str) -> str:\n        \"\"\"Encode the data using the spe..."}, {"qid": "", "rank": 6, "path": "pydantic/networks.py", "score": 0.221612811088562, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 7, "path": "pydantic/json_schema.py", "score": 0.215501070022583, "span_start": null, "span_end": null, "passage": "Args:\n            inputs: A sequence of tuples, where:\n\n                - The first element is a JSON schema key type - The second element is the JSON mode: either 'validation' or 'serialization' - Th..."}, {"qid": "", "rank": 8, "path": "pydantic/functional_serializers.py", "score": 0.21215422451496124, "span_start": null, "span_end": null, "passage": "An example would be to serialize temperature to the same temperature scale, such as degrees Celsius"}, {"qid": "", "rank": 9, "path": "pydantic/types.py", "score": 0.21100255846977234, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        .. @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        \"\"\"Encode the data using the encoder Ar..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_dataclasses.py", "score": 0.2104780077934265, "span_start": null, "span_end": null, "passage": "__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the dataclass __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the dataclas..."}, {"qid": "", "rank": 11, "path": "pydantic/types.py", "score": 0.20517878234386444, "span_start": null, "span_end": null, "passage": "You can use the `ByteSize` data type to (case-insensitively) convert a string representation of a number of bytes into\n    an integer, and also to print out human-readable strings representing a numbe..."}, {"qid": "", "rank": 12, "path": "tests/test_types.py", "score": 0.18582972884178162, "span_start": null, "span_end": null, "passage": "import collections\nimport itertools\nimport json\nimport math\nimport os\nimport re\nimport sys\nimport typing\nimport uuid\nfrom collections import OrderedDict, defaultdict, deque\nfrom dataclasses import dat..."}, {"qid": "", "rank": 13, "path": "tests/test_json.py", "score": 0.1855243742465973, "span_start": null, "span_end": null, "passage": "import json\nimport math\nimport re\nimport sys\nfrom dataclasses import dataclass as vanilla_dataclass\nfrom datetime import date, datetime, time, timedelta, timezone\nfrom decimal import Decimal\nfrom enum..."}, {"qid": "", "rank": 14, "path": "tests/test_serialize.py", "score": 0.18206679821014404, "span_start": null, "span_end": null, "passage": "\"\"\"\nNew tests for v2 of serialization logic"}, {"qid": "", "rank": 15, "path": "pydantic/v1/typing.py", "score": 0.1816239356994629, "span_start": null, "span_end": null, "passage": "For unions, basic simplifications used by Union constructor are performed"}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.1782473623752594, "span_start": null, "span_end": null, "passage": "In general, including a middle `'i'` will cause the unit to be interpreted as a power of 2,\n    rather than a power of 10 (so, for example, `'1 MB'` is treated as `1_000_000` bytes, whereas `'1 MiB'` ..."}, {"qid": "", "rank": 17, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.17669349908828735, "span_start": null, "span_end": null, "passage": "c: int = Field(...)\n    d: Union[int, str]\n    e = .."}, {"qid": "", "rank": 18, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.17669349908828735, "span_start": null, "span_end": null, "passage": "c: int = Field(...)\n    d: Union[int, str]\n    e = .."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.16875144839286804, "span_start": null, "span_end": null, "passage": "This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached"}, {"qid": "", "rank": 20, "path": "pydantic/types.py", "score": 0.16605743765830994, "span_start": null, "span_end": null, "passage": "There is\n        some nuance to this behavior, demonstrated in the examples below"}], "latency_ms": 3.8454532623291016, "gold_paths": ["HISTORY.md", "README.md"]}
{"qid": "lens_main_rag_design_4", "query": "What are the key design decisions and trade-offs?", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/dataclasses.py", "score": 0.31390538811683655, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3110761046409607, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 3, "path": "tests/test_fields.py", "score": 0.2972111999988556, "span_start": null, "span_end": null, "passage": "Basically, I think retaining the flexibility\n    # is worth the increased potential for weird/confusing \"accidental\" overrides"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generate_schema.py", "score": 0.28601396083831787, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 5, "path": "pydantic/fields.py", "score": 0.2524506151676178, "span_start": null, "span_end": null, "passage": "This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached"}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.24741318821907043, "span_start": null, "span_end": null, "passage": "This is used to\n        determine whether this TaggedUnionSchema choice should be \"coalesced\" into the top level,\n        or whether it should be treated as a separate (nested) choice"}, {"qid": "", "rank": 7, "path": "tests/benchmarks/test_north_star.py", "score": 0.24740152060985565, "span_start": null, "span_end": null, "passage": "\"\"\"\nAn integration-style benchmark of a model with a class of what should\n(hopefully) be some of the most common field types used in pydantic validation Used to gauge overall pydantic performance"}, {"qid": "", "rank": 8, "path": "pydantic/deprecated/class_validators.py", "score": 0.24181482195854187, "span_start": null, "span_end": null, "passage": "each_item (bool, optional): For complex objects (sets, lists etc.) whether to validate\n            individual elements rather than the whole object Defaults to False always (bool, optional): Whether t..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_core_metadata.py", "score": 0.2297654002904892, "span_start": null, "span_end": null, "passage": "Attributes:\n        pydantic_js_functions: List of JSON schema functions pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n            prefer positional over keyword argument..."}, {"qid": "", "rank": 10, "path": "pydantic/config.py", "score": 0.22864589095115662, "span_start": null, "span_end": null, "passage": "Meaning when `defer_build` is `True` and `experimental_defer_build_mode` is the default `('model',)`\n    then `TypeAdapter` immediately constructs its validator and serializer instead of postponing sa..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.22754640877246857, "span_start": null, "span_end": null, "passage": "See also:\n\nhttps://hypothesis.readthedocs.io/en/latest/strategies.html#registering-strategies-via-setuptools-entry-points\nhttps://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.re..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_generate_schema.py", "score": 0.2239050716161728, "span_start": null, "span_end": null, "passage": "The general structure is a series of if statements starting with the simple cases\n        (non-generic primitive types) and then handling generics and other more complex cases Each case either generat..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.22282952070236206, "span_start": null, "span_end": null, "passage": "This allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,\n    but without needing to have a single shared field across all the union choices This also makes i..."}, {"qid": "", "rank": 14, "path": "pydantic/fields.py", "score": 0.22169463336467743, "span_start": null, "span_end": null, "passage": "repr: Whether to include the field in representation of the model init: Whether the field should be included in the constructor of the dataclass init_var: Whether the field should _only_ be included i..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generics.py", "score": 0.21952910721302032, "span_start": null, "span_end": null, "passage": "As a concrete example, this approach was necessary to make Model[List[T]][int] equal to Model[List[int]] The approach could be modified to not use two different cache keys at different points, but the..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_config.py", "score": 0.21913400292396545, "span_start": null, "span_end": null, "passage": "The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        A..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.21246549487113953, "span_start": null, "span_end": null, "passage": "Args:\n            inputs: A sequence of tuples, where:\n\n                - The first element is a JSON schema key type - The second element is the JSON mode: either 'validation' or 'serialization' - Th..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.21043387055397034, "span_start": null, "span_end": null, "passage": "self._prioritized_defsref_choices: dict[DefsRef, list[DefsRef]] = {}\n        self._collision_counter: dict[str, int] = defaultdict(int)\n        self._collision_index: dict[str, int] = {}\n\n        self..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_generics.py", "score": 0.20808866620063782, "span_start": null, "span_end": null, "passage": "If we wanted to move to only using a single cache key per type, we would either need to always use the\n    slower/more computationally intensive logic associated with _late_cache_key, or would need to..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_utils.py", "score": 0.20696046948432922, "span_start": null, "span_end": null, "passage": "Both `base` and `override` are converted to dictionaries if possible Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values Each key-value pair existing in `ba..."}], "latency_ms": 3.5881996154785156, "gold_paths": ["HISTORY.md", "docs/migration.md"]}
{"qid": "lens_main_rag_design_5", "query": "How is the system designed to scale?", "results": [{"qid": "", "rank": 1, "path": "pydantic/functional_serializers.py", "score": 0.4017676115036011, "span_start": null, "span_end": null, "passage": "An example would be to serialize temperature to the same temperature scale, such as degrees Celsius"}, {"qid": "", "rank": 2, "path": "pydantic/types.py", "score": 0.23856060206890106, "span_start": null, "span_end": null, "passage": "Args:\n            decimal: If True, use decimal units (e.g 1000 bytes per KB) If False, use binary units\n                (e.g 1024 bytes per KiB) separator: A string used to split the value and unit D..."}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.19600798189640045, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if decimal:\n            divisor = 1000\n            units = 'B', 'KB', 'MB', 'GB', 'TB', 'PB'\n            final_unit = 'EB'\n        else:\n            divisor = 1024\n            units = 'B',..."}, {"qid": "", "rank": 4, "path": "pydantic/types.py", "score": 0.18841704726219177, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, ByteSize\n\n    class MyModel(BaseModel):\n        size: ByteSize\n\n    print(MyModel(size=52000).size)\n    #> 52000\n    print(MyModel(size='3000 KiB').size)\n    ..."}, {"qid": "", "rank": 5, "path": "pydantic/types.py", "score": 0.1820708066225052, "span_start": null, "span_end": null, "passage": "Args:\n            unit: The unit to convert to Must be one of the following: B, KB, MB, GB, TB, PB, EB,\n                KiB, MiB, GiB, TiB, PiB, EiB (byte units) and\n                bit, kbit, mbit, g..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/dataclasses.py", "score": 0.17937429249286652, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.1508805751800537, "span_start": null, "span_end": null, "passage": "This is used to\n        determine whether this TaggedUnionSchema choice should be \"coalesced\" into the top level,\n        or whether it should be treated as a separate (nested) choice"}, {"qid": "", "rank": 8, "path": "pydantic/networks.py", "score": 0.14989164471626282, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.14741572737693787, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.1436879187822342, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # We need to iteratively simplify the definitions until we reach a fixed point # The reason for this is that outer definitions may reference inner definitions that get simplified\n        #..."}, {"qid": "", "rank": 11, "path": "tests/test_internal.py", "score": 0.14140494167804718, "span_start": null, "span_end": null, "passage": "\"\"\"\nTests for internal things that are complex enough to warrant their own unit tests"}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_utils.py", "score": 0.1362505406141281, "span_start": null, "span_end": null, "passage": "\"\"\"Bucket of reusable internal utilities This should be reduced as much as possible with functions only used in one place, moved to that place"}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.13324618339538574, "span_start": null, "span_end": null, "passage": "You can use the `ByteSize` data type to (case-insensitively) convert a string representation of a number of bytes into\n    an integer, and also to print out human-readable strings representing a numbe..."}, {"qid": "", "rank": 14, "path": "tests/benchmarks/test_north_star.py", "score": 0.13286064565181732, "span_start": null, "span_end": null, "passage": "\"\"\"\nAn integration-style benchmark of a model with a class of what should\n(hopefully) be some of the most common field types used in pydantic validation Used to gauge overall pydantic performance"}, {"qid": "", "rank": 15, "path": "pydantic/deprecated/json.py", "score": 0.1267058253288269, "span_start": null, "span_end": null, "passage": "This is useful when we use ConstrainedDecimal to represent Numeric(x,0)\n    where a integer (but not int typed) is used Encoding this as a float\n    results in failed round-tripping between encode and..."}, {"qid": "", "rank": 16, "path": "pydantic/color.py", "score": 0.12589822709560394, "span_start": null, "span_end": null, "passage": "Args:\n        c: The float value to be converted Must be between 0 and 1 (inclusive) Returns:\n        The integer equivalent of the given float value rounded to the nearest whole number Raises:\n      ..."}, {"qid": "", "rank": 17, "path": "pydantic/fields.py", "score": 0.11879988759756088, "span_start": null, "span_end": null, "passage": "This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_decorators.py", "score": 0.11650143563747406, "span_start": null, "span_end": null, "passage": "If we do replace any functions we put the replacement into the position\n        the replaced function was in; that is, we maintain the order"}, {"qid": "", "rank": 19, "path": "pydantic/types.py", "score": 0.11560079455375671, "span_start": null, "span_end": null, "passage": "In general, including a middle `'i'` will cause the unit to be interpreted as a power of 2,\n    rather than a power of 10 (so, for example, `'1 MB'` is treated as `1_000_000` bytes, whereas `'1 MiB'` ..."}, {"qid": "", "rank": 20, "path": "pydantic/types.py", "score": 0.11441921442747116, "span_start": null, "span_end": null, "passage": "There is\n        some nuance to this behavior, demonstrated in the examples below"}], "latency_ms": 4.105567932128906, "gold_paths": ["HISTORY.md", "README.md"]}
{"qid": "lens_main_rag_design_6", "query": "What security design principles are followed?", "results": [{"qid": "", "rank": 1, "path": "pydantic/networks.py", "score": 0.340688019990921, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 2, "path": "pydantic/v1/main.py", "score": 0.33807340264320374, "span_start": null, "span_end": null, "passage": "# The extra \"is not None\" guards are not logically necessary but optimizes performance for the simple case"}, {"qid": "", "rank": 3, "path": "pydantic/deprecated/copy_internals.py", "score": 0.33807340264320374, "span_start": null, "span_end": null, "passage": "# The extra \"is not None\" guards are not logically necessary but optimizes performance for the simple case"}, {"qid": "", "rank": 4, "path": "pydantic/deprecated/class_validators.py", "score": 0.22369080781936646, "span_start": null, "span_end": null, "passage": "each_item (bool, optional): For complex objects (sets, lists etc.) whether to validate\n            individual elements rather than the whole object Defaults to False always (bool, optional): Whether t..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generate_schema.py", "score": 0.22239913046360016, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 6, "path": "pydantic/networks.py", "score": 0.21808654069900513, "span_start": null, "span_end": null, "passage": "Attributes:\n        max_length: The maximum length of the url Defaults to `None` allowed_schemes: The allowed schemes Defaults to `None` host_required: Whether the host is required Defaults to `None` ..."}, {"qid": "", "rank": 7, "path": "tests/test_fields.py", "score": 0.21418845653533936, "span_start": null, "span_end": null, "passage": "Basically, I think retaining the flexibility\n    # is worth the increased potential for weird/confusing \"accidental\" overrides"}, {"qid": "", "rank": 8, "path": "pydantic/fields.py", "score": 0.21075618267059326, "span_start": null, "span_end": null, "passage": "Only applicable to numbers le: Less than or equal If set, value must be less than or equal to this Only applicable to numbers multiple_of: Value must be a multiple of this Only applicable to numbers m..."}, {"qid": "", "rank": 9, "path": "pydantic/types.py", "score": 0.2017604559659958, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 10, "path": "tests/test_discriminated_union.py", "score": 0.1916661560535431, "span_start": null, "span_end": null, "passage": "I think this would be difficult to avoid in the general case, and I would suggest that we not\n            # attempt to do more than this until presented with scenarios where it is helpful/necessary"}, {"qid": "", "rank": 11, "path": "tests/test_discriminated_union.py", "score": 0.1916661560535431, "span_start": null, "span_end": null, "passage": "I think this would be difficult to avoid in the general case, and I would suggest that we not\n            # attempt to do more than this until presented with scenarios where it is helpful/necessary"}, {"qid": "", "rank": 12, "path": "pydantic/networks.py", "score": 0.1902424395084381, "span_start": null, "span_end": null, "passage": "# Define your own class if you want to specify network address check strictness"}, {"qid": "", "rank": 13, "path": "pydantic/v1/env_settings.py", "score": 0.1860477328300476, "span_start": null, "span_end": null, "passage": "This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),\n    Heroku and any 12 factor app design"}, {"qid": "", "rank": 14, "path": "pydantic/v1/dataclasses.py", "score": 0.1852971762418747, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/schema.py", "score": 0.18391409516334534, "span_start": null, "span_end": null, "passage": "Otherwise we will end up with several allOf inside anyOf/oneOf"}, {"qid": "", "rank": 16, "path": "pydantic/v1/color.py", "score": 0.1817663013935089, "span_start": null, "span_end": null, "passage": "hue, saturation, lightness and optionally alpha; all elements are in\n        the range 0 to 1 NOTE: this is HSL as used in HTML and most other places, not HLS as used in python's colorsys :param alpha..."}, {"qid": "", "rank": 17, "path": "pydantic/plugin/__init__.py", "score": 0.179780513048172, "span_start": null, "span_end": null, "passage": "strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators \"\"\"\n        pass"}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.1772964894771576, "span_start": null, "span_end": null, "passage": "This should be performed in a later phase"}, {"qid": "", "rank": 19, "path": "pydantic/types.py", "score": 0.17645835876464844, "span_start": null, "span_end": null, "passage": "max_length: The maximum length of the bytes strict: Whether to validate the bytes in strict mode Returns:\n        The wrapped bytes type"}, {"qid": "", "rank": 20, "path": "pydantic/v1/fields.py", "score": 0.1758529096841812, "span_start": null, "span_end": null, "passage": "This method should be idempotent, e.g it should be safe to call multiple times\n        without mis-configuring the field"}], "latency_ms": 3.5076141357421875, "gold_paths": ["HISTORY.md", "README.md"]}
{"qid": "lens_main_rag_design_7", "query": "How is the codebase organized by domain?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_model_construction.py", "score": 0.2720341086387634, "span_start": null, "span_end": null, "passage": "Args:\n        cls: BaseModel or dataclass bases: Parents of the class, generally `cls.__bases__` config_wrapper: The config wrapper instance types_namespace: Optional extra namespace to look for types..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.2564507722854614, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 3, "path": "pydantic/networks.py", "score": 0.2534636855125427, "span_start": null, "span_end": null, "passage": "* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host required\n\nAssuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export t..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_utils.py", "score": 0.23755332827568054, "span_start": null, "span_end": null, "passage": "Both `base` and `override` are converted to dictionaries if possible Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values Each key-value pair existing in `ba..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_config.py", "score": 0.23600569367408752, "span_start": null, "span_end": null, "passage": "The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        A..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_generate_schema.py", "score": 0.2239537239074707, "span_start": null, "span_end": null, "passage": "The general structure is a series of if statements starting with the simple cases\n        (non-generic primitive types) and then handling generics and other more complex cases Each case either generat..."}, {"qid": "", "rank": 7, "path": "pydantic/json_schema.py", "score": 0.2160342037677765, "span_start": null, "span_end": null, "passage": "This is used to encode default values for fields in the generated JSON schema Args:\n            dft: The default value to encode Returns:\n            The encoded default value"}, {"qid": "", "rank": 8, "path": "pydantic/v1/utils.py", "score": 0.2158290147781372, "span_start": null, "span_end": null, "passage": "Both ``base`` and ``override`` are converted to dictionaries if possible Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values Each key-value pair existing in..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.21518391370773315, "span_start": null, "span_end": null, "passage": "During this recursion, we allow references to be resolved from the definitions\n    # that are originally present on the original, outermost `schema` Before `apply_discriminators` is called,\n    # `sim..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.21462860703468323, "span_start": null, "span_end": null, "passage": "Attributes:\n        max_length: The maximum length of the url Defaults to `None` allowed_schemes: The allowed schemes Defaults to `None` host_required: Whether the host is required Defaults to `None` ..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_model_construction.py", "score": 0.21332424879074097, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/networks.py", "score": 0.20741184055805206, "span_start": null, "span_end": null, "passage": "Additionally to `url_regex` it allows to match multiple hosts E.g"}, {"qid": "", "rank": 13, "path": "tests/test_aliases.py", "score": 0.20487737655639648, "span_start": null, "span_end": null, "passage": "The specific alias, if specified, or\n        # 2 The alias, if specified, or\n        # 3 The generated alias (i.e"}, {"qid": "", "rank": 14, "path": "pydantic/v1/main.py", "score": 0.19993767142295837, "span_start": null, "span_end": null, "passage": "# This allows users to write custom JSON encoders for given `BaseModel` classes"}, {"qid": "", "rank": 15, "path": "pydantic/v1/schema.py", "score": 0.19410644471645355, "span_start": null, "span_end": null, "passage": ":param models: a list of models to include in the generated JSON Schema\n    :param by_alias: generate the schemas using the aliases defined, if any\n    :param title: title for the generated schema tha..."}, {"qid": "", "rank": 16, "path": "pydantic/fields.py", "score": 0.1865718960762024, "span_start": null, "span_end": null, "passage": "This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached"}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_generate_schema.py", "score": 0.18416376411914825, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance computed_field_info: The ComputedFieldInfo instance to which the alias_generator i..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.18287354707717896, "span_start": null, "span_end": null, "passage": "It uses the `typing.get_type_hints`, The only thing that we do here is fetching\n    global namespace from `obj.__module__` if it is not `None` Args:\n        obj: The object to get its type hints local..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.18206584453582764, "span_start": null, "span_end": null, "passage": "This class generates JSON schemas based on configured parameters The default schema dialect\n    is [https://json-schema.org/draft/2020-12/schema](https://json-schema.org/draft/2020-12/schema) The clas..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/networks.py", "score": 0.1811840534210205, "span_start": null, "span_end": null, "passage": "host1.db.net,host2.db.net\n    \"\"\"\n    global _multi_host_url_regex_cache\n    if _multi_host_url_regex_cache is None:\n        _multi_host_url_regex_cache = re.compile(\n            rf'{_scheme_regex}{_u..."}], "latency_ms": 4.268646240234375, "gold_paths": ["docs/index.md", "docs/why.md"]}
{"qid": "lens_main_rag_design_8", "query": "What external dependencies and services are used?", "results": [{"qid": "", "rank": 1, "path": "pydantic/type_adapter.py", "score": 0.3230142593383789, "span_start": null, "span_end": null, "passage": "module: The module that passes to plugin if provided !! note\n            You cannot use the `config` argument when instantiating a `TypeAdapter` if the type you're using has its own\n            config..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_utils.py", "score": 0.28871411085128784, "span_start": null, "span_end": null, "passage": "\"\"\"Bucket of reusable internal utilities This should be reduced as much as possible with functions only used in one place, moved to that place"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.28033846616744995, "span_start": null, "span_end": null, "passage": "Args:\n        cls: BaseModel or dataclass bases: Parents of the class, generally `cls.__bases__` config_wrapper: The config wrapper instance types_namespace: Optional extra namespace to look for types..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/mypy.py", "score": 0.2744868993759155, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 5, "path": "pydantic/mypy.py", "score": 0.2744868993759155, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_config.py", "score": 0.25282102823257446, "span_start": null, "span_end": null, "passage": "The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        A..."}, {"qid": "", "rank": 7, "path": "pydantic/fields.py", "score": 0.251822829246521, "span_start": null, "span_end": null, "passage": "repr: Whether to include the field in representation of the model init: Whether the field should be included in the constructor of the dataclass init_var: Whether the field should _only_ be included i..."}, {"qid": "", "rank": 8, "path": "pydantic/networks.py", "score": 0.2516704201698303, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 9, "path": "pydantic/functional_serializers.py", "score": 0.2505618929862976, "span_start": null, "span_end": null, "passage": "\"\"\"This module contains related classes and functions for serialization.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom functools import partialmethod\nfrom typing import TYPE_CHECKING..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/dataclasses.py", "score": 0.24736522138118744, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 11, "path": "pydantic/fields.py", "score": 0.2449113428592682, "span_start": null, "span_end": null, "passage": "repr: A boolean indicating whether to include the field in the `__repr__` output init: Whether the field should be included in the constructor of the dataclass (Only applies to dataclasses.)\n        i..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/schema.py", "score": 0.242397278547287, "span_start": null, "span_end": null, "passage": ":param models: a list of models to include in the generated JSON Schema\n    :param by_alias: generate the schemas using the aliases defined, if any\n    :param title: title for the generated schema tha..."}, {"qid": "", "rank": 13, "path": "pydantic/plugin/__init__.py", "score": 0.23357215523719788, "span_start": null, "span_end": null, "passage": "\"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/plugins#build-a-plugin\n\nPlugin interface for Pydantic plugins, and related types"}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.23346416652202606, "span_start": null, "span_end": null, "passage": "\"\"\"Types and utility functions used by various other internal tools.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import core_schema\nfrom..."}, {"qid": "", "rank": 15, "path": "pydantic/type_adapter.py", "score": 0.2227284163236618, "span_start": null, "span_end": null, "passage": "A `TypeAdapter` instance exposes some of the functionality from `BaseModel` instance methods\n    for types that do not have such methods (such as dataclasses, primitive types, and more) **Note:** `Typ..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.2226916402578354, "span_start": null, "span_end": null, "passage": ":param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n..."}, {"qid": "", "rank": 17, "path": "tests/test_internal.py", "score": 0.22085599601268768, "span_start": null, "span_end": null, "passage": "\"\"\"\nTests for internal things that are complex enough to warrant their own unit tests"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2207498997449875, "span_start": null, "span_end": null, "passage": "It uses the `typing.get_type_hints`, The only thing that we do here is fetching\n    global namespace from `obj.__module__` if it is not `None` Args:\n        obj: The object to get its type hints local..."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.21817141771316528, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    annotation: type[Any] | None\n    default: Any\n    default_factory: typing.Callable[[], Any] | None\n    alias: str | None\n    alias_priority: int | None\n    validation_alias: str | AliasPath |..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_dataclasses.py", "score": 0.21682734787464142, "span_start": null, "span_end": null, "passage": "__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the dataclass __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the dataclas..."}], "latency_ms": 4.048347473144531, "gold_paths": ["HISTORY.md", "README.md"]}
{"qid": "lens_main_rag_design_9", "query": "How is backwards compatibility maintained?", "results": [{"qid": "", "rank": 1, "path": "pydantic/warnings.py", "score": 0.39451301097869873, "span_start": null, "span_end": null, "passage": "It provides information on when the\n    deprecation was introduced and the expected version in which the corresponding functionality will be removed Attributes:\n        message: Description of the war..."}, {"qid": "", "rank": 2, "path": "pydantic/type_adapter.py", "score": 0.3748586177825928, "span_start": null, "span_end": null, "passage": "Thus, this feature is opt-in to ensure backwards\n    compatibility Attributes:\n        core_schema: The core schema for the type validator (SchemaValidator): The schema validator for the type serializ..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_utils.py", "score": 0.33563780784606934, "span_start": null, "span_end": null, "passage": "Both `base` and `override` are converted to dictionaries if possible Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values Each key-value pair existing in `ba..."}, {"qid": "", "rank": 4, "path": "pydantic/functional_serializers.py", "score": 0.32413727045059204, "span_start": null, "span_end": null, "passage": "For example, here's a scenario in which a wrap serializer transforms timezones to UTC **and** utilizes the existing `datetime` serialization logic"}, {"qid": "", "rank": 5, "path": "pydantic/type_adapter.py", "score": 0.3164210319519043, "span_start": null, "span_end": null, "passage": "For backward compatibility we don't rebuild model mocks\n                # here as part of __init__ even though TypeAdapter itself is not using deferred building"}, {"qid": "", "rank": 6, "path": "pydantic/v1/utils.py", "score": 0.3135196566581726, "span_start": null, "span_end": null, "passage": "Both ``base`` and ``override`` are converted to dictionaries if possible Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values Each key-value pair existing in..."}, {"qid": "", "rank": 7, "path": "pydantic/config.py", "score": 0.3120914399623871, "span_start": null, "span_end": null, "passage": "Meaning when `defer_build` is `True` and `experimental_defer_build_mode` is the default `('model',)`\n    then `TypeAdapter` immediately constructs its validator and serializer instead of postponing sa..."}, {"qid": "", "rank": 8, "path": "tests/test_serialize.py", "score": 0.30995193123817444, "span_start": null, "span_end": null, "passage": "\"\"\"\nNew tests for v2 of serialization logic"}, {"qid": "", "rank": 9, "path": "tests/test_edge_cases.py", "score": 0.2909572422504425, "span_start": null, "span_end": null, "passage": "This is not compatible with e.g"}, {"qid": "", "rank": 10, "path": "tests/test_fields.py", "score": 0.2901252210140228, "span_start": null, "span_end": null, "passage": "Basically, I think retaining the flexibility\n    # is worth the increased potential for weird/confusing \"accidental\" overrides"}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generics.py", "score": 0.2805730104446411, "span_start": null, "span_end": null, "passage": "if sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[GenericTypesCacheKey, 'type[BaseModel]']\nelse:\n    GenericTypesCache = WeakV..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/generics.py", "score": 0.27995672821998596, "span_start": null, "span_end": null, "passage": "if sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[CacheKey, Type[BaseModel]]\n    AssignedParameters = WeakKeyDictionary[Type[B..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.2692386507987976, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is\n    newer, or especially older, than we expect (or need) Args:\n        version: The mypy version string Return:\n        T..."}, {"qid": "", "rank": 14, "path": "pydantic/warnings.py", "score": 0.26291975378990173, "span_start": null, "span_end": null, "passage": "This warning is raised when using experimental functionality in Pydantic It is raised to warn users that the functionality may change or be removed in future versions of Pydantic \"\"\""}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.2580581605434418, "span_start": null, "span_end": null, "passage": "def make_v1_generic_root_validator(\n    validator: V1RootValidatorFunction, pre: bool\n) -> V2CoreBeforeRootValidator | V2CoreAfterRootValidator:\n    \"\"\"Wrap a V1 style root validator for V2 compatibil..."}, {"qid": "", "rank": 16, "path": "pydantic/fields.py", "score": 0.2566497027873993, "span_start": null, "span_end": null, "passage": "discriminator: Field name or Discriminator for discriminating the type in a tagged union deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` b..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.25660866498947144, "span_start": null, "span_end": null, "passage": "__pydantic_decorators__: Metadata containing the decorators defined on the model This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1 __pydantic_generic_metadata__: Me..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/dataclasses.py", "score": 0.25529348850250244, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.25176820158958435, "span_start": null, "span_end": null, "passage": "Later `FieldInfo` instances override earlier ones Returns:\n            FieldInfo: A merged FieldInfo instance"}, {"qid": "", "rank": 20, "path": "pydantic/config.py", "score": 0.2510652244091034, "span_start": null, "span_end": null, "passage": "- `'never'` will not revalidate models and dataclasses during validation\n    - `'always'` will revalidate models and dataclasses during validation\n    - `'subclass-instances'` will revalidate models a..."}], "latency_ms": 3.348827362060547, "gold_paths": ["HISTORY.md", "README.md"]}
