{"qid": "lens_main_rag_code_0", "query": "How does the authentication system work?", "results": [{"qid": "", "rank": 1, "path": "pydantic/networks.py", "score": 0.4136565923690796, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 2, "path": "pydantic/types.py", "score": 0.258161723613739, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 3, "path": "tests/test_types.py", "score": 0.22611993551254272, "span_start": null, "span_end": null, "passage": "# Use bytes that can't be decoded with UTF8 (https://github.com/pydantic/pydantic/issues/7971)\n    password = b'\\x89PNG\\r\\n\\x1a\\n'\n    f = Foobar(password=password, empty_password=b'')\n\n    # Assert c..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generate_schema.py", "score": 0.22442635893821716, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 5, "path": "pydantic/v1/dataclasses.py", "score": 0.21519140899181366, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.2111508846282959, "span_start": null, "span_end": null, "passage": "Then there are the registration hooks below"}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.20087830722332, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, SecretBytes\n\n    class User(BaseModel):\n        username: str\n        password: SecretBytes\n\n    user = User(username='scolvin', password=b'password1')\n    #>..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/typing.py", "score": 0.19931566715240479, "span_start": null, "span_end": null, "passage": "For unions, basic simplifications used by Union constructor are performed"}, {"qid": "", "rank": 9, "path": "tests/test_types.py", "score": 0.1991727650165558, "span_start": null, "span_end": null, "passage": "assert str(f.password) == '**********'\n    assert str(f.empty_password) == ''\n    assert repr(f.password) == \"SecretStr('**********')\"\n    assert repr(f.empty_password) == \"SecretStr('')\"\n    assert l..."}, {"qid": "", "rank": 10, "path": "pydantic/plugin/__init__.py", "score": 0.18912377953529358, "span_start": null, "span_end": null, "passage": "Args:\n            input: The JSON data to be validated strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators self_in..."}, {"qid": "", "rank": 11, "path": "tests/test_types.py", "score": 0.1864767074584961, "span_start": null, "span_end": null, "passage": "assert str(f.password) == \"b'**********'\"\n    assert str(f.empty_password) == \"b''\"\n    assert repr(f.password) == \"SecretBytes(b'**********')\"\n    assert repr(f.empty_password) == \"SecretBytes(b'')\"\n..."}, {"qid": "", "rank": 12, "path": "pydantic/plugin/__init__.py", "score": 0.18594428896903992, "span_start": null, "span_end": null, "passage": "Args:\n            input: The input to be validated strict: Whether to validate the object in strict mode from_attributes: Whether to validate objects as inputs by extracting attributes context: The co..."}, {"qid": "", "rank": 13, "path": "tests/test_types.py", "score": 0.18306615948677063, "span_start": null, "span_end": null, "passage": "assert str(f.password) == '**********'\n    assert str(f.empty_password) == ''\n    assert repr(f.password) == \"DecryptableStr('**********')\"\n    assert repr(f.empty_password) == \"SecretStr('')\"\n    ass..."}, {"qid": "", "rank": 14, "path": "tests/test_types.py", "score": 0.17922259867191315, "span_start": null, "span_end": null, "passage": "assert f == f.model_copy()\n    copied_with_changes = f.model_copy()\n    copied_with_changes.password = SecretBytes(b'4321')\n    assert f != copied_with_changes\n\n\ndef test_secretbytes_equality():\n    a..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.1792009323835373, "span_start": null, "span_end": null, "passage": "\"\"\"\n        num_masked = len(self) - 10  # len(bin) + len(last4) == 10\n        return f'{self.bin}{\"*\" * num_masked}{self.last4}'\n\n    @classmethod\n    def validate_digits(cls, card_number: str) -> No..."}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.17397235333919525, "span_start": null, "span_end": null, "passage": "This allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,\n    but without needing to have a single shared field across all the union choices This also makes i..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.17364785075187683, "span_start": null, "span_end": null, "passage": "It displays `b'**********'` instead of the string value on `repr()` and `str()` calls When the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\n    calls..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.171620711684227, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.17140409350395203, "span_start": null, "span_end": null, "passage": "Args:\n            inputs: A sequence of tuples, where:\n\n                - The first element is a JSON schema key type - The second element is the JSON mode: either 'validation' or 'serialization' - Th..."}, {"qid": "", "rank": 20, "path": ".github/actions/people/people.py", "score": 0.16924235224723816, "span_start": null, "span_end": null, "passage": "\"\"\"Use the github API to get lists of people who have contributed in various ways to Pydantic This logic is inspired by that of @tiangolo's\n[FastAPI people script](https://github.com/tiangolo/fastapi/..."}], "latency_ms": 3.9756298065185547, "gold_paths": ["release/make_history.py", "tests/conftest.py", "tests/test_config.py"]}
{"qid": "lens_main_rag_code_1", "query": "What is the error handling strategy?", "results": [{"qid": "", "rank": 1, "path": "pydantic/deprecated/class_validators.py", "score": 0.3747655153274536, "span_start": null, "span_end": null, "passage": "allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n            the decorated function Defaults to False Returns:\n        Callable: A decorator that can be..."}, {"qid": "", "rank": 2, "path": "pydantic/plugin/__init__.py", "score": 0.36158594489097595, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return\n\n    def on_exception(self, exception: Exception) -> None:\n        \"\"\"Callback to be notified of validation exceptions Args:\n            exception: The exception raised during valid..."}, {"qid": "", "rank": 3, "path": "pydantic/deprecated/class_validators.py", "score": 0.35861366987228394, "span_start": null, "span_end": null, "passage": "Args:\n        pre (bool, optional): Whether this validator should be called before the standard\n            validators (else after) Defaults to False skip_on_failure (bool, optional): Whether to stop ..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/fields.py", "score": 0.3478968143463135, "span_start": null, "span_end": null, "passage": "This method should be idempotent, e.g it should be safe to call multiple times\n        without mis-configuring the field"}, {"qid": "", "rank": 5, "path": "pydantic/_migration.py", "score": 0.345816433429718, "span_start": null, "span_end": null, "passage": "Args:\n        module: The module name Returns:\n        A callable that will raise an error if the object is not found \"\"\"\n    # This avoids circular import with errors.py from .errors import PydanticI..."}, {"qid": "", "rank": 6, "path": "tests/plugin/example_plugin.py", "score": 0.34250929951667786, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nm = MyModel(x='10')\nif m.x != 10:\n    raise ValueError('m.x should be 10')\n\nlog = []\n\n\nclass ValidatePythonHandler:\n    def on_e..."}, {"qid": "", "rank": 7, "path": "pydantic/main.py", "score": 0.34005221724510193, "span_start": null, "span_end": null, "passage": "exclude_unset: Whether to exclude fields that have not been explicitly set exclude_defaults: Whether to exclude fields that are set to their default value exclude_none: Whether to exclude fields that ..."}, {"qid": "", "rank": 8, "path": "pydantic/plugin/__init__.py", "score": 0.32740193605422974, "span_start": null, "span_end": null, "passage": "Returns:\n            A tuple of optional event handlers for each of the three validation methods -\n                `validate_python`, `validate_json`, `validate_strings` \"\"\"\n        raise NotImplement..."}, {"qid": "", "rank": 9, "path": "pydantic/types.py", "score": 0.3228856921195984, "span_start": null, "span_end": null, "passage": "this annotation omits the item from the iteration if there is any error validating it That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterab..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/datetime_parse.py", "score": 0.31135472655296326, "span_start": null, "span_end": null, "passage": "Raise ValueError if the input is well formatted but not a valid time Raise ValueError if the input isn't well formatted, in particular if it contains an offset"}, {"qid": "", "rank": 11, "path": "pydantic/errors.py", "score": 0.3051813244819641, "span_start": null, "span_end": null, "passage": "Attributes:\n        message: A message describing the error code: An optional error code from PydanticErrorCodes enum"}, {"qid": "", "rank": 12, "path": "pydantic/v1/validators.py", "score": 0.30343449115753174, "span_start": null, "span_end": null, "passage": "use a different JSON library like ujson\n    if isinstance(v, (str, bytes, bytearray)) and len(v) > max_str_int:\n        raise errors.IntegerError()\n\n    try:\n        return int(v)\n    except (TypeErro..."}, {"qid": "", "rank": 13, "path": "pydantic/functional_validators.py", "score": 0.30274519324302673, "span_start": null, "span_end": null, "passage": "Args:\n        field: The first field the `field_validator` should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one *fields: Addition..."}, {"qid": "", "rank": 14, "path": "pydantic/type_adapter.py", "score": 0.301297128200531, "span_start": null, "span_end": null, "passage": "warnings: How to handle serialization errors False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationErro..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/mypy.py", "score": 0.2968127131462097, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 16, "path": "pydantic/mypy.py", "score": 0.2968127131462097, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.29610416293144226, "span_start": null, "span_end": null, "passage": "Also provides a way to label a union case in error messages When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\n    should be used to identify tha..."}, {"qid": "", "rank": 18, "path": "pydantic/deprecated/class_validators.py", "score": 0.29564782977104187, "span_start": null, "span_end": null, "passage": "@overload\ndef root_validator(\n    *,\n    # if you specify `pre=True` then you don't need to specify\n    # `skip_on_failure`, in fact it is not allowed as an argument pre: Literal[True],\n    allow_reus..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.2953602969646454, "span_start": null, "span_end": null, "passage": "`model_name` is accepted for the purpose of producing useful error messages"}, {"qid": "", "rank": 20, "path": "pydantic/plugin/__init__.py", "score": 0.29460084438323975, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    on_enter: Callable[..., None]\n    \"\"\"`on_enter` is changed to be more specific on all subclasses\"\"\"\n\n    def on_success(self, result: Any) -> None:\n        \"\"\"Callback to be notified of succe..."}], "latency_ms": 4.476785659790039, "gold_paths": ["pydantic/error_wrappers.py", "pydantic/__init__.py", "pydantic/_migration.py"]}
{"qid": "lens_main_rag_code_2", "query": "How are database connections managed?", "results": [{"qid": "", "rank": 1, "path": "pydantic/networks.py", "score": 0.2789837718009949, "span_start": null, "span_end": null, "passage": "More: https://nats.io\n\"\"\"\nMySQLDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=[\n            'mysql',\n            'mysql+mysqlconnector',\n            'mysql+aiomysql',\n          ..."}, {"qid": "", "rank": 2, "path": "pydantic/networks.py", "score": 0.25838330388069153, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n\"\"\"\nMariaDBDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=['mariadb', 'mariadb+mariadbconnector', 'mariadb+pymysql'],\n   ..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.24854923784732819, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.23359255492687225, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 5, "path": "pydantic/v1/dataclasses.py", "score": 0.21964716911315918, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 6, "path": "pydantic/networks.py", "score": 0.200788676738739, "span_start": null, "span_end": null, "passage": "Attributes:\n        max_length: The maximum length of the url Defaults to `None` allowed_schemes: The allowed schemes Defaults to `None` host_required: Whether the host is required Defaults to `None` ..."}, {"qid": "", "rank": 7, "path": "pydantic/networks.py", "score": 0.18917500972747803, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required (e.g., `rediss://:pass@localhost`)\n\"\"\"\nMongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=['mongodb', 'mongodb+srv'], default_por..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generate_schema.py", "score": 0.1885775923728943, "span_start": null, "span_end": null, "passage": "The general structure is a series of if statements starting with the simple cases\n        (non-generic primitive types) and then handling generics and other more complex cases Each case either generat..."}, {"qid": "", "rank": 9, "path": "pydantic/type_adapter.py", "score": 0.1804368793964386, "span_start": null, "span_end": null, "passage": "module: The module that passes to plugin if provided !! note\n            You cannot use the `config` argument when instantiating a `TypeAdapter` if the type you're using has its own\n            config..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.1777743399143219, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n* Supports multiple hosts\n\nIf further validation is required, these properties can be used by validators to enforce specific behaviour:\n\n```py\nf..."}, {"qid": "", "rank": 11, "path": "pydantic/networks.py", "score": 0.17238202691078186, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n\"\"\"\nAmqpDsn = Annotated[Url, UrlConstraints(allowed_schemes=['amqp', 'amqps'])]\n\"\"\"A type that will accept any AMQP DSN * User info required\n* T..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_model_construction.py", "score": 0.16634535789489746, "span_start": null, "span_end": null, "passage": "Args:\n        cls: BaseModel or dataclass bases: Parents of the class, generally `cls.__bases__` config_wrapper: The config wrapper instance types_namespace: Optional extra namespace to look for types..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.1661950945854187, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_dataclasses.py", "score": 0.16447365283966064, "span_start": null, "span_end": null, "passage": "This logic is called on a class which has already been wrapped in `dataclasses.dataclass()` This is somewhat analogous to `pydantic._internal._model_construction.complete_model_class` Args:\n        cl..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_config.py", "score": 0.16326124966144562, "span_start": null, "span_end": null, "passage": "The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        A..."}, {"qid": "", "rank": 16, "path": "pydantic/plugin/__init__.py", "score": 0.16108720004558563, "span_start": null, "span_end": null, "passage": "It should return an event handler for each of the three validation methods, or `None` if the plugin does not\n        implement that method Args:\n            schema: The schema to validate against sche..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_dataclasses.py", "score": 0.15739428997039795, "span_start": null, "span_end": null, "passage": "__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the dataclass __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the dataclas..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.15414628386497498, "span_start": null, "span_end": null, "passage": "Then there are the registration hooks below"}, {"qid": "", "rank": 19, "path": "pydantic/mypy.py", "score": 0.14938202500343323, "span_start": null, "span_end": null, "passage": "Attributes:\n        tracked_config_fields: A set of field configs that the plugin has to track their value"}, {"qid": "", "rank": 20, "path": "pydantic/networks.py", "score": 0.1469435691833496, "span_start": null, "span_end": null, "passage": "* TLD not required\n* Host required\n\"\"\"\nPostgresDsn = Annotated[\n    MultiHostUrl,\n    UrlConstraints(\n        host_required=True,\n        allowed_schemes=[\n            'postgres',\n            'postgre..."}], "latency_ms": 4.16874885559082, "gold_paths": ["pydantic/__init__.py", "pydantic/_migration.py", "pydantic/networks.py"]}
{"qid": "lens_main_rag_code_3", "query": "What caching mechanisms are used?", "results": [{"qid": "", "rank": 1, "path": "pydantic/fields.py", "score": 0.49980878829956055, "span_start": null, "span_end": null, "passage": "This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generics.py", "score": 0.43841275572776794, "span_start": null, "span_end": null, "passage": "As a concrete example, this approach was necessary to make Model[List[T]][int] equal to Model[List[int]] The approach could be modified to not use two different cache keys at different points, but the..."}, {"qid": "", "rank": 3, "path": "tests/test_edge_cases.py", "score": 0.4183235764503479, "span_start": null, "span_end": null, "passage": "functools.cached_property,\n    which caches the computed values in the instance's __dict__\n    \"\"\"\n\n    class Model(BaseModel):\n        attr: int\n\n        @functools.cached_property\n        def cached..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/generics.py", "score": 0.41026750206947327, "span_start": null, "span_end": null, "passage": "_generic_types_cache = GenericTypesCache()\n\n# _assigned_parameters is a Mapping from parametrized version of generic models to assigned types of parametrizations\n# as captured during construction of t..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generics.py", "score": 0.37756043672561646, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return _GENERIC_TYPES_CACHE.get(_early_cache_key(parent, typevar_values))\n\n\ndef get_cached_generic_type_late(\n    parent: type[BaseModel], typevar_values: Any, origin: type[BaseModel], args: t..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_generics.py", "score": 0.348014771938324, "span_start": null, "span_end": null, "passage": "If it turns out that a different set of inputs to\n    __class_getitem__ resulted in the same inputs to the generic type creation process, we can still\n    return the cached type, and update the cache ..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generics.py", "score": 0.3469056487083435, "span_start": null, "span_end": null, "passage": "If we wanted to move to only using a single cache key per type, we would either need to always use the\n    slower/more computationally intensive logic associated with _late_cache_key, or would need to..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generics.py", "score": 0.342538982629776, "span_start": null, "span_end": null, "passage": "KT = TypeVar('KT')\nVT = TypeVar('VT')\n_LIMITED_DICT_SIZE = 100\nif TYPE_CHECKING:\n\n    class LimitedDict(dict, MutableMapping[KT, VT]):\n        def __init__(self, size_limit: int = _LIMITED_DICT_SIZE):..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generics.py", "score": 0.3310222625732422, "span_start": null, "span_end": null, "passage": "Note that this is overly simplistic, and it's possible that two different cls/typevar_values\n    inputs would ultimately result in the same type being created in BaseModel.__class_getitem__ To handle ..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generics.py", "score": 0.3219282031059265, "span_start": null, "span_end": null, "passage": "#   Right now, to handle recursive generics, we some types must remain cached for brief periods without references #   By chaining the WeakValuesDict with a LimitedDict, we have a way to retain cachin..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/generics.py", "score": 0.3172273337841034, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def _cache_key(_params: Any) -> CacheKey:\n            args = get_args(_params)\n            # python returns a list for Callables, which is not hashable\n            if len(args) == 2 and i..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_generics.py", "score": 0.3134748041629791, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return cls, typevar_values, _union_orderings_key(typevar_values)\n\n\ndef _late_cache_key(origin: type[BaseModel], args: tuple[Any, ...], typevar_values: Any) -> GenericTypesCacheKey:\n    \"\"\"This..."}, {"qid": "", "rank": 13, "path": "pydantic/config.py", "score": 0.3038260042667389, "span_start": null, "span_end": null, "passage": "Enabling this setting should significantly improve validation performance while increasing memory usage slightly - `True` or `'all'` (the default): cache all strings\n    - `'keys'`: cache only diction..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generics.py", "score": 0.29344338178634644, "span_start": null, "span_end": null, "passage": "\"\"\"\n    _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values)] = type_\n    if len(typevar_values) == 1:\n        _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values[0])] = type_\n    if..."}, {"qid": "", "rank": 15, "path": "pydantic/fields.py", "score": 0.2844536304473877, "span_start": null, "span_end": null, "passage": "```py\n    from functools import cached_property\n\n    from pydantic import BaseModel, computed_field\n\n    class Model(BaseModel):\n        foo: int\n\n        @computed_field\n        @cached_property\n    ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.2836275100708008, "span_start": null, "span_end": null, "passage": "(See https://github.com/python/cpython/issues/86483 for reference.)\n    \"\"\"\n    if isinstance(typevar_values, tuple):\n        args_data = []\n        for value in typevar_values:\n            args_data...."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.28357648849487305, "span_start": null, "span_end": null, "passage": "Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions)"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generics.py", "score": 0.2801666259765625, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # The _union_orderings_key is placed at the start here to ensure there cannot be a collision with an\n    # _early_cache_key, as that function will always produce a BaseModel subclass as the fi..."}, {"qid": "", "rank": 19, "path": "pydantic/functional_serializers.py", "score": 0.27681949734687805, "span_start": null, "span_end": null, "passage": "An example would be to serialize temperature to the same temperature scale, such as degrees Celsius"}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.2712782621383667, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting\n    modifications to the definition schema Used internally by Pydantic, please do not rely on this implementation See `..."}], "latency_ms": 3.7806034088134766, "gold_paths": ["pydantic/__init__.py", "pydantic/color.py", "pydantic/config.py"]}
{"qid": "lens_main_rag_code_4", "query": "How is input validation implemented?", "results": [{"qid": "", "rank": 1, "path": "pydantic/plugin/__init__.py", "score": 0.5851633548736572, "span_start": null, "span_end": null, "passage": "Args:\n            input: The input to be validated strict: Whether to validate the object in strict mode from_attributes: Whether to validate objects as inputs by extracting attributes context: The co..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_decorators.py", "score": 0.5668169260025024, "span_start": null, "span_end": null, "passage": "\"\"\"Logic related to validators applied to models etc"}, {"qid": "", "rank": 3, "path": "pydantic/plugin/__init__.py", "score": 0.5637209415435791, "span_start": null, "span_end": null, "passage": "Args:\n            input: The JSON data to be validated strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators self_in..."}, {"qid": "", "rank": 4, "path": "pydantic/functional_validators.py", "score": 0.5038717985153198, "span_start": null, "span_end": null, "passage": "Args:\n        field: The first field the `field_validator` should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one *fields: Addition..."}, {"qid": "", "rank": 5, "path": "pydantic/functional_validators.py", "score": 0.4933333694934845, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 6, "path": "pydantic/functional_validators.py", "score": 0.4933333098888397, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 7, "path": "pydantic/functional_validators.py", "score": 0.4933333098888397, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 8, "path": "pydantic/functional_validators.py", "score": 0.4933333098888397, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 9, "path": "pydantic/v1/dataclasses.py", "score": 0.48744916915893555, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 10, "path": "pydantic/plugin/__init__.py", "score": 0.4836358428001404, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\nStringInput: TypeAlias = 'dict[str, StringInput]'\n\n\nclass ValidateStringsHandlerProtocol(BaseValidateHandlerProtocol, Protocol):\n    \"\"\"Event handler for `SchemaValidator.validate_s..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generate_schema.py", "score": 0.48178476095199585, "span_start": null, "span_end": null, "passage": "This serves as an auxiliary function for re-implementing that logic, by looping over a provided\n    collection of (v1-style) ValidatorDecoratorInfo's and checking if any of them have `always=True` We ..."}, {"qid": "", "rank": 12, "path": "tests/test_dataclasses.py", "score": 0.47934627532958984, "span_start": null, "span_end": null, "passage": "In V1 we called it before validation, in V2 it gets called after"}, {"qid": "", "rank": 13, "path": "pydantic/v1/class_validators.py", "score": 0.47170957922935486, "span_start": null, "span_end": null, "passage": "def root_validator(\n    _func: Optional[AnyCallable] = None, *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False\n) -> Union['AnyClassMethod', Callable[[AnyCallable], 'AnyCla..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.4691621959209442, "span_start": null, "span_end": null, "passage": "\"\"\"Logic for V1 validators, e.g"}, {"qid": "", "rank": 15, "path": "pydantic/plugin/__init__.py", "score": 0.4638664722442627, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return\n\n\nclass ValidatePythonHandlerProtocol(BaseValidateHandlerProtocol, Protocol):\n    \"\"\"Event handler for `SchemaValidator.validate_python`.\"\"\"\n\n    def on_enter(\n        self,\n       ..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/main.py", "score": 0.45321229100227356, "span_start": null, "span_end": null, "passage": "Raises ValidationError if the input data cannot be parsed to form a valid model"}, {"qid": "", "rank": 17, "path": "pydantic/deprecated/class_validators.py", "score": 0.4477464556694031, "span_start": null, "span_end": null, "passage": "Args:\n        __field (str): The first field the validator should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one *fields (str): Ad..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4383280277252197, "span_start": null, "span_end": null, "passage": "Args:\n        schema: The schema to apply validators on validators: An iterable of validators field_name: The name of the field if validators are being applied to a model field Returns:\n        The up..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.4365922808647156, "span_start": null, "span_end": null, "passage": "Args:\n            inputs: A sequence of tuples, where:\n\n                - The first element is a JSON schema key type - The second element is the JSON mode: either 'validation' or 'serialization' - Th..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.4365876317024231, "span_start": null, "span_end": null, "passage": "Args:\n        mode: A required string literal that specifies the validation mode It can be one of the following: 'wrap', 'before', or 'after' Returns:\n        A decorator that can be used to decorate ..."}], "latency_ms": 3.805398941040039, "gold_paths": ["pydantic/__init__.py", "pydantic/_migration.py", "pydantic/aliases.py"]}
{"qid": "lens_main_rag_code_5", "query": "What logging framework is configured?", "results": [{"qid": "", "rank": 1, "path": "pydantic/mypy.py", "score": 0.29296305775642395, "span_start": null, "span_end": null, "passage": "Attributes:\n        tracked_config_fields: A set of field configs that the plugin has to track their value"}, {"qid": "", "rank": 2, "path": "pydantic/json_schema.py", "score": 0.27623623609542847, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n\nclass PydanticJsonSchemaWarning(UserWarning):\n    \"\"\"This class is used to emit warnings produced during JSON schema generation See the [`GenerateJsonSchema.emit_warning`][pydantic.json_schema.G..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/fields.py", "score": 0.26156699657440186, "span_start": null, "span_end": null, "passage": ":param field_name: name of the field for use in error messages\n        :param annotation: a type hint such as `str` or `Annotated[str, Field(..., min_length=5)]`\n        :param value: the field's assi..."}, {"qid": "", "rank": 4, "path": "pydantic/main.py", "score": 0.24921461939811707, "span_start": null, "span_end": null, "passage": "Args:\n        model_name: The name of the newly created model __config__: The configuration of the new model __doc__: The docstring of the new model __base__: The base class or classes for the new mod..."}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.24813252687454224, "span_start": null, "span_end": null, "passage": "This is used to encode default values for fields in the generated JSON schema Args:\n            dft: The default value to encode Returns:\n            The encoded default value"}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_model_construction.py", "score": 0.24323998391628265, "span_start": null, "span_end": null, "passage": "Args:\n        cls: BaseModel or dataclass bases: Parents of the class, generally `cls.__bases__` config_wrapper: The config wrapper instance types_namespace: Optional extra namespace to look for types..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_config.py", "score": 0.24267426133155823, "span_start": null, "span_end": null, "passage": "The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        A..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.23842711746692657, "span_start": null, "span_end": null, "passage": "\"\"\"Types and utility functions used by various other internal tools.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import core_schema\nfrom..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_core_utils.py", "score": 0.23557686805725098, "span_start": null, "span_end": null, "passage": "This is intended for debugging purposes Args:\n        schema: The CoreSchema to print include_metadata: Whether to include metadata in the output Defaults to `False`"}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.23164212703704834, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    tracked_config_fields: set[str] = {\n        'extra',\n        'frozen',\n        'from_attributes',\n        'populate_by_name',\n        'alias_generator',\n    }\n\n    def __init__(\n        self,..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.22846363484859467, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting\n    modifications to the definition schema Used internally by Pydantic, please do not rely on this implementation See `..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.22562894225120544, "span_start": null, "span_end": null, "passage": "Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)\n        \"\"\"\n        if name not in self.tracked_config_fields:\n            return None\n   ..."}, {"qid": "", "rank": 13, "path": "pydantic/fields.py", "score": 0.22422245144844055, "span_start": null, "span_end": null, "passage": "discriminator: Field name or Discriminator for discriminating the type in a tagged union deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` b..."}, {"qid": "", "rank": 14, "path": "pydantic/warnings.py", "score": 0.22205376625061035, "span_start": null, "span_end": null, "passage": "It provides information on when the\n    deprecation was introduced and the expected version in which the corresponding functionality will be removed Attributes:\n        message: Description of the war..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.22166360914707184, "span_start": null, "span_end": null, "passage": "Used internally by Pydantic, please do not rely on this implementation See `GetCoreSchemaHandler` for the handler API"}, {"qid": "", "rank": 16, "path": "tests/test_main.py", "score": 0.22053179144859314, "span_start": null, "span_end": null, "passage": "with warnings.catch_warnings(record=True) as captured_warnings:\n        # Start capturing all warnings\n        warnings.simplefilter('always')\n\n        class ChildWithoutRedefinedField(BaseModel, Pare..."}, {"qid": "", "rank": 17, "path": "tests/plugin/example_plugin.py", "score": 0.21876825392246246, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nm = MyModel(x='10')\nif m.x != 10:\n    raise ValueError('m.x should be 10')\n\nlog = []\n\n\nclass ValidatePythonHandler:\n    def on_e..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_dataclasses.py", "score": 0.21522195637226105, "span_start": null, "span_end": null, "passage": "Args:\n        cls: The class types_namespace: The types namespace, defaults to `None` config_wrapper: The config wrapper instance, defaults to `None`"}, {"qid": "", "rank": 19, "path": "pydantic/v1/mypy.py", "score": 0.21013915538787842, "span_start": null, "span_end": null, "passage": "Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)\n        \"\"\"\n        lhs = substmt.lvalues[0]\n        if not (isinstance(lhs, NameExpr) and..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/errors.py", "score": 0.20710237324237823, "span_start": null, "span_end": null, "passage": "__all__ = (\n    'PydanticTypeError',\n    'PydanticValueError',\n    'ConfigError',\n    'MissingError',\n    'ExtraError',\n    'NoneIsNotAllowedError',\n    'NoneIsAllowedError',\n    'WrongConstantError',..."}], "latency_ms": 3.649473190307617, "gold_paths": ["pydantic/config.py", "pydantic/dataclasses.py", "pydantic/fields.py"]}
{"qid": "lens_main_rag_code_6", "query": "How are API responses formatted?", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.4713056981563568, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n'\n            f'    [`{api_link}`][{api_link}]<br>'\n            f'{content[heading_end:]}'\n        )\n\n    return f'!!"}, {"qid": "", "rank": 2, "path": "pydantic/main.py", "score": 0.4466392397880554, "span_start": null, "span_end": null, "passage": "Returns:\n            A JSON string representation of the model"}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.4372316598892212, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        .. @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        \"\"\"Encode the data using the encoder Ar..."}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.4318828284740448, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.41787731647491455, "span_start": null, "span_end": null, "passage": "Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.40208470821380615, "span_start": null, "span_end": null, "passage": "# At the end of schema generation, we use these to produce a JSON schema with more human-readable\n        # definitions, which would also work better in a generated OpenAPI client, etc"}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.39452534914016724, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return base64.encodebytes(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64']:\n        \"\"\"Get the JSON format for the encoded data Returns:\n            The JSON form..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/utils.py", "score": 0.38949862122535706, "span_start": null, "span_end": null, "passage": "Useful with Representation when you want to return a string\n    representation of something that valid (or pseudo-valid) python \"\"\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n\nclass Rep..."}, {"qid": "", "rank": 9, "path": "pydantic/json_schema.py", "score": 0.3892212510108948, "span_start": null, "span_end": null, "passage": "This is used to encode default values for fields in the generated JSON schema Args:\n            dft: The default value to encode Returns:\n            The encoded default value"}, {"qid": "", "rank": 10, "path": "pydantic/type_adapter.py", "score": 0.38359349966049194, "span_start": null, "span_end": null, "passage": "(These schemas may have\n                    JsonRef references to definitions that are defined in the second returned element.)\n                - The second element is a JSON schema containing all def..."}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.38359349966049194, "span_start": null, "span_end": null, "passage": "(These schemas may have\n                JsonRef references to definitions that are defined in the second returned element.)\n            - The second element is a JSON schema containing all definitions..."}, {"qid": "", "rank": 12, "path": "pydantic/json_schema.py", "score": 0.378664493560791, "span_start": null, "span_end": null, "passage": "Args:\n            inputs: A sequence of tuples, where:\n\n                - The first element is a JSON schema key type - The second element is the JSON mode: either 'validation' or 'serialization' - Th..."}, {"qid": "", "rank": 13, "path": "pydantic/main.py", "score": 0.3729517459869385, "span_start": null, "span_end": null, "passage": "Args:\n            indent: Indentation to use in the JSON output If None is passed, the output will be compact include: Field(s) to include in the JSON output exclude: Field(s) to exclude from the JSON..."}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.36798930168151855, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        return self.encoder.decode(data)\n\n    def encode(self, value: bytes) -> bytes:\n        \"\"\"Encode the data u..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.3672472834587097, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        return data.decode()\n\n    def encode_str(self, value: str) -> str:\n        \"\"\"Encode the data using the spe..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.3645717203617096, "span_start": null, "span_end": null, "passage": "This class generates JSON schemas based on configured parameters The default schema dialect\n    is [https://json-schema.org/draft/2020-12/schema](https://json-schema.org/draft/2020-12/schema) The clas..."}, {"qid": "", "rank": 17, "path": "pydantic/plugin/__init__.py", "score": 0.3634244203567505, "span_start": null, "span_end": null, "passage": "Args:\n            input: The JSON data to be validated strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators self_in..."}, {"qid": "", "rank": 18, "path": "pydantic/config.py", "score": 0.3628852367401123, "span_start": null, "span_end": null, "passage": "- `'iso8601'` will serialize timedeltas to ISO 8601 durations - `'float'` will serialize timedeltas to the total number of seconds \"\"\"\n\n    ser_json_bytes: Literal['utf8', 'base64']\n    \"\"\"\n    The en..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.3603944182395935, "span_start": null, "span_end": null, "passage": "This flag provides a way to indicate whether you want the JSON schema required\nfor validation inputs, or that will be matched by serialization outputs"}, {"qid": "", "rank": 20, "path": "pydantic/functional_serializers.py", "score": 0.35667523741722107, "span_start": null, "span_end": null, "passage": "- `plain` means the function will be called instead of the default serialization logic,\n            - `wrap` means the function will be called with an argument to optionally call the\n               de..."}], "latency_ms": 3.9091110229492188, "gold_paths": ["pydantic/json.py", "pydantic/__init__.py", "pydantic/_migration.py"]}
{"qid": "lens_main_rag_code_8", "query": "How is configuration managed?", "results": [{"qid": "", "rank": 1, "path": "pydantic/mypy.py", "score": 0.44724932312965393, "span_start": null, "span_end": null, "passage": "It includes the config if config value is not `None`"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_config.py", "score": 0.44638726115226746, "span_start": null, "span_end": null, "passage": "old class-based config) or None Args:\n        config: The input config Returns:\n        A ConfigDict object created from config"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_config.py", "score": 0.4222949743270874, "span_start": null, "span_end": null, "passage": "The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        A..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_config.py", "score": 0.4025917649269104, "span_start": null, "span_end": null, "passage": "Args:\n        config_dict: The input config"}, {"qid": "", "rank": 5, "path": "pydantic/mypy.py", "score": 0.4006803333759308, "span_start": null, "span_end": null, "passage": "Attributes:\n        tracked_config_fields: A set of field configs that the plugin has to track their value"}, {"qid": "", "rank": 6, "path": "pydantic/v1/mypy.py", "score": 0.3460659384727478, "span_start": null, "span_end": null, "passage": "Similar to the fields-aware __init__ method, but always uses the field names (not aliases),\n        and does not treat settings fields as optional"}, {"qid": "", "rank": 7, "path": "pydantic/mypy.py", "score": 0.3460659384727478, "span_start": null, "span_end": null, "passage": "Similar to the fields-aware __init__ method, but always uses the field names (not aliases),\n        and does not treat settings fields as optional"}, {"qid": "", "rank": 8, "path": "pydantic/main.py", "score": 0.3407060503959656, "span_start": null, "span_end": null, "passage": "Args:\n        model_name: The name of the newly created model __config__: The configuration of the new model __doc__: The docstring of the new model __base__: The base class or classes for the new mod..."}, {"qid": "", "rank": 9, "path": "tests/mypy/modules/pydantic_settings.py", "score": 0.33730196952819824, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.32140201330184937, "span_start": null, "span_end": null, "passage": "It reads configs from toml file and returns `None` if the file is not a toml file"}, {"qid": "", "rank": 11, "path": "pydantic/v1/mypy.py", "score": 0.31896159052848816, "span_start": null, "span_end": null, "passage": "In particular:\n        * determines the model config and fields,\n        * adds a fields-aware signature for the initializer and construct methods\n        * freezes the class if allow_mutation = False..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_dataclasses.py", "score": 0.3054125905036926, "span_start": null, "span_end": null, "passage": "Args:\n        cls: The class types_namespace: The types namespace, defaults to `None` config_wrapper: The config wrapper instance, defaults to `None`"}, {"qid": "", "rank": 13, "path": "pydantic/v1/config.py", "score": 0.2901657521724701, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\ndef get_config(config: Union[ConfigDict, Type[object], None]) -> Type[BaseConfig]:\n    if config is None:\n        return BaseConfig\n\n    else:\n        config_dict = (\n            co..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/mypy.py", "score": 0.2852438986301422, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_model_construction.py", "score": 0.28250136971473694, "span_start": null, "span_end": null, "passage": "Args:\n        cls: BaseModel or dataclass bases: Parents of the class, generally `cls.__bases__` config_wrapper: The config wrapper instance types_namespace: Optional extra namespace to look for types..."}, {"qid": "", "rank": 16, "path": "pydantic/mypy.py", "score": 0.28189966082572937, "span_start": null, "span_end": null, "passage": "Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)\n        \"\"\"\n        if name not in self.tracked_config_fields:\n            return None\n   ..."}, {"qid": "", "rank": 17, "path": "pydantic/networks.py", "score": 0.26916950941085815, "span_start": null, "span_end": null, "passage": "Attributes:\n        max_length: The maximum length of the url Defaults to `None` allowed_schemes: The allowed schemes Defaults to `None` host_required: Whether the host is required Defaults to `None` ..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/schema.py", "score": 0.2684643566608429, "span_start": null, "span_end": null, "passage": ":param models: a list of models to include in the generated JSON Schema\n    :param by_alias: generate the schemas using the aliases defined, if any\n    :param title: title for the generated schema tha..."}, {"qid": "", "rank": 19, "path": "tests/mypy/outputs/1.4.1/pyproject-plugin_toml/pydantic_settings.py", "score": 0.2684617042541504, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 20, "path": "tests/mypy/outputs/1.4.1/mypy-plugin_ini/pydantic_settings.py", "score": 0.2684617042541504, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}], "latency_ms": 3.758668899536133, "gold_paths": ["pydantic/env_settings.py", "pydantic/__init__.py", "pydantic/_migration.py"]}
{"qid": "lens_main_rag_code_9", "query": "What testing strategy is used?", "results": [{"qid": "", "rank": 1, "path": "tests/test_internal.py", "score": 0.5449138879776001, "span_start": null, "span_end": null, "passage": "\"\"\"\nTests for internal things that are complex enough to warrant their own unit tests"}, {"qid": "", "rank": 2, "path": "tests/test_dataclasses.py", "score": 0.5313751697540283, "span_start": null, "span_end": null, "passage": "while working on one specific test"}, {"qid": "", "rank": 3, "path": "tests/test_serialize.py", "score": 0.43200087547302246, "span_start": null, "span_end": null, "passage": "\"\"\"\nNew tests for v2 of serialization logic"}, {"qid": "", "rank": 4, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.40007326006889343, "span_start": null, "span_end": null, "passage": "\"\"\"\nRegister Hypothesis strategies for Pydantic custom types This enables fully-automatic generation of test data for most Pydantic classes Note that this module has *no* runtime impact on Pydantic it..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.375152051448822, "span_start": null, "span_end": null, "passage": "See also:\n\nhttps://hypothesis.readthedocs.io/en/latest/strategies.html#registering-strategies-via-setuptools-entry-points\nhttps://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.re..."}, {"qid": "", "rank": 6, "path": "tests/test_validate_call.py", "score": 0.3522506356239319, "span_start": null, "span_end": null, "passage": "def __repr__(self) -> str:\n            assert False\n\n    Class(50)\n\n\ndef test_methods_are_not_rebound():\n    class Thing:\n        def __init__(self, x: int):\n            self.x = x\n\n        def a(self..."}, {"qid": "", "rank": 7, "path": "tests/test_forward_ref.py", "score": 0.34855329990386963, "span_start": null, "span_end": null, "passage": "type checking approach: (2a) `from __future__ import annotations` vs (2b) `ForwardRef`\n#\n#   The parameter tags \"1a\", \"1b\", \"2a\", and \"2b\" are used in the test names below, to indicate which combinati..."}, {"qid": "", "rank": 8, "path": "tests/test_utils.py", "score": 0.3429259657859802, "span_start": null, "span_end": null, "passage": "Given varied output, this test verifies that the content of the output is as expected,\n    Rather than doing robust formatting testing"}, {"qid": "", "rank": 9, "path": "tests/test_forward_ref.py", "score": 0.3228412866592407, "span_start": null, "span_end": null, "passage": "#   The initial attempt to refactor them into a single parameterized test was not straightforward due to the use of the\n#   `create_module` fixture and the requirement that `from __future__ import ann..."}, {"qid": "", "rank": 10, "path": "tests/test_version.py", "score": 0.31907206773757935, "span_start": null, "span_end": null, "passage": "from unittest.mock import patch\n\nimport pytest\nfrom packaging.version import parse as parse_version\n\nimport pydantic\nfrom pydantic.version import version_info, version_short\n\n\ndef test_version_info():..."}, {"qid": "", "rank": 11, "path": "tests/benchmarks/test_north_star.py", "score": 0.30685698986053467, "span_start": null, "span_end": null, "passage": "\"\"\"\nAn integration-style benchmark of a model with a class of what should\n(hopefully) be some of the most common field types used in pydantic validation Used to gauge overall pydantic performance"}, {"qid": "", "rank": 12, "path": "pydantic/experimental/pipeline.py", "score": 0.30398425459861755, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}, {"qid": "", "rank": 13, "path": "tests/test_dataclasses.py", "score": 0.28932809829711914, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    @dataclasses.dataclass\n    class A:\n        a: float\n\n        def __post_init__(self):\n            self.a *= 2\n\n    assert A(a=1.2).a == 2.4\n\n    @pydantic.dataclasses.dataclass\n    class B(A..."}, {"qid": "", "rank": 14, "path": "tests/test_dataclasses.py", "score": 0.2881724238395691, "span_start": null, "span_end": null, "passage": "assert real_dc <= real_dc\n    assert model.dc <= model.dc\n    assert real_dc <= model.dc\n\n\ndef test_issue_2424():\n    @dataclasses.dataclass\n    class Base:\n        x: str\n\n    @dataclasses.dataclass\n..."}, {"qid": "", "rank": 15, "path": "tests/test_validate_call.py", "score": 0.28745895624160767, "span_start": null, "span_end": null, "passage": "This test is just to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n    globs = {}\n    exec(\n        \"\"\"\nfrom typing import Iterable\nfrom pydantic import validate_call\n\n@validate..."}, {"qid": "", "rank": 16, "path": "tests/test_validators.py", "score": 0.2858579456806183, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: str\n        b: str\n\n        @field_validator('b', mode='before')\n        @classmethod\n        def check_a(cls, v: Any, info: ValidationInfo) -> Any:\n       ..."}, {"qid": "", "rank": 17, "path": "tests/test_plugin_loader.py", "score": 0.2773773670196533, "span_start": null, "span_end": null, "passage": "import importlib.metadata as importlib_metadata\nimport os\nfrom unittest.mock import patch\n\nimport pytest\n\nimport pydantic.plugin._loader as loader\n\n\nclass EntryPoint:\n    def __init__(self, name, valu..."}, {"qid": "", "rank": 18, "path": "tests/pyright/pyright_example.py", "score": 0.27639320492744446, "span_start": null, "span_end": null, "passage": "\"\"\"\nThis file is used to test pyright's ability to check pydantic code"}, {"qid": "", "rank": 19, "path": "pydantic/v1/dataclasses.py", "score": 0.27484142780303955, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 20, "path": "tests/test_networks.py", "score": 0.2702578902244568, "span_start": null, "span_end": null, "passage": "Otherwise it will be set to default\n    # https://www.iana.org/assignments/uri-schemes/prov/redis\n    m = Model(a='rediss://')\n    assert m.a.scheme == 'rediss'\n    assert m.a.host == 'localhost'\n    ..."}], "latency_ms": 3.772735595703125, "gold_paths": ["pydantic/_migration.py", "pydantic/color.py", "pydantic/dataclasses.py"]}
