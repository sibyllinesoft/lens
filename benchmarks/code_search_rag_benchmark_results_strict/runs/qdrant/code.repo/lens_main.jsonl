{"qid": "lens_main_repo_1", "query": "error handling that logs and returns status", "results": [{"qid": "", "rank": 1, "path": "pydantic/plugin/__init__.py", "score": 0.3988197445869446, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return\n\n    def on_exception(self, exception: Exception) -> None:\n        \"\"\"Callback to be notified of validation exceptions Args:\n            exception: The exception raised during valid..."}, {"qid": "", "rank": 2, "path": "tests/plugin/example_plugin.py", "score": 0.3787512183189392, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nm = MyModel(x='10')\nif m.x != 10:\n    raise ValueError('m.x should be 10')\n\nlog = []\n\n\nclass ValidatePythonHandler:\n    def on_e..."}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.3567137122154236, "span_start": null, "span_end": null, "passage": "\"\"\"\n    custom_error_type: str | None = None\n    \"\"\"Type to use in [custom errors](../errors/errors.md#custom-errors) replacing the standard discriminated union\n    validation errors"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.34325456619262695, "span_start": null, "span_end": null, "passage": "(The list[list[str]] here\n            #   is the appropriate way to provide a list of fallback attributes to check for a discriminator value.)\n            discriminator: str | list[list[str | int]] = ..."}, {"qid": "", "rank": 5, "path": "pydantic/type_adapter.py", "score": 0.34045523405075073, "span_start": null, "span_end": null, "passage": "warnings: How to handle serialization errors False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationErro..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_model_construction.py", "score": 0.3257482051849365, "span_start": null, "span_end": null, "passage": "Returns:\n        `True` if the model is successfully completed, else `False` Raises:\n        PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n     ..."}, {"qid": "", "rank": 7, "path": "pydantic/config.py", "score": 0.32344239950180054, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, ConfigDict, Field, ValidationError\n\n    class Model(BaseModel):\n        model_config = ConfigDict(regex_engine='python-re')\n\n        value: str = Field(patter..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3192363381385803, "span_start": null, "span_end": null, "passage": "`model_name` is accepted for the purpose of producing useful error messages"}, {"qid": "", "rank": 9, "path": "pydantic/v1/validators.py", "score": 0.31377673149108887, "span_start": null, "span_end": null, "passage": "use a different JSON library like ujson\n    if isinstance(v, (str, bytes, bytearray)) and len(v) > max_str_int:\n        raise errors.IntegerError()\n\n    try:\n        return int(v)\n    except (TypeErro..."}, {"qid": "", "rank": 10, "path": "tests/test_main.py", "score": 0.3112615942955017, "span_start": null, "span_end": null, "passage": "with warnings.catch_warnings(record=True) as captured_warnings:\n        # Start capturing all warnings\n        warnings.simplefilter('always')\n\n        class ChildWithoutRedefinedField(BaseModel, Pare..."}, {"qid": "", "rank": 11, "path": "pydantic/types.py", "score": 0.3104543685913086, "span_start": null, "span_end": null, "passage": "\"\"\"\n    custom_error_message: str | None = None\n    \"\"\"Message to use in custom errors.\"\"\"\n    custom_error_context: dict[str, int | str | float] | None = None\n    \"\"\"Context to use in custom errors.\"..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.30860593914985657, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.30860593914985657, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.30479317903518677, "span_start": null, "span_end": null, "passage": "Also provides a way to label a union case in error messages When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\n    should be used to identify tha..."}, {"qid": "", "rank": 15, "path": "pydantic/mypy.py", "score": 0.30336666107177734, "span_start": null, "span_end": null, "passage": "\"\"\"\n    api.fail('Required dynamic aliases disallowed', context, code=ERROR_ALIAS)\n\n\ndef error_unexpected_behavior(\n    detail: str, api: CheckerPluginInterface | SemanticAnalyzerPluginInterface, cont..."}, {"qid": "", "rank": 16, "path": "pydantic/plugin/__init__.py", "score": 0.2901116609573364, "span_start": null, "span_end": null, "passage": "Returns:\n            A tuple of optional event handlers for each of the three validation methods -\n                `validate_python`, `validate_json`, `validate_strings` \"\"\"\n        raise NotImplement..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.28947123885154724, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_val_or_ser', '_attempt_rebuild'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        val_..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/fields.py", "score": 0.2890539765357971, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        try:\n            iterable = iter(v)\n        except TypeError:\n            return v, ErrorWrapper(errors_.IterableError(), loc)\n        return iterable, None\n\n    def _validate_tuple(\n    ..."}, {"qid": "", "rank": 19, "path": "pydantic/networks.py", "score": 0.28768298029899597, "span_start": null, "span_end": null, "passage": "print(m.url)\n#> http://www.example.com/\n\ntry:\n    MyModel(url='ftp://invalid.url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      URL scheme should ..."}, {"qid": "", "rank": 20, "path": "pydantic/plugin/__init__.py", "score": 0.286652147769928, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    on_enter: Callable[..., None]\n    \"\"\"`on_enter` is changed to be more specific on all subclasses\"\"\"\n\n    def on_success(self, result: Any) -> None:\n        \"\"\"Callback to be notified of succe..."}], "latency_ms": 4.672765731811523, "gold_paths": ["pydantic/__init__.py", "pydantic/annotated_handlers.py"]}
{"qid": "lens_main_repo_3", "query": "API rate limiting implementation", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.35851120948791504, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 2, "path": "docs/plugins/using_update.py", "score": 0.30173662304878235, "span_start": null, "span_end": null, "passage": "from pathlib import Path\nfrom time import sleep\n\nimport requests\nimport tomli\n\nTHIS_DIR = Path(__file__).parent\n\nsession = requests.Session()\n\n\ndef update_lib(lib, *, retry=0):\n    repo = lib['repo']\n..."}, {"qid": "", "rank": 3, "path": "docs/plugins/conversion_table.py", "score": 0.29091131687164307, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/).',\n        valid_examples=[b'10:10:10.0002'],\n        invalid_examples=[b'1:1:1'],\n        core_schemas=[core_schema.TimeSchema],\n    ),\n    R..."}, {"qid": "", "rank": 4, "path": "pydantic/fields.py", "score": 0.28049901127815247, "span_start": null, "span_end": null, "passage": "decimal_places: Maximum number of decimal places allowed for numbers union_mode: The strategy to apply when validating a union Can be `smart` (the default), or `left_to_right` See [Union Mode](../conc..."}, {"qid": "", "rank": 5, "path": "docs/plugins/conversion_table.py", "score": 0.27831485867500305, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/), (UTF-8).',\n        valid_examples=[b'1 days 10:10', b'1 d 10:10'],\n        invalid_examples=[b'1 10:10'],\n        core_schemas=[core_schema.T..."}, {"qid": "", "rank": 6, "path": "pydantic/experimental/pipeline.py", "score": 0.26454758644104004, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}, {"qid": "", "rank": 7, "path": "docs/plugins/conversion_table.py", "score": 0.26386046409606934, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/), (UTF-8).'\n        ),\n        valid_examples=[b'2017-05-05 10:10:10', b'2017-05-05T10:10:10.0002', b'2017-05-05 10:10:10+00:00'],\n        inva..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.2618786096572876, "span_start": null, "span_end": null, "passage": "Used internally by Pydantic, please do not rely on this implementation See `GetCoreSchemaHandler` for the handler API"}, {"qid": "", "rank": 9, "path": "docs/plugins/conversion_table.py", "score": 0.2606391906738281, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/).',\n        valid_examples=['1 days 10:10', '1 d 10:10'],\n        invalid_examples=['1 10:10'],\n        core_schemas=[core_schema.TimedeltaSche..."}, {"qid": "", "rank": 10, "path": "pydantic/experimental/pipeline.py", "score": 0.26023274660110474, "span_start": null, "span_end": null, "passage": "@overload\n    def constrain(\n        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n    ) -> _Pipeline[_InT, _NewOutInterval]: .. @overload\n    def constrain(self: _Pipel..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generics.py", "score": 0.2598963975906372, "span_start": null, "span_end": null, "passage": "KT = TypeVar('KT')\nVT = TypeVar('VT')\n_LIMITED_DICT_SIZE = 100\nif TYPE_CHECKING:\n\n    class LimitedDict(dict, MutableMapping[KT, VT]):\n        def __init__(self, size_limit: int = _LIMITED_DICT_SIZE):..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.25866708159446716, "span_start": null, "span_end": null, "passage": "from __future__ import annotations\n\nfrom collections import defaultdict\nfrom copy import copy\nfrom functools import partial\nfrom typing import TYPE_CHECKING, Any, Callable, Iterable\n\nfrom pydantic_cor..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.2563807964324951, "span_start": null, "span_end": null, "passage": "This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not You might want to enable this setting if you want to validate your data faster (basic..."}, {"qid": "", "rank": 14, "path": "docs/plugins/conversion_table.py", "score": 0.2529931664466858, "span_start": null, "span_end": null, "passage": "'\n            'See [speedate](https://docs.rs/speedate/latest/speedate/) Must be exact date.'\n        ),\n        valid_examples=[1493942400000, 1493942400],\n        invalid_examples=[1493942401000],\n ..."}, {"qid": "", "rank": 15, "path": "docs/plugins/conversion_table.py", "score": 0.24852736294269562, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/).',\n        valid_examples=['10:10:10.0002'],\n        invalid_examples=['1:1:1'],\n        core_schemas=[core_schema.TimeSchema],\n    ),\n    Row..."}, {"qid": "", "rank": 16, "path": "pydantic/experimental/pipeline.py", "score": 0.24223551154136658, "span_start": null, "span_end": null, "passage": "@overload\n    def constrain(\n        self: _Pipeline[_InT, _NewOutT], constraint: annotated_types.MultipleOf\n    ) -> _Pipeline[_InT, _NewOutT]: .. @overload\n    def constrain(\n        self: _Pipeline..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.2357998937368393, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if kind in self.ignored_warning_kinds:\n            return None\n        return f'{detail} [{kind}]'\n\n    def _build_definitions_remapping(self) -> _DefinitionsRemapping:\n        defs_to_jso..."}, {"qid": "", "rank": 18, "path": "pydantic/networks.py", "score": 0.23233094811439514, "span_start": null, "span_end": null, "passage": "Attributes:\n        max_length: The maximum length of the url Defaults to `None` allowed_schemes: The allowed schemes Defaults to `None` host_required: Whether the host is required Defaults to `None` ..."}, {"qid": "", "rank": 19, "path": "pydantic/experimental/pipeline.py", "score": 0.23060178756713867, "span_start": null, "span_end": null, "passage": "@overload\n    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]: .. @overload\n    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _P..."}, {"qid": "", "rank": 20, "path": "pydantic/config.py", "score": 0.22866609692573547, "span_start": null, "span_end": null, "passage": "- `'iso8601'` will serialize timedeltas to ISO 8601 durations - `'float'` will serialize timedeltas to the total number of seconds \"\"\"\n\n    ser_json_bytes: Literal['utf8', 'base64']\n    \"\"\"\n    The en..."}], "latency_ms": 4.025459289550781, "gold_paths": ["pydantic/config.py", "pydantic/fields.py"]}
{"qid": "lens_main_repo_4", "query": "user session management", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.2826787829399109, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.19546550512313843, "span_start": null, "span_end": null, "passage": "```py\n    from typing import List\n\n    from pydantic import BaseModel\n\n    class User(BaseModel, revalidate_instances='never'):  # (1) hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[s..."}, {"qid": "", "rank": 3, "path": "tests/test_discriminated_union.py", "score": 0.19210928678512573, "span_start": null, "span_end": null, "passage": "I think this would be difficult to avoid in the general case, and I would suggest that we not\n            # attempt to do more than this until presented with scenarios where it is helpful/necessary"}, {"qid": "", "rank": 4, "path": "tests/test_discriminated_union.py", "score": 0.19210928678512573, "span_start": null, "span_end": null, "passage": "I think this would be difficult to avoid in the general case, and I would suggest that we not\n            # attempt to do more than this until presented with scenarios where it is helpful/necessary"}, {"qid": "", "rank": 5, "path": "tests/mypy/modules/strict_equality.py", "score": 0.18763913214206696, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 6, "path": "pydantic/config.py", "score": 0.1850142478942871, "span_start": null, "span_end": null, "passage": "print(t)\n    #> user=User(hobbies=[1])\n\n    my_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\n    t = Transaction(user=my_sub_user)\n    print(t)\n    #> user=SubUser(hobbies=['scuba divin..."}, {"qid": "", "rank": 7, "path": "tests/test_dataclasses.py", "score": 0.18295975029468536, "span_start": null, "span_end": null, "passage": "while working on one specific test"}, {"qid": "", "rank": 8, "path": "pydantic/v1/env_settings.py", "score": 0.17462709546089172, "span_start": null, "span_end": null, "passage": "This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),\n    Heroku and any 12 factor app design"}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.1719372570514679, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.1660606414079666, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 11, "path": "tests/test_rich_repr.py", "score": 0.16123545169830322, "span_start": null, "span_end": null, "passage": "from datetime import datetime\nfrom typing import List, Optional\n\nimport pytest\n\nfrom pydantic import BaseModel\nfrom pydantic.color import Color\n\n\n@pytest.fixture(scope='session', name='User')\ndef user..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_utils.py", "score": 0.15620388090610504, "span_start": null, "span_end": null, "passage": "\"\"\"Bucket of reusable internal utilities This should be reduced as much as possible with functions only used in one place, moved to that place"}, {"qid": "", "rank": 13, "path": "pydantic/config.py", "score": 0.1554083377122879, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.15424621105194092, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, SecretStr\n\n    class User(BaseModel):\n        username: str\n        password: SecretStr\n\n    user = User(username='scolvin', password='password1')\n\n    print(..."}, {"qid": "", "rank": 15, "path": "pydantic/config.py", "score": 0.14931775629520416, "span_start": null, "span_end": null, "passage": "The model is revalidated, since `revalidate_instances` is set to `'always'` 3 Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])` It's also possible to set `r..."}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.14592018723487854, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, SecretBytes\n\n    class User(BaseModel):\n        username: str\n        password: SecretBytes\n\n    user = User(username='scolvin', password=b'password1')\n    #>..."}, {"qid": "", "rank": 17, "path": "pydantic/config.py", "score": 0.1456339955329895, "span_start": null, "span_end": null, "passage": "Enabling this setting should significantly improve validation performance while increasing memory usage slightly - `True` or `'all'` (the default): cache all strings\n    - `'keys'`: cache only diction..."}, {"qid": "", "rank": 18, "path": "pydantic/config.py", "score": 0.14165471494197845, "span_start": null, "span_end": null, "passage": "#> user=User(hobbies=['scuba diving'])\n    ```\n\n    1 `revalidate_instances` is set to `'subclass-instances'` 2 This is not revalidated, since `my_user` is not a subclass of `User` 3 Using `'never'` w..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/dataclasses.py", "score": 0.13969825208187103, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.13569149374961853, "span_start": null, "span_end": null, "passage": "This should be performed in a later phase"}], "latency_ms": 4.131317138671875, "gold_paths": ["pydantic/type_adapter.py", "tests/test_config.py"]}
{"qid": "lens_main_repo_5", "query": "configuration loading from environment", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/env_settings.py", "score": 0.3907615542411804, "span_start": null, "span_end": null, "passage": "'\n                        'Instead use the \"env\" field setting"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_config.py", "score": 0.3729211091995239, "span_start": null, "span_end": null, "passage": "old class-based config) or None Args:\n        config: The input config Returns:\n        A ConfigDict object created from config"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_config.py", "score": 0.36608004570007324, "span_start": null, "span_end": null, "passage": "Args:\n        config_dict: The input config"}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.3618531823158264, "span_start": null, "span_end": null, "passage": "It reads configs from toml file and returns `None` if the file is not a toml file"}, {"qid": "", "rank": 5, "path": "tests/mypy/modules/pydantic_settings.py", "score": 0.3549157679080963, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 6, "path": "pydantic/env_settings.py", "score": 0.3522818982601166, "span_start": null, "span_end": null, "passage": "\"\"\"The `env_settings` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 7, "path": "pydantic/mypy.py", "score": 0.3406488299369812, "span_start": null, "span_end": null, "passage": "It includes the config if config value is not `None`"}, {"qid": "", "rank": 8, "path": "tests/test_validators.py", "score": 0.3347468078136444, "span_start": null, "span_end": null, "passage": "Expects ConfigError to be raised"}, {"qid": "", "rank": 9, "path": "tests/test_validators.py", "score": 0.3347468078136444, "span_start": null, "span_end": null, "passage": "Expects ConfigError to be raised"}, {"qid": "", "rank": 10, "path": "tests/test_config.py", "score": 0.3288702666759491, "span_start": null, "span_end": null, "passage": "Use the `pydantic.ConfigDict` instead',\n            'Support for class-based `config` is deprecated, use ConfigDict instead',\n            'BaseConfig is deprecated"}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.31407320499420166, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = (\n        'init_forbid_extra',\n        'init_typed',\n        'warn_required_dynamic_aliases',\n        'debug_dataclass_transform',\n    )\n    init_forbid_extra: bool\n    init_typed..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/fields.py", "score": 0.30636972188949585, "span_start": null, "span_end": null, "passage": "env variables should be parsed as JSON"}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_config.py", "score": 0.3035610318183899, "span_start": null, "span_end": null, "passage": "Use `model_config` for model configuration.',\n                code='model-config-invalid-field-name',\n            )\n\n        if config_class_from_namespace and config_dict_from_namespace:\n            ..."}, {"qid": "", "rank": 14, "path": "pydantic/_migration.py", "score": 0.29778051376342773, "span_start": null, "span_end": null, "passage": "We are importing from `{new_location}` instead.'\n                'See the migration guide for more details: https://docs.pydantic.dev/latest/migration/'\n            )\n            return import_string(..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/env_settings.py", "score": 0.2973286509513855, "span_start": null, "span_end": null, "passage": "'\n                        'See https://pydantic-docs.helpmanual.io/usage/settings/#environment-variable-names',\n                        FutureWarning,\n                    )\n                env_names =..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/env_settings.py", "score": 0.29570868611335754, "span_start": null, "span_end": null, "passage": "\"\"\"\n        d: Dict[str, Any] = {}\n\n        if settings.__config__.case_sensitive:\n            env_vars: Mapping[str, Optional[str]] = os.environ\n        else:\n            env_vars = {k.lower(): v for..."}, {"qid": "", "rank": 17, "path": "tests/mypy/outputs/1.4.1/pyproject-plugin_toml/pydantic_settings.py", "score": 0.2931283116340637, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 18, "path": "tests/mypy/outputs/1.4.1/mypy-plugin_ini/pydantic_settings.py", "score": 0.2931283116340637, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/config.py", "score": 0.2866622805595398, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\ndef get_config(config: Union[ConfigDict, Type[object], None]) -> Type[BaseConfig]:\n    if config is None:\n        return BaseConfig\n\n    else:\n        config_dict = (\n            co..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_config.py", "score": 0.2864728271961212, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if config is None:\n        return ConfigDict()\n\n    if not isinstance(config, dict):\n        warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)\n        config = {k: getattr(config, k) for ..."}], "latency_ms": 3.60870361328125, "gold_paths": ["pydantic/dataclasses.py", "pydantic/fields.py"]}
{"qid": "lens_main_repo_6", "query": "request validation and sanitization", "results": [{"qid": "", "rank": 1, "path": "pydantic/deprecated/class_validators.py", "score": 0.4254993200302124, "span_start": null, "span_end": null, "passage": "allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n            the decorated function Defaults to False Returns:\n        Callable: A decorator that can be..."}, {"qid": "", "rank": 2, "path": "pydantic/plugin/__init__.py", "score": 0.4214402437210083, "span_start": null, "span_end": null, "passage": "strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators \"\"\"\n        pass"}, {"qid": "", "rank": 3, "path": "pydantic/functional_validators.py", "score": 0.41207993030548096, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 4, "path": "pydantic/functional_validators.py", "score": 0.4120798408985138, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 5, "path": "pydantic/functional_validators.py", "score": 0.4120798408985138, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 6, "path": "pydantic/functional_validators.py", "score": 0.4120798408985138, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 7, "path": "pydantic/v1/networks.py", "score": 0.40821993350982666, "span_start": null, "span_end": null, "passage": "\"\"\"\n        host, tld, host_type, rebuild = cls.validate_host(parts)\n\n        return cls(\n            None if rebuild else url,\n            scheme=parts['scheme'],\n            user=parts['user'],\n    ..."}, {"qid": "", "rank": 8, "path": "pydantic/config.py", "score": 0.40649914741516113, "span_start": null, "span_end": null, "passage": "Enabling this setting should significantly improve validation performance while increasing memory usage slightly - `True` or `'all'` (the default): cache all strings\n    - `'keys'`: cache only diction..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/networks.py", "score": 0.3994078040122986, "span_start": null, "span_end": null, "passage": "Split from `validate` so this method\n        can be altered in `MultiHostDsn`"}, {"qid": "", "rank": 10, "path": "pydantic/plugin/__init__.py", "score": 0.393935889005661, "span_start": null, "span_end": null, "passage": "Args:\n            input: The JSON data to be validated strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators self_in..."}, {"qid": "", "rank": 11, "path": "pydantic/types.py", "score": 0.3922474980354309, "span_start": null, "span_end": null, "passage": "This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not You might want to enable this setting if you want to validate your data faster (basic..."}, {"qid": "", "rank": 12, "path": "pydantic/plugin/__init__.py", "score": 0.3892519474029541, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\nStringInput: TypeAlias = 'dict[str, StringInput]'\n\n\nclass ValidateStringsHandlerProtocol(BaseValidateHandlerProtocol, Protocol):\n    \"\"\"Event handler for `SchemaValidator.validate_s..."}, {"qid": "", "rank": 13, "path": "pydantic/type_adapter.py", "score": 0.38794735074043274, "span_start": null, "span_end": null, "passage": "context: Additional context to pass to the validator Returns:\n            The default value wrapped in a `Some` if there is one or None if not"}, {"qid": "", "rank": 14, "path": "pydantic/plugin/__init__.py", "score": 0.38416799902915955, "span_start": null, "span_end": null, "passage": "Args:\n            input: The input to be validated strict: Whether to validate the object in strict mode from_attributes: Whether to validate objects as inputs by extracting attributes context: The co..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_decorators.py", "score": 0.38345587253570557, "span_start": null, "span_end": null, "passage": "This function should only be used to inspect signatures of validation and serialization functions The first argument (the value being serialized or validated) is counted as a required argument\n    eve..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/class_validators.py", "score": 0.3827378749847412, "span_start": null, "span_end": null, "passage": "def root_validator(\n    _func: Optional[AnyCallable] = None, *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False\n) -> Union['AnyClassMethod', Callable[[AnyCallable], 'AnyCla..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.38038069009780884, "span_start": null, "span_end": null, "passage": "This flag provides a way to indicate whether you want the JSON schema required\nfor validation inputs, or that will be matched by serialization outputs"}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.3801421523094177, "span_start": null, "span_end": null, "passage": "Attributes:\n        strict: Whether to validate the field in strict mode"}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_decorators.py", "score": 0.37972140312194824, "span_start": null, "span_end": null, "passage": "\"\"\"Logic related to validators applied to models etc"}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.37336811423301697, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        cls: type[_ModelType],\n        # this can be a dict, a model instance\n        # or anything else that gets passed to validate_python\n        ..."}], "latency_ms": 3.9191246032714844, "gold_paths": ["pydantic/fields.py", "tests/test_construction.py"]}
{"qid": "lens_main_repo_9", "query": "cache invalidation strategy", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.4805762469768524, "span_start": null, "span_end": null, "passage": "Enabling this setting should significantly improve validation performance while increasing memory usage slightly - `True` or `'all'` (the default): cache all strings\n    - `'keys'`: cache only diction..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generics.py", "score": 0.4514823257923126, "span_start": null, "span_end": null, "passage": "As a concrete example, this approach was necessary to make Model[List[T]][int] equal to Model[List[int]] The approach could be modified to not use two different cache keys at different points, but the..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generics.py", "score": 0.4425688683986664, "span_start": null, "span_end": null, "passage": "If we wanted to move to only using a single cache key per type, we would either need to always use the\n    slower/more computationally intensive logic associated with _late_cache_key, or would need to..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generics.py", "score": 0.4415009021759033, "span_start": null, "span_end": null, "passage": "If it turns out that a different set of inputs to\n    __class_getitem__ resulted in the same inputs to the generic type creation process, we can still\n    return the cached type, and update the cache ..."}, {"qid": "", "rank": 5, "path": "tests/test_edge_cases.py", "score": 0.40914642810821533, "span_start": null, "span_end": null, "passage": "functools.cached_property,\n    which caches the computed values in the instance's __dict__\n    \"\"\"\n\n    class Model(BaseModel):\n        attr: int\n\n        @functools.cached_property\n        def cached..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_generics.py", "score": 0.39185523986816406, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return _GENERIC_TYPES_CACHE.get(_early_cache_key(parent, typevar_values))\n\n\ndef get_cached_generic_type_late(\n    parent: type[BaseModel], typevar_values: Any, origin: type[BaseModel], args: t..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generics.py", "score": 0.3870345950126648, "span_start": null, "span_end": null, "passage": "#   Right now, to handle recursive generics, we some types must remain cached for brief periods without references #   By chaining the WeakValuesDict with a LimitedDict, we have a way to retain cachin..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generics.py", "score": 0.379331111907959, "span_start": null, "span_end": null, "passage": "Note that this is overly simplistic, and it's possible that two different cls/typevar_values\n    inputs would ultimately result in the same type being created in BaseModel.__class_getitem__ To handle ..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/generics.py", "score": 0.35695672035217285, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def _cache_key(_params: Any) -> CacheKey:\n            args = get_args(_params)\n            # python returns a list for Callables, which is not hashable\n            if len(args) == 2 and i..."}, {"qid": "", "rank": 10, "path": "tests/test_generics.py", "score": 0.35210120677948, "span_start": null, "span_end": null, "passage": "This is due to weird behavior with the WeakValueDictionary used for caching As part of the next batch of generics work, we should attempt to fix this if possible"}, {"qid": "", "rank": 11, "path": "pydantic/v1/generics.py", "score": 0.3330032527446747, "span_start": null, "span_end": null, "passage": "if sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[CacheKey, Type[BaseModel]]\n    AssignedParameters = WeakKeyDictionary[Type[B..."}, {"qid": "", "rank": 12, "path": "tests/test_generics.py", "score": 0.3251621723175049, "span_start": null, "span_end": null, "passage": "# Make sure we can handle that special case\n    Simple = MyGenericModel[Callable[[int], str]]\n    models = []  # keep references to models to get cache size\n    models.append(Simple)\n\n    assert len(_..."}, {"qid": "", "rank": 13, "path": "pydantic/fields.py", "score": 0.3178725838661194, "span_start": null, "span_end": null, "passage": "This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached"}, {"qid": "", "rank": 14, "path": "tests/test_generics.py", "score": 0.3157387375831604, "span_start": null, "span_end": null, "passage": "concrete = MyGeneric[Model]\n        _GENERIC_TYPES_CACHE.clear()\n        second_concrete = MyGeneric[Model]\n\n        class Model(BaseModel):  # same name, but type different, so it's not in cache\n    ..."}, {"qid": "", "rank": 15, "path": "tests/test_main.py", "score": 0.3150022029876709, "span_start": null, "span_end": null, "passage": "# This could change the hash, and more importantly hashing shouldn't raise a KeyError\n    # We don't assert here, because a hash collision is possible: the hash is not guaranteed to change\n    # Howev..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.2973042130470276, "span_start": null, "span_end": null, "passage": "\"\"\"\n    _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values)] = type_\n    if len(typevar_values) == 1:\n        _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values[0])] = type_\n    if..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/dataclasses.py", "score": 0.2971905469894409, "span_start": null, "span_end": null, "passage": "input_data = {\n            k: v\n            for k, v in self.__dict__.items()\n            if not (isinstance(v, FieldInfo) or _is_field_cached_property(self, k))\n        }\n    else:\n        input_data..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generics.py", "score": 0.29488861560821533, "span_start": null, "span_end": null, "passage": "KT = TypeVar('KT')\nVT = TypeVar('VT')\n_LIMITED_DICT_SIZE = 100\nif TYPE_CHECKING:\n\n    class LimitedDict(dict, MutableMapping[KT, VT]):\n        def __init__(self, size_limit: int = _LIMITED_DICT_SIZE):..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/generics.py", "score": 0.29420286417007446, "span_start": null, "span_end": null, "passage": "_generic_types_cache = GenericTypesCache()\n\n# _assigned_parameters is a Mapping from parametrized version of generic models to assigned types of parametrizations\n# as captured during construction of t..."}, {"qid": "", "rank": 20, "path": "pydantic/deprecated/class_validators.py", "score": 0.29169273376464844, "span_start": null, "span_end": null, "passage": "allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n            the decorated function Defaults to False Returns:\n        Callable: A decorator that can be..."}], "latency_ms": 3.4894943237304688, "gold_paths": ["pydantic/fields.py", "tests/test_private_attributes.py"]}
