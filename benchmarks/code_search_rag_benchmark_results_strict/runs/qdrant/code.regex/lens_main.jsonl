{"qid": "lens_main_regex_0", "query": "import requests", "results": [{"qid": "", "rank": 1, "path": "pydantic/types.py", "score": 0.39438432455062866, "span_start": null, "span_end": null, "passage": "`ImportString` expects a string and loads the Python object importable at that dotted path Attributes of modules may be separated from the module by `:` or `.`, e.g if `'math:cos'` was provided,\n     ..."}, {"qid": "", "rank": 2, "path": "docs/plugins/using_update.py", "score": 0.3699418008327484, "span_start": null, "span_end": null, "passage": "from pathlib import Path\nfrom time import sleep\n\nimport requests\nimport tomli\n\nTHIS_DIR = Path(__file__).parent\n\nsession = requests.Session()\n\n\ndef update_lib(lib, *, retry=0):\n    repo = lib['repo']\n..."}, {"qid": "", "rank": 3, "path": "pydantic/errors.py", "score": 0.3247668445110321, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version imp..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_repr.py", "score": 0.31941893696784973, "span_start": null, "span_end": null, "passage": "\"\"\"Tools to provide pretty/human-readable display of objects.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport types\nimport typing\nfrom typing import Any\n\nimport typing_extensions\n\nfrom"}, {"qid": "", "rank": 5, "path": "tests/conftest.py", "score": 0.31069862842559814, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if isinstance(source_code_or_function, FunctionType):\n            source_code = _extract_source_code_from_function(source_code_or_function)\n        else:\n            source_code = source_c..."}, {"qid": "", "rank": 6, "path": "pydantic/networks.py", "score": 0.30960288643836975, "span_start": null, "span_end": null, "passage": "a URL where the host or TLD includes non-ascii characters) will be encoded via\n[punycode](https://en.wikipedia.org/wiki/Punycode) (see\n[this article](https://www.xudongz.com/blog/2017/idn-phishing/) f..."}, {"qid": "", "rank": 7, "path": "pydantic/error_wrappers.py", "score": 0.3087478280067444, "span_start": null, "span_end": null, "passage": "\"\"\"The `error_wrappers` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 8, "path": "tests/mypy/outputs/1.0.1/pyproject-default_toml/success.py", "score": 0.30798500776290894, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport os\nfrom datetime import date, datetime, timedelta, timezone\nfrom pathlib import Path, PurePath\nfrom typing import Any, ClassVar, Dict, ForwardRef, Generic, List, Optional, Type, TypeVar\nfro..."}, {"qid": "", "rank": 9, "path": "tests/mypy/outputs/1.0.1/mypy-default_ini/success.py", "score": 0.30798500776290894, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport os\nfrom datetime import date, datetime, timedelta, timezone\nfrom pathlib import Path, PurePath\nfrom typing import Any, ClassVar, Dict, ForwardRef, Generic, List, Optional, Type, TypeVar\nfro..."}, {"qid": "", "rank": 10, "path": "tests/mypy/modules/success.py", "score": 0.30798500776290894, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport os\nfrom datetime import date, datetime, timedelta, timezone\nfrom pathlib import Path, PurePath\nfrom typing import Any, ClassVar, Dict, ForwardRef, Generic, List, Optional, Type, TypeVar\nfro..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.30696991086006165, "span_start": null, "span_end": null, "passage": "\"\"\"\n    import annotated_types as at\n\n    from"}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.3059091567993164, "span_start": null, "span_end": null, "passage": "import sys\nfrom configparser import ConfigParser\nfrom typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as TypingType, Union\n\nfrom mypy.errorcodes import ErrorCode\nfrom mypy.nodes im..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.30549728870391846, "span_start": null, "span_end": null, "passage": "**Good behavior:**\n        ```py\n        from math import cos\n\n        from pydantic import BaseModel, Field, ImportString, ValidationError\n\n\n        class ImportThings(BaseModel):\n            obj: Im..."}, {"qid": "", "rank": 14, "path": "pydantic/json.py", "score": 0.30176734924316406, "span_start": null, "span_end": null, "passage": "\"\"\"The `json` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 15, "path": "pydantic/utils.py", "score": 0.30012017488479614, "span_start": null, "span_end": null, "passage": "\"\"\"The `utils` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 16, "path": "tests/test_exports.py", "score": 0.30002641677856445, "span_start": null, "span_end": null, "passage": "import importlib\nimport importlib.util\nimport json\nimport platform\nimport sys\nfrom pathlib import Path\nfrom types import ModuleType\n\nimport pytest\n\nimport pydantic\n\n\n@pytest.mark.filterwarnings('ignor..."}, {"qid": "", "rank": 17, "path": "pydantic/networks.py", "score": 0.2991397976875305, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n* Supports multiple hosts\n\nIf further validation is required, these properties can be used by validators to enforce specific behaviour:\n\n```py\nf..."}, {"qid": "", "rank": 18, "path": "pydantic/tools.py", "score": 0.29864266514778137, "span_start": null, "span_end": null, "passage": "\"\"\"The `tools` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 19, "path": "pydantic/typing.py", "score": 0.29668813943862915, "span_start": null, "span_end": null, "passage": "\"\"\"`typing` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/plugin/_loader.py", "score": 0.29641014337539673, "span_start": null, "span_end": null, "passage": "from __future__ import annotations\n\nimport importlib.metadata as importlib_metadata\nimport os\nimport warnings\nfrom typing import TYPE_CHECKING, Final, Iterable\n\nif TYPE_CHECKING:\n    from"}], "latency_ms": 4.175901412963867, "gold_paths": ["release/make_history.py"]}
{"qid": "lens_main_regex_1", "query": "def __init__", "results": [{"qid": "", "rank": 1, "path": "pydantic/dataclasses.py", "score": 0.5585658550262451, "span_start": null, "span_end": null, "passage": "def _call_initvar(*args: Any, **kwargs: Any) -> NoReturn:\n        \"\"\"This function does nothing but raise an error that is as similar as possible to what you'd get\n        if you were to try calling `..."}, {"qid": "", "rank": 2, "path": "pydantic/dataclasses.py", "score": 0.5582419633865356, "span_start": null, "span_end": null, "passage": "Raises:\n        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`"}, {"qid": "", "rank": 3, "path": "pydantic/main.py", "score": 0.542203426361084, "span_start": null, "span_end": null, "passage": "```\n\n            However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n            of the config arguments, and will only receive any keyword arguments p..."}, {"qid": "", "rank": 4, "path": "pydantic/root_model.py", "score": 0.5345549583435059, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __pydantic_root_model__ = True\n    __pydantic_private__ = None\n    __pydantic_extra__ = None\n\n    root: RootModelRootType\n\n    def __init_subclass__(cls, **kwargs):\n        extra = cls.model_..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/mypy.py", "score": 0.511174201965332, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.511174201965332, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_dataclasses.py", "score": 0.5016341805458069, "span_start": null, "span_end": null, "passage": "def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -> None:\n        __tracebackhide__ = True\n        s = __dataclass_self__\n        s.__pydantic_validator__.validate_python..."}, {"qid": "", "rank": 8, "path": "pydantic/errors.py", "score": 0.4974667727947235, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, message: str) -> None:\n        super().__init__(message, code='import-error')\n\n\nclass PydanticSchemaGenerationError(PydanticUserError):\n    \"\"\"An error raised during failur..."}, {"qid": "", "rank": 9, "path": "pydantic/mypy.py", "score": 0.49564632773399353, "span_start": null, "span_end": null, "passage": "Attributes:\n        init_forbid_extra: Whether to add a `**kwargs` at the end of the generated `__init__` signature init_typed: Whether to annotate fields in the generated `__init__` warn_required_dyn..."}, {"qid": "", "rank": 10, "path": "pydantic/type_adapter.py", "score": 0.49174201488494873, "span_start": null, "span_end": null, "passage": "# This second overload is for unsupported special forms (such as Annotated, Union, etc.)\n    # Currently there is no way to type this correctly\n    # See https://github.com/python/typing/pull/1618\n   ..."}, {"qid": "", "rank": 11, "path": "pydantic/main.py", "score": 0.4887324571609497, "span_start": null, "span_end": null, "passage": "param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n        params_component = ', '.join(param_names)\n        return f'{cls.__name__}[{params_componen..."}, {"qid": "", "rank": 12, "path": "pydantic/main.py", "score": 0.48739922046661377, "span_start": null, "span_end": null, "passage": "def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n            \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n            provides a way ..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/env_settings.py", "score": 0.48430928587913513, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(\n        __pydantic_self__,\n        _env_file: Optional[DotenvType] = env_file_sentinel,\n        _env_file_encoding: Optional[str] = None,\n        _env_nested_delimiter: Optional..."}, {"qid": "", "rank": 14, "path": "tests/test_types.py", "score": 0.4793858528137207, "span_start": null, "span_end": null, "passage": "def __init__(self, t: int) -> None:\n            self.t = t\n\n        def __eq__(self, value: object) -> bool:\n            if isinstance(value, IntWrapper):\n                return self.t == value.t\n    ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/dataclasses.py", "score": 0.4777989685535431, "span_start": null, "span_end": null, "passage": "If no `__post_init__` has been set in the stdlib dataclass\n    it won't even exist (code is generated on the fly by `dataclasses`)\n    By default, we run validation after `__init__` or `__post_init__`..."}, {"qid": "", "rank": 16, "path": "pydantic/dataclasses.py", "score": 0.47651180624961853, "span_start": null, "span_end": null, "passage": "validate_on_init: A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses\n            are validated on init kw_only: Determines if `__init__` method parameters mus..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_validate_call.py", "score": 0.46733182668685913, "span_start": null, "span_end": null, "passage": "import _generate_schema, _typing_extra\nfrom ._config import ConfigWrapper\n\n\nclass ValidateCallWrapper:\n    \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optiona..."}, {"qid": "", "rank": 18, "path": "pydantic/main.py", "score": 0.46595892310142517, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return handler(core_schema)\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs: Any) -> None:\n        \"\"\"This is intended to behave just like `__init_subclass__`, but is ca..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.45980364084243774, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if getattr(self, '__pydantic_private__', None) is None:\n        pydantic_private = {}\n        for name, private_attr in self.__private_attributes__.items():\n            default = private_attr...."}, {"qid": "", "rank": 20, "path": "pydantic/errors.py", "score": 0.4573330283164978, "span_start": null, "span_end": null, "passage": "Attributes:\n        name: Name of the error message: Description of the error \"\"\"\n\n    def __init__(self, name: str, message: str) -> None:\n        self.name = name\n        super().__init__(message=me..."}], "latency_ms": 3.6575794219970703, "gold_paths": ["pydantic/aliases.py", "pydantic/color.py", "pydantic/config.py"]}
{"qid": "lens_main_regex_3", "query": "if __name__", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/mypy.py", "score": 0.5673869252204895, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        # Get a nice unique name instead"}, {"qid": "", "rank": 2, "path": "pydantic/v1/mypy.py", "score": 0.38756948709487915, "span_start": null, "span_end": null, "passage": "\"\"\"\n    fn = x.fullname\n    if callable(fn):  # pragma: no cover\n        return fn()\n    return fn\n\n\ndef get_name(x: Union[FuncBase, SymbolNode]) -> str:\n    \"\"\"\n    Used for compatibility with mypy 0..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/main.py", "score": 0.37044477462768555, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.33438122272491455, "span_start": null, "span_end": null, "passage": "if name is None or name == 'default':\n                    return arg.__class__ is not EllipsisExpr\n                if name == 'default_factory':\n                    return not (isinstance(arg, NameExp..."}, {"qid": "", "rank": 5, "path": "pydantic/networks.py", "score": 0.33068254590034485, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.33051252365112305, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/config.py", "score": 0.325734943151474, "span_start": null, "span_end": null, "passage": "if not compiled:\n    from typing_extensions import TypedDict\n\n    class ConfigDict(TypedDict, total=False):\n        title: Optional[str]\n        anystr_lower: bool\n        anystr_strip_whitespace: boo..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_decorators.py", "score": 0.324800968170166, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if ismethoddescriptor(f) or isdatadescriptor(f):\n        return f\n    else:\n        return property(f)"}, {"qid": "", "rank": 9, "path": "pydantic/v1/env_settings.py", "score": 0.3242802321910858, "span_start": null, "span_end": null, "passage": "\"\"\"\n    for f in dir_path.iterdir():\n        if f.name == file_name:\n            return f\n        elif not case_sensitive and f.name.lower() == file_name.lower():\n            return f\n    return None"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generate_schema.py", "score": 0.32330840826034546, "span_start": null, "span_end": null, "passage": "field_name: The name of the field from which to generate the title"}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.32210850715637207, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if _core_utils.is_core_schema_field(schema):\n            if schema['type'] == 'computed-field':\n                field_schema = schema['return_schema']\n            else:\n                fie..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/utils.py", "score": 0.32077381014823914, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        eval('__IPYTHON__')\n    except NameError:\n        return False\n    else:  # pragma: no cover\n        return True\n\n\ndef is_valid_identifier(identifier: str) -> bool:\n    \"\"\"\n    Ch..."}, {"qid": "", "rank": 13, "path": "pydantic/fields.py", "score": 0.32050269842147827, "span_start": null, "span_end": null, "passage": "\"\"\"\n            if item in {'__get__', '__set__', '__delete__'}:\n                if hasattr(self.default, item):\n                    return getattr(self.default, item)\n            raise AttributeError..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.3201771378517151, "span_start": null, "span_end": null, "passage": "Args:\n            name: The name to retrieve a title from Returns:\n            The title \"\"\"\n        return name.title().replace('_', ' ')\n\n    def field_title_should_be_set(self, schema: CoreSchemaOr..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/typing.py", "score": 0.3192116618156433, "span_start": null, "span_end": null, "passage": "Returns True if Type is used\n    without brackets Otherwise returns None"}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.3176451325416565, "span_start": null, "span_end": null, "passage": "for arg, name in zip(expr.args, expr.arg_names):\n                # If name is None, then this arg is the default because it is the only positional argument"}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.3134336769580841, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The schema to check Returns:\n            `True` if the field should have a title set, `False` otherwise"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_model_construction.py", "score": 0.31310659646987915, "span_start": null, "span_end": null, "passage": "{\"_\" + var_name!r} instead of {var_name!r}.'\n                )\n            private_attributes[var_name] = value\n            del namespace[var_name]\n        elif isinstance(value, FieldInfo) and not is..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/schema.py", "score": 0.3130203187465668, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/dataclasses.py", "score": 0.3129030466079712, "span_start": null, "span_end": null, "passage": "# for example if Extra.forbid is enabled, it would consider __pydantic_initialised__ an invalid extra property\n    if getattr(self, '__pydantic_initialised__'):\n        return\n    if getattr(self, '__..."}], "latency_ms": 3.7229061126708984, "gold_paths": ["release/make_history.py"]}
{"qid": "lens_main_regex_6", "query": "@property", "results": [{"qid": "", "rank": 1, "path": "pydantic/networks.py", "score": 0.41648486256599426, "span_start": null, "span_end": null, "passage": "The `NameEmail` has two properties: `name` and `email` In case the `name` is not provided, it's inferred from the email address"}, {"qid": "", "rank": 2, "path": "pydantic/fields.py", "score": 0.41075456142425537, "span_start": null, "span_end": null, "passage": "Although this is more concise, you will lose IntelliSense in your IDE,\n    and confuse static type checkers, thus explicit use of `@property` is recommended !! warning \"Mypy Warning\"\n        Even with..."}, {"qid": "", "rank": 3, "path": "pydantic/fields.py", "score": 0.3848697543144226, "span_start": null, "span_end": null, "passage": "@typing.overload\ndef computed_field(__func: PropertyT) -> PropertyT: .."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_model_construction.py", "score": 0.3409150242805481, "span_start": null, "span_end": null, "passage": "Attributes:\n        msg: The deprecation message to be emitted wrapped_property: The property instance if the deprecated field is a computed field, or `None` field_name: The name of the field being de..."}, {"qid": "", "rank": 5, "path": "pydantic/fields.py", "score": 0.2966989278793335, "span_start": null, "span_end": null, "passage": "If you don't include a return type Any is used, which does runtime introspection to handle arbitrary\n            objects Returns:\n        A proxy wrapper for the property"}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_decorators.py", "score": 0.28972262144088745, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 7, "path": "pydantic/mypy.py", "score": 0.2866057753562927, "span_start": null, "span_end": null, "passage": "# Also, it is tricky to avoid eager expansion of Self types here (e.g because\n            # we serialize attributes)"}, {"qid": "", "rank": 8, "path": "pydantic/fields.py", "score": 0.2847445607185364, "span_start": null, "span_end": null, "passage": "Attributes:\n        decorator_repr: A class variable representing the decorator string, '@computed_field' wrapped_property: The wrapped computed field property return_type: The type of the computed fi..."}, {"qid": "", "rank": 9, "path": "pydantic/fields.py", "score": 0.27324217557907104, "span_start": null, "span_end": null, "passage": "```py\n    from functools import cached_property\n\n    from pydantic import BaseModel, computed_field\n\n    class Model(BaseModel):\n        foo: int\n\n        @computed_field\n        @cached_property\n    ..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_decorators.py", "score": 0.273103803396225, "span_start": null, "span_end": null, "passage": "and (param.default is Parameter.empty or param == parameters[0])\n    )\n\n\ndef can_be_positional(param: Parameter) -> bool:\n    return param.kind in (Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_K..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_config.py", "score": 0.26944488286972046, "span_start": null, "span_end": null, "passage": "Pass `obj=None` if you do not want to attempt to infer the `title` We don't use getattr here since we don't want to populate with defaults Args:\n            obj: An object used to populate `title` if ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.26598548889160156, "span_start": null, "span_end": null, "passage": "This is the same approach used by the attrs and dataclasses plugins"}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.26598548889160156, "span_start": null, "span_end": null, "passage": "This is the same approach used by the attrs and dataclasses plugins"}, {"qid": "", "rank": 14, "path": "pydantic/fields.py", "score": 0.2659660577774048, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> in..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.26459264755249023, "span_start": null, "span_end": null, "passage": "Args:\n        annotations: An iterable of annotations Returns:\n        An iterable of expanded annotations"}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_model_construction.py", "score": 0.26440542936325073, "span_start": null, "span_end": null, "passage": "- If a field on base class was overridden by a non-annotated attribute"}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_decorators.py", "score": 0.25702860951423645, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if ismethoddescriptor(f) or isdatadescriptor(f):\n        return f\n    else:\n        return property(f)"}, {"qid": "", "rank": 18, "path": "tests/test_config.py", "score": 0.2547348737716675, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.25307798385620117, "span_start": null, "span_end": null, "passage": "Returns:\n            An instance of the field metadata"}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_decorators.py", "score": 0.25233832001686096, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    decorator_repr: ClassVar[str] = '@model_validator'\n    mode: Literal['wrap', 'before', 'after']\n\n\nDecoratorInfo: TypeAlias = \"\"\"Union[\n    ValidatorDecoratorInfo,\n    FieldValidatorDecoratorI..."}], "latency_ms": 4.65083122253418, "gold_paths": ["pydantic/annotated_handlers.py", "pydantic/fields.py", "pydantic/json_schema.py"]}
{"qid": "lens_main_regex_7", "query": "return None", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/typing.py", "score": 0.45384645462036133, "span_start": null, "span_end": null, "passage": "Returns True if Type is used\n    without brackets Otherwise returns None"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_decorators.py", "score": 0.3902748227119446, "span_start": null, "span_end": null, "passage": "return\n            candidate: type[Any] | None = None\n            for seq in non_empty:  # Find merge candidates among seq heads candidate = seq[0]\n                not_head = [s for s in non_empty if ..."}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.36863359808921814, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators.py", "score": 0.3666386604309082, "span_start": null, "span_end": null, "passage": "candidate = None\n                else:\n                    break\n            if not candidate:\n                raise TypeError('Inconsistent hierarchy, no C3 MRO is possible')\n            yield candid..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_decorators.py", "score": 0.3527944087982178, "span_start": null, "span_end": null, "passage": "It gets the return type from the type annotation if `explicit_return_type` is `None` Otherwise, it returns `explicit_return_type` Args:\n        func: The function to get its return type explicit_retur..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3503972887992859, "span_start": null, "span_end": null, "passage": "This has the same semantics on the\n        # python side, but resolves the issue that `None` cannot correspond to any discriminator values"}, {"qid": "", "rank": 7, "path": "pydantic/mypy.py", "score": 0.34880876541137695, "span_start": null, "span_end": null, "passage": "It includes the config if config value is not `None`"}, {"qid": "", "rank": 8, "path": "pydantic/v1/typing.py", "score": 0.3479467034339905, "span_start": null, "span_end": null, "passage": "def is_none_type(type_: Any) -> bool:\n        return type_ in NONE_TYPES\n\nelif sys.version_info[:2] == (3, 8):\n\n    def is_none_type(type_: Any) -> bool:\n        for none_type in NONE_TYPES:\n         ..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/dataclasses.py", "score": 0.34513425827026367, "span_start": null, "span_end": null, "passage": "# for example if Extra.forbid is enabled, it would consider __pydantic_initialised__ an invalid extra property\n    if getattr(self, '__pydantic_initialised__'):\n        return\n    if getattr(self, '__..."}, {"qid": "", "rank": 10, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.3420793414115906, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 11, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.3420793414115906, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.34088313579559326, "span_start": null, "span_end": null, "passage": "return None\n\n        if not isinstance(node, Var):  # pragma: no cover\n            # Don't know if this edge case still happens with the `is_valid_field` check above\n            # but better safe than..."}, {"qid": "", "rank": 13, "path": "pydantic/main.py", "score": 0.3383004069328308, "span_start": null, "span_end": null, "passage": "exclude_unset: Whether to exclude fields that have not been explicitly set exclude_defaults: Whether to exclude fields that are set to their default value exclude_none: Whether to exclude fields that ..."}, {"qid": "", "rank": 14, "path": "pydantic/fields.py", "score": 0.3360457122325897, "span_start": null, "span_end": null, "passage": "If `self.default_factory` is `None`, the method will return a deep copy of the `self.default` object If `self.default_factory` is not `None`, it will call `self.default_factory` and return the value r..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.3347958028316498, "span_start": null, "span_end": null, "passage": "Defaults to `None` allow_inf_nan: Whether to allow infinity and NaN Defaults to `None`"}, {"qid": "", "rank": 16, "path": "tests/test_validators.py", "score": 0.3315310478210449, "span_start": null, "span_end": null, "passage": "This is why I've set the default to '' instead of None # But, I think this is a good thing, and I don't think we should try to support this"}, {"qid": "", "rank": 17, "path": "pydantic/warnings.py", "score": 0.33039331436157227, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    message: str\n    since: tuple[int, int]\n    expected_removal: tuple[int, int]\n\n    def __init__(\n        self, message: str, *args: object, since: tuple[int, int], expected_removal: tuple[int..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/fields.py", "score": 0.32880261540412903, "span_start": null, "span_end": null, "passage": "Union, Dict, List etc # allow None for virtual superclasses of NoneType, e.g"}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.32631897926330566, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if d is None:\n        return None\n    result = {}\n    for k, v in d.items():\n        try:\n            proxy = _PydanticWeakRef(v)\n        except TypeError:\n            proxy = v\n        result..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_forward_ref.py", "score": 0.32497918605804443, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __or__(self, other):\n        return Union[self, other]  # type: ignore\n\n    def __ror__(self, other):\n        return Union[other, self]  # type: ignore"}], "latency_ms": 4.837512969970703, "gold_paths": ["pydantic/color.py", "pydantic/dataclasses.py", "pydantic/fields.py"]}
{"qid": "lens_main_regex_8", "query": "raise ValueError", "results": [{"qid": "", "rank": 1, "path": "pydantic/dataclasses.py", "score": 0.6532255411148071, "span_start": null, "span_end": null, "passage": "Raises:\n        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`"}, {"qid": "", "rank": 2, "path": "tests/test_validators.py", "score": 0.6239168643951416, "span_start": null, "span_end": null, "passage": "Expects ConfigError to be raised"}, {"qid": "", "rank": 3, "path": "tests/test_validators.py", "score": 0.6239168643951416, "span_start": null, "span_end": null, "passage": "Expects ConfigError to be raised"}, {"qid": "", "rank": 4, "path": "pydantic/v1/datetime_parse.py", "score": 0.5977891683578491, "span_start": null, "span_end": null, "passage": "Raise ValueError if the input is well formatted but not a valid date Raise ValueError if the input isn't well formatted"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_decorators.py", "score": 0.5919562578201294, "span_start": null, "span_end": null, "passage": "Raises:\n        AttributeError: If the attribute is not found in any class in the MRO"}, {"qid": "", "rank": 6, "path": "pydantic/v1/datetime_parse.py", "score": 0.5727041363716125, "span_start": null, "span_end": null, "passage": "Raise ValueError if the input is well formatted but not a valid time Raise ValueError if the input isn't well formatted, in particular if it contains an offset"}, {"qid": "", "rank": 7, "path": "pydantic/v1/main.py", "score": 0.5541326999664307, "span_start": null, "span_end": null, "passage": "Raises ValidationError if the input data cannot be parsed to form a valid model"}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generics.py", "score": 0.5540776252746582, "span_start": null, "span_end": null, "passage": "Raises:\n        TypeError: If the passed parameters count is not equal to generic model parameters count"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_dataclasses.py", "score": 0.5386410355567932, "span_start": null, "span_end": null, "passage": "Raises:\n        PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations"}, {"qid": "", "rank": 10, "path": "pydantic/config.py", "score": 0.533723771572113, "span_start": null, "span_end": null, "passage": "except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Transaction\n        user.hobbies.0\n          Input should be a valid string [type=string_type, input_value=1, i..."}, {"qid": "", "rank": 11, "path": "pydantic/types.py", "score": 0.5179430246353149, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, PositiveFloat, ValidationError\n\nclass Model(BaseModel):\n    positive_float: PositiveFloat\n\nm = Model(positive_float=1.0)\nprint(repr(m))\n#> Model(positive_float=1...."}, {"qid": "", "rank": 12, "path": "pydantic/types.py", "score": 0.5140421390533447, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, NegativeFloat, ValidationError\n\nclass Model(BaseModel):\n    negative_float: NegativeFloat\n\nm = Model(negative_float=-1.0)\nprint(repr(m))\n#> Model(negative_float=-..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.49998462200164795, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, NonNegativeFloat, ValidationError\n\nclass Model(BaseModel):\n    non_negative_float: NonNegativeFloat\n\nm = Model(non_negative_float=0.0)\nprint(repr(m))\n#> Model(non..."}, {"qid": "", "rank": 14, "path": "tests/test_errors.py", "score": 0.4994787871837616, "span_start": null, "span_end": null, "passage": "import re\n\nimport pytest\n\nfrom pydantic import BaseModel, PydanticUserError, ValidationError\nfrom pydantic.version import version_short\n\n\ndef test_user_error_url():\n    with pytest.raises(PydanticUser..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.49150773882865906, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, NonPositiveFloat, ValidationError\n\nclass Model(BaseModel):\n    non_positive_float: NonPositiveFloat\n\nm = Model(non_positive_float=0.0)\nprint(repr(m))\n#> Model(non..."}, {"qid": "", "rank": 16, "path": "pydantic/main.py", "score": 0.4912188649177551, "span_start": null, "span_end": null, "passage": "# See `BaseModel.__repr_args__` for more details\n                try:\n                    pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n                except AttributeError:\n  ..."}, {"qid": "", "rank": 17, "path": "tests/test_deprecated.py", "score": 0.48902326822280884, "span_start": null, "span_end": null, "passage": "use `min_length` instead'\n    with pytest.warns(PydanticDeprecatedSince20, match=m):\n\n        class Model(BaseModel):\n            x: List[int] = Field(None, min_items=1)\n\n    with pytest.raises(Valida..."}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.4882258474826813, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, ValidationError, confloat\n\n    class ConstrainedExample(BaseModel):\n        constrained_float: confloat(gt=1.0)\n\n    m = ConstrainedExample(constrained_float=..."}, {"qid": "", "rank": 19, "path": "tests/test_dataclasses.py", "score": 0.4873766601085663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    @pydantic.dataclasses.dataclass\n    class Model:\n        x: Annotated[int, Field(gt=1)] = dataclasses.field(default=1)\n\n    assert Model().x == 1\n\n    with pytest.raises(ValidationError) as e..."}, {"qid": "", "rank": 20, "path": "pydantic/types.py", "score": 0.4857313632965088, "span_start": null, "span_end": null, "passage": "```py\n    from decimal import Decimal\n\n    from pydantic import BaseModel, ValidationError, condecimal\n\n    class ConstrainedExample(BaseModel):\n        constrained_decimal: condecimal(gt=Decimal('1.0..."}], "latency_ms": 4.5928955078125, "gold_paths": ["pydantic/color.py", "pydantic/functional_validators.py", "pydantic/json_schema.py"]}
