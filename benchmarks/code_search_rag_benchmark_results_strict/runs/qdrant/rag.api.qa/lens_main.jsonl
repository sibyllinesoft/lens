{"qid": "lens_main_rag_api_0", "query": "How do I authenticate API requests?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.37061649560928345, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 2, "path": "pydantic/networks.py", "score": 0.3275452256202698, "span_start": null, "span_end": null, "passage": "- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`) - `fragment`: optional fragment (`fragment=is;this=bit`) \"\"\"\nAnyHttpUrl = Annotated[Url, UrlConstr..."}, {"qid": "", "rank": 3, "path": "pydantic/networks.py", "score": 0.28784918785095215, "span_start": null, "span_end": null, "passage": "* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host required\n\nAssuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export t..."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.28635740280151367, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n\"\"\"\nClickHouseDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=['clickhouse+native', 'clickhouse+asynch'],\n        default_..."}, {"qid": "", "rank": 5, "path": "pydantic/experimental/pipeline.py", "score": 0.26901161670684814, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}, {"qid": "", "rank": 6, "path": "pydantic/v1/networks.py", "score": 0.26057350635528564, "span_start": null, "span_end": null, "passage": "\"\"\"\n        host, tld, host_type, rebuild = cls.validate_host(parts)\n\n        return cls(\n            None if rebuild else url,\n            scheme=parts['scheme'],\n            user=parts['user'],\n    ..."}, {"qid": "", "rank": 7, "path": "docs/plugins/griffe_doclinks.py", "score": 0.2522105276584625, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n'\n            f'    [`{api_link}`][{api_link}]<br>'\n            f'{content[heading_end:]}'\n        )\n\n    return f'!!"}, {"qid": "", "rank": 8, "path": "docs/plugins/using_update.py", "score": 0.2405530959367752, "span_start": null, "span_end": null, "passage": "from pathlib import Path\nfrom time import sleep\n\nimport requests\nimport tomli\n\nTHIS_DIR = Path(__file__).parent\n\nsession = requests.Session()\n\n\ndef update_lib(lib, *, retry=0):\n    repo = lib['repo']\n..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.2373960018157959, "span_start": null, "span_end": null, "passage": "- `'iso8601'` will serialize timedeltas to ISO 8601 durations - `'float'` will serialize timedeltas to the total number of seconds \"\"\"\n\n    ser_json_bytes: Literal['utf8', 'base64']\n    \"\"\"\n    The en..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.22969666123390198, "span_start": null, "span_end": null, "passage": "\"\"\"\nKafkaDsn = Annotated[Url, UrlConstraints(allowed_schemes=['kafka'], default_host='localhost', default_port=9092)]\n\"\"\"A type that will accept any Kafka DSN * User info required\n* TLD not required\n*..."}, {"qid": "", "rank": 11, "path": "tests/test_fastapi_json_schema.py", "score": 0.22628110647201538, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def handle_invalid_for_json_schema(self, schema: CoreSchemaOrField, error_info: str) -> JsonSchemaValue:\n        # NOTE: I think it may be a good idea to rework this method to either not use ..."}, {"qid": "", "rank": 12, "path": "pydantic/annotated_handlers.py", "score": 0.22504296898841858, "span_start": null, "span_end": null, "passage": "Attributes:\n        mode: Json schema mode, can be `validation` or `serialization` \"\"\"\n\n    mode: JsonSchemaMode\n\n    def __call__(self, core_schema: CoreSchemaOrField, /) -> JsonSchemaValue:\n        ..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.21760807931423187, "span_start": null, "span_end": null, "passage": "Note:\n    Under the hood, `Base64UrlStr` use standard library `base64.urlsafe_b64encode` and `base64.urlsafe_b64decode`\n    functions As a result, the `Base64UrlStr` type can be used to faithfully dec..."}, {"qid": "", "rank": 14, "path": "pydantic/networks.py", "score": 0.2166130244731903, "span_start": null, "span_end": null, "passage": "More: https://nats.io\n\"\"\"\nMySQLDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=[\n            'mysql',\n            'mysql+mysqlconnector',\n            'mysql+aiomysql',\n          ..."}, {"qid": "", "rank": 15, "path": "tests/test_networks.py", "score": 0.21400269865989685, "span_start": null, "span_end": null, "passage": "import json\nfrom typing import Union\n\nimport pytest\nfrom pydantic_core import PydanticCustomError, Url\nfrom typing_extensions import Annotated\n\nfrom pydantic import (\n    AmqpDsn,\n    AnyUrl,\n    Base..."}, {"qid": "", "rank": 16, "path": "pydantic/networks.py", "score": 0.2102717161178589, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n* Supports multiple hosts\n\nIf further validation is required, these properties can be used by validators to enforce specific behaviour:\n\n```py\nf..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.20785877108573914, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return base64.encodebytes(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64']:\n        \"\"\"Get the JSON format for the encoded data Returns:\n            The JSON form..."}, {"qid": "", "rank": 18, "path": ".github/actions/people/people.py", "score": 0.20670239627361298, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport requests\nimport logging\nimport subprocess\nimport sys\nfrom collections import Counter\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Any, Cont..."}, {"qid": "", "rank": 19, "path": "pydantic/networks.py", "score": 0.20524810254573822, "span_start": null, "span_end": null, "passage": "* TLD not required\n* Host required\n\"\"\"\nWebsocketUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['ws', 'wss'])]\n\"\"\"A type that will accept any ws or wss URL * TLD not required\n* H..."}, {"qid": "", "rank": 20, "path": "pydantic/plugin/__init__.py", "score": 0.20388707518577576, "span_start": null, "span_end": null, "passage": "Args:\n            input: The JSON data to be validated strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators self_in..."}], "latency_ms": 4.299402236938477, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_1", "query": "What are the rate limits for API calls?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3421129286289215, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 2, "path": "pydantic/networks.py", "score": 0.3161274194717407, "span_start": null, "span_end": null, "passage": "Attributes:\n        max_length: The maximum length of the url Defaults to `None` allowed_schemes: The allowed schemes Defaults to `None` host_required: Whether the host is required Defaults to `None` ..."}, {"qid": "", "rank": 3, "path": "pydantic/config.py", "score": 0.29078638553619385, "span_start": null, "span_end": null, "passage": "- `'iso8601'` will serialize timedeltas to ISO 8601 durations - `'float'` will serialize timedeltas to the total number of seconds \"\"\"\n\n    ser_json_bytes: Literal['utf8', 'base64']\n    \"\"\"\n    The en..."}, {"qid": "", "rank": 4, "path": "docs/plugins/using_update.py", "score": 0.2789875864982605, "span_start": null, "span_end": null, "passage": "from pathlib import Path\nfrom time import sleep\n\nimport requests\nimport tomli\n\nTHIS_DIR = Path(__file__).parent\n\nsession = requests.Session()\n\n\ndef update_lib(lib, *, retry=0):\n    repo = lib['repo']\n..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.26486867666244507, "span_start": null, "span_end": null, "passage": "\"\"\"Types and utility functions used by various other internal tools.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import core_schema\nfrom..."}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.26239824295043945, "span_start": null, "span_end": null, "passage": "Args:\n            core_ref: The core reference to get the definitions reference for Returns:\n            A tuple of the definitions reference and the JSON schema that will refer to it"}, {"qid": "", "rank": 7, "path": "tests/benchmarks/generate_north_star_data.py", "score": 0.26043829321861267, "span_start": null, "span_end": null, "passage": "from datetime import datetime\nfrom typing import Any, Callable, List, TypeVar, Union\n\nfrom faker import Faker\n\nf = Faker()\nFaker.seed(0)\n\n\nT = TypeVar('T')\n\n## Helper functions\n\n# by default faker use..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.24173977971076965, "span_start": null, "span_end": null, "passage": "(See bottom of https://swagger.io/docs/specification/using-ref/ for a reference about this behavior)\n        \"\"\"\n        if '$ref' in json_schema:\n            # prevent modifications to the input; thi..."}, {"qid": "", "rank": 9, "path": "docs/plugins/conversion_table.py", "score": 0.2414192259311676, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/).',\n        valid_examples=[b'10:10:10.0002'],\n        invalid_examples=[b'1:1:1'],\n        core_schemas=[core_schema.TimeSchema],\n    ),\n    R..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.24088606238365173, "span_start": null, "span_end": null, "passage": "Used internally by Pydantic, please do not rely on this implementation See `GetCoreSchemaHandler` for the handler API"}, {"qid": "", "rank": 11, "path": "pydantic/experimental/pipeline.py", "score": 0.236707866191864, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}, {"qid": "", "rank": 12, "path": "pydantic/types.py", "score": 0.23522476851940155, "span_start": null, "span_end": null, "passage": "min_length: The minimum length of the string max_length: The maximum length of the string pattern: A regex pattern to validate the string against Returns:\n        The wrapped string type"}, {"qid": "", "rank": 13, "path": "pydantic/fields.py", "score": 0.23112952709197998, "span_start": null, "span_end": null, "passage": "decimal_places: Maximum number of decimal places allowed for numbers union_mode: The strategy to apply when validating a union Can be `smart` (the default), or `left_to_right` See [Union Mode](../conc..."}, {"qid": "", "rank": 14, "path": "pydantic/annotated_handlers.py", "score": 0.23008882999420166, "span_start": null, "span_end": null, "passage": "Attributes:\n        mode: Json schema mode, can be `validation` or `serialization` \"\"\"\n\n    mode: JsonSchemaMode\n\n    def __call__(self, core_schema: CoreSchemaOrField, /) -> JsonSchemaValue:\n        ..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.22952143847942352, "span_start": null, "span_end": null, "passage": "# I believe this is true, but I am not 100% sure\n                min_items += 1\n\n        json_schema: JsonSchemaValue = {'type': 'array', 'prefixItems': prefix_items}\n        if min_items:\n           ..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/fields.py", "score": 0.22510655224323273, "span_start": null, "span_end": null, "passage": "This method should be idempotent, e.g it should be safe to call multiple times\n        without mis-configuring the field"}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.22224856913089752, "span_start": null, "span_end": null, "passage": "max_length: The maximum length of the bytes strict: Whether to validate the bytes in strict mode Returns:\n        The wrapped bytes type"}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.2213204801082611, "span_start": null, "span_end": null, "passage": "to reduce the number of nested calls.\"\"\"\n            if item == '__get_pydantic_core_schema__' and self.get_pydantic_core_schema:\n                return self.get_pydantic_core_schema\n            elif ..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.22050315141677856, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, generate_json_schema: GenerateJsonSchema, handler_override: HandlerOverride | None) -> None:\n        self.generate_json_schema = generate_json_schema\n        self.handler =..."}, {"qid": "", "rank": 20, "path": "pydantic/fields.py", "score": 0.2185472548007965, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    annotation: type[Any] | None\n    default: Any\n    default_factory: typing.Callable[[], Any] | None\n    alias: str | None\n    alias_priority: int | None\n    validation_alias: str | AliasPath |..."}], "latency_ms": 3.999948501586914, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_2", "query": "How do I handle API errors properly?", "results": [{"qid": "", "rank": 1, "path": "tests/test_fastapi_json_schema.py", "score": 0.46162837743759155, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def handle_invalid_for_json_schema(self, schema: CoreSchemaOrField, error_info: str) -> JsonSchemaValue:\n        # NOTE: I think it may be a good idea to rework this method to either not use ..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.4142361581325531, "span_start": null, "span_end": null, "passage": "\"\"\"\n    api.fail('Required dynamic aliases disallowed', context, code=ERROR_ALIAS)\n\n\ndef error_unexpected_behavior(\n    detail: str, api: CheckerPluginInterface | SemanticAnalyzerPluginInterface, cont..."}, {"qid": "", "rank": 3, "path": "pydantic/plugin/__init__.py", "score": 0.40875300765037537, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return\n\n    def on_exception(self, exception: Exception) -> None:\n        \"\"\"Callback to be notified of validation exceptions Args:\n            exception: The exception raised during valid..."}, {"qid": "", "rank": 4, "path": "tests/test_fastapi_json_schema.py", "score": 0.40389469265937805, "span_start": null, "span_end": null, "passage": "if CoreMetadataHandler(schema).metadata.get('pydantic_js_modify_function') is not None:\n            # Since there is a json schema modify function, assume that this type is meant to be handled,\n      ..."}, {"qid": "", "rank": 5, "path": "pydantic/main.py", "score": 0.3885369300842285, "span_start": null, "span_end": null, "passage": "exclude_unset: Whether to exclude fields that have not been explicitly set exclude_defaults: Whether to exclude fields that are set to their default value exclude_none: Whether to exclude fields that ..."}, {"qid": "", "rank": 6, "path": "pydantic/main.py", "score": 0.3866574168205261, "span_start": null, "span_end": null, "passage": "You can ignore this argument and call the handler with a new CoreSchema,\n                wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n                or just call the handl..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/networks.py", "score": 0.36487919092178345, "span_start": null, "span_end": null, "passage": "Could be overridden to set default values for parts if missing\n        \"\"\"\n        scheme = parts['scheme']\n        if scheme is None:\n            raise errors.UrlSchemeError()\n\n        if cls.allowed..."}, {"qid": "", "rank": 8, "path": "pydantic/type_adapter.py", "score": 0.36045923829078674, "span_start": null, "span_end": null, "passage": "warnings: How to handle serialization errors False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationErro..."}, {"qid": "", "rank": 9, "path": "pydantic/plugin/__init__.py", "score": 0.3570694327354431, "span_start": null, "span_end": null, "passage": "Returns:\n            A tuple of optional event handlers for each of the three validation methods -\n                `validate_python`, `validate_json`, `validate_strings` \"\"\"\n        raise NotImplement..."}, {"qid": "", "rank": 10, "path": "pydantic/types.py", "score": 0.3553563356399536, "span_start": null, "span_end": null, "passage": "\"\"\"\n    custom_error_type: str | None = None\n    \"\"\"Type to use in [custom errors](../errors/errors.md#custom-errors) replacing the standard discriminated union\n    validation errors"}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.35194551944732666, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema \"\"\"\n        return self.generate_inner(schema['arguments_schema'])\n\n    def custom_error_schema(self, schema: c..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.35157883167266846, "span_start": null, "span_end": null, "passage": "return None\n\n        if isinstance(node, TypeAlias):\n            self._api.fail(\n                'Type aliases inside BaseModel definitions are not supported at runtime',\n                node,\n       ..."}, {"qid": "", "rank": 13, "path": "tests/test_validators.py", "score": 0.3514407277107239, "span_start": null, "span_end": null, "passage": "Expects ConfigError to be raised"}, {"qid": "", "rank": 14, "path": "tests/test_validators.py", "score": 0.3514407277107239, "span_start": null, "span_end": null, "passage": "Expects ConfigError to be raised"}, {"qid": "", "rank": 15, "path": "pydantic/v1/validators.py", "score": 0.3483573794364929, "span_start": null, "span_end": null, "passage": "use a different JSON library like ujson\n    if isinstance(v, (str, bytes, bytearray)) and len(v) > max_str_int:\n        raise errors.IntegerError()\n\n    try:\n        return int(v)\n    except (TypeErro..."}, {"qid": "", "rank": 16, "path": "pydantic/type_adapter.py", "score": 0.34644877910614014, "span_start": null, "span_end": null, "passage": "Args:\n            instance: The instance to be serialized indent: Number of spaces for JSON indentation include: Fields to include exclude: Fields to exclude by_alias: Whether to use alias names for f..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.3453402817249298, "span_start": null, "span_end": null, "passage": "More than saving lines of code, this gives us a consistent error message for all of our internal implementations Args:\n        metadata: A dict of metadata allowed: An iterable of allowed metadata sou..."}, {"qid": "", "rank": 18, "path": "pydantic/networks.py", "score": 0.3430660367012024, "span_start": null, "span_end": null, "passage": "print(m.url)\n#> http://www.example.com/\n\ntry:\n    MyModel(url='ftp://invalid.url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      URL scheme should ..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3417781591415405, "span_start": null, "span_end": null, "passage": "(The list[list[str]] here\n            #   is the appropriate way to provide a list of fallback attributes to check for a discriminator value.)\n            discriminator: str | list[list[str | int]] = ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.33945417404174805, "span_start": null, "span_end": null, "passage": "`model_name` is accepted for the purpose of producing useful error messages"}], "latency_ms": 4.227638244628906, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_3", "query": "What response format does the API use?", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.45171794295310974, "span_start": null, "span_end": null, "passage": "- `'iso8601'` will serialize timedeltas to ISO 8601 durations - `'float'` will serialize timedeltas to the total number of seconds \"\"\"\n\n    ser_json_bytes: Literal['utf8', 'base64']\n    \"\"\"\n    The en..."}, {"qid": "", "rank": 2, "path": "pydantic/main.py", "score": 0.44586044549942017, "span_start": null, "span_end": null, "passage": "Returns:\n            A JSON string representation of the model"}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.44084805250167847, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        .. @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        \"\"\"Encode the data using the encoder Ar..."}, {"qid": "", "rank": 4, "path": "pydantic/types.py", "score": 0.43509140610694885, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return base64.encodebytes(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64']:\n        \"\"\"Get the JSON format for the encoded data Returns:\n            The JSON form..."}, {"qid": "", "rank": 5, "path": "docs/plugins/griffe_doclinks.py", "score": 0.4294280409812927, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n'\n            f'    [`{api_link}`][{api_link}]<br>'\n            f'{content[heading_end:]}'\n        )\n\n    return f'!!"}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.42416390776634216, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.41486281156539917, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return base64.urlsafe_b64encode(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64url']:\n        \"\"\"Get the JSON format for the encoded data Returns:\n            The ..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.4111977219581604, "span_start": null, "span_end": null, "passage": "Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 9, "path": "pydantic/json_schema.py", "score": 0.39283204078674316, "span_start": null, "span_end": null, "passage": "This is used to encode default values for fields in the generated JSON schema Args:\n            dft: The default value to encode Returns:\n            The encoded default value"}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.3858029544353485, "span_start": null, "span_end": null, "passage": "# At the end of schema generation, we use these to produce a JSON schema with more human-readable\n        # definitions, which would also work better in a generated OpenAPI client, etc"}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.3789270520210266, "span_start": null, "span_end": null, "passage": "Args:\n            core_ref: The core reference to get the definitions reference for Returns:\n            A tuple of the definitions reference and the JSON schema that will refer to it"}, {"qid": "", "rank": 12, "path": "pydantic/types.py", "score": 0.36642998456954956, "span_start": null, "span_end": null, "passage": "Note:\n    Under the hood, `Base64UrlStr` use standard library `base64.urlsafe_b64encode` and `base64.urlsafe_b64decode`\n    functions As a result, the `Base64UrlStr` type can be used to faithfully dec..."}, {"qid": "", "rank": 13, "path": "pydantic/type_adapter.py", "score": 0.36594972014427185, "span_start": null, "span_end": null, "passage": "(These schemas may have\n                    JsonRef references to definitions that are defined in the second returned element.)\n                - The second element is a JSON schema containing all def..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.36594972014427185, "span_start": null, "span_end": null, "passage": "(These schemas may have\n                JsonRef references to definitions that are defined in the second returned element.)\n            - The second element is a JSON schema containing all definitions..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.3659161925315857, "span_start": null, "span_end": null, "passage": "Note:\n    Under the hood, `Base64UrlBytes` use standard library `base64.urlsafe_b64encode` and `base64.urlsafe_b64decode`\n    functions As a result, the `Base64UrlBytes` type can be used to faithfully..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_decorators.py", "score": 0.3602604269981384, "span_start": null, "span_end": null, "passage": "mode: The proposed serializer mode return_type: The type of the serializer's return value when_used: The serialization condition Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n   ..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.35126399993896484, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        return self.encoder.decode(data)\n\n    def encode(self, value: bytes) -> bytes:\n        \"\"\"Encode the data u..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/main.py", "score": 0.34841373562812805, "span_start": null, "span_end": null, "passage": "`encoder` is an optional function to supply as `default` to json.dumps(), other arguments as per `json.dumps()`"}, {"qid": "", "rank": 19, "path": "pydantic/functional_serializers.py", "score": 0.3472980260848999, "span_start": null, "span_end": null, "passage": "return_type: The return type for the function If omitted it will be inferred from the type annotation when_used: Determines when this serializer should be used Accepts a string with values `'always'`,..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_serializers.py", "score": 0.3472980260848999, "span_start": null, "span_end": null, "passage": "return_type: The return type for the function If omitted it will be inferred from the type annotation when_used: Determines when this serializer should be used Accepts a string with values `'always'`,..."}], "latency_ms": 3.9603710174560547, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "docs/contributing.md"]}
{"qid": "lens_main_rag_api_4", "query": "How do I paginate through API results?", "results": [{"qid": "", "rank": 1, "path": "docs/extra/fluff.js", "score": 0.3186781108379364, "span_start": null, "span_end": null, "passage": "async function set_download_count(el) {\n  const r = await fetch('https://errors.pydantic.dev/download-count.txt');\n  if (r.status === 200) {\n    el.innerText = await r.text();\n  }\n}\n\nconst download_co..."}, {"qid": "", "rank": 2, "path": "docs/plugins/griffe_doclinks.py", "score": 0.3098038136959076, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n'\n            f'    [`{api_link}`][{api_link}]<br>'\n            f'{content[heading_end:]}'\n        )\n\n    return f'!!"}, {"qid": "", "rank": 3, "path": "pydantic/json_schema.py", "score": 0.30485737323760986, "span_start": null, "span_end": null, "passage": "Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 4, "path": ".github/actions/people/people.py", "score": 0.28267213702201843, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport requests\nimport logging\nimport subprocess\nimport sys\nfrom collections import Counter\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Any, Cont..."}, {"qid": "", "rank": 5, "path": "pydantic/networks.py", "score": 0.27682793140411377, "span_start": null, "span_end": null, "passage": "- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`) - `fragment`: optional fragment (`fragment=is;this=bit`) \"\"\"\nAnyHttpUrl = Annotated[Url, UrlConstr..."}, {"qid": "", "rank": 6, "path": "docs/plugins/griffe_doclinks.py", "score": 0.2719852924346924, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file})\\n'\n\n\ndef replace_links(m: re.Match, *, api_link: str) -> str:\n    path_group = m.group(1)\n    if '#' not in path_group:\n        # no head..."}, {"qid": "", "rank": 7, "path": "pydantic/main.py", "score": 0.2696908712387085, "span_start": null, "span_end": null, "passage": "Returns:\n            A JSON string representation of the model"}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generate_schema.py", "score": 0.24545466899871826, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 9, "path": "docs/plugins/using_update.py", "score": 0.2381601333618164, "span_start": null, "span_end": null, "passage": "from pathlib import Path\nfrom time import sleep\n\nimport requests\nimport tomli\n\nTHIS_DIR = Path(__file__).parent\n\nsession = requests.Session()\n\n\ndef update_lib(lib, *, retry=0):\n    repo = lib['repo']\n..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.23673121631145477, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 11, "path": "pydantic/types.py", "score": 0.22307002544403076, "span_start": null, "span_end": null, "passage": "However, you can use the argument `round_trip=True` to get the original JSON string back:\n\n        ```py\n        from typing import List\n\n        from pydantic import BaseModel, Json\n\n\n        class C..."}, {"qid": "", "rank": 12, "path": "tests/mypy/modules/generics.py", "score": 0.21993619203567505, "span_start": null, "span_end": null, "passage": "from typing import Any, Dict, Generic, Optional, TypeVar\n\nfrom pydantic import BaseModel\n\nTbody = TypeVar('Tbody')\n\n\nclass Response(BaseModel, Generic[Tbody]):\n    url: str\n    body: Tbody\n\n\nclass Jso..."}, {"qid": "", "rank": 13, "path": "tests/benchmarks/test_north_star.py", "score": 0.2197909951210022, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport json\nfrom datetime import date, datetime, time\nfrom decimal import Decimal\nfrom pathlib import Path\nfrom typing import List, Union\nfrom uuid import UUID\n\nimport pytest\nfrom typing_extensio..."}, {"qid": "", "rank": 14, "path": "docs/plugins/conversion_table.py", "score": 0.21499648690223694, "span_start": null, "span_end": null, "passage": "'\n            'See [speedate](https://docs.rs/speedate/latest/speedate/) Must be exact date.'\n        ),\n        valid_examples=[1493942400000, 1493942400],\n        invalid_examples=[1493942401000],\n ..."}, {"qid": "", "rank": 15, "path": "docs/plugins/griffe_doclinks.py", "score": 0.21036875247955322, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n' f'    [`{api_link}`][{api_link}]<br>\\n\\n' f'{content}')\n\n    heading = file_path.stem.replace('_', ' ').title()\n    return f'!!"}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.20919892191886902, "span_start": null, "span_end": null, "passage": "# I believe this is true, but I am not 100% sure\n                min_items += 1\n\n        json_schema: JsonSchemaValue = {'type': 'array', 'prefixItems': prefix_items}\n        if min_items:\n           ..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.2052009105682373, "span_start": null, "span_end": null, "passage": "Args:\n            json_schema: The schema to resolve Returns:\n            The resolved schema"}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.20215585827827454, "span_start": null, "span_end": null, "passage": "pprint(Model.model_json_schema())\n            '''\n            {\n                'properties': {\n                    'a': {\n                        'anyOf': [\n                            {'type': 'inte..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/main.py", "score": 0.19436682760715485, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if skip_defaults is not None:\n            warnings.warn(\n                f'{self.__class__.__name__}.dict(): \"skip_defaults\" is deprecated and replaced by \"exclude_unset\"',\n               ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_core_metadata.py", "score": 0.1939224898815155, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    pydantic_js_functions: list[GetJsonSchemaFunction]\n    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n\n    # If `pydantic_js_prefer_positional_arguments` is True, the JSON sche..."}], "latency_ms": 3.830432891845703, "gold_paths": ["docs/migration.md", "docs/api/standard_library_types.md"]}
{"qid": "lens_main_rag_api_5", "query": "What headers are required for API calls?", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.4216116964817047, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n'\n            f'    [`{api_link}`][{api_link}]<br>'\n            f'{content[heading_end:]}'\n        )\n\n    return f'!!"}, {"qid": "", "rank": 2, "path": "pydantic/json_schema.py", "score": 0.36960119009017944, "span_start": null, "span_end": null, "passage": "# At the end of schema generation, we use these to produce a JSON schema with more human-readable\n        # definitions, which would also work better in a generated OpenAPI client, etc"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3614753186702728, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.35921233892440796, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting\n    modifications to the definition schema Used internally by Pydantic, please do not rely on this implementation See `..."}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.35713133215904236, "span_start": null, "span_end": null, "passage": "Args:\n            core_ref: The core reference to get the definitions reference for Returns:\n            A tuple of the definitions reference and the JSON schema that will refer to it"}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_core_metadata.py", "score": 0.3506981432437897, "span_start": null, "span_end": null, "passage": "Attributes:\n        pydantic_js_functions: List of JSON schema functions pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n            prefer positional over keyword argument..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.3423394560813904, "span_start": null, "span_end": null, "passage": "\"\"\"Types and utility functions used by various other internal tools.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import core_schema\nfrom..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.3405582308769226, "span_start": null, "span_end": null, "passage": ":param models: a list of models to include in the generated JSON Schema\n    :param by_alias: generate the schemas using the aliases defined, if any\n    :param title: title for the generated schema tha..."}, {"qid": "", "rank": 9, "path": "pydantic/networks.py", "score": 0.33472487330436707, "span_start": null, "span_end": null, "passage": "* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host required\n\nAssuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export t..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.33430182933807373, "span_start": null, "span_end": null, "passage": "Attributes:\n        max_length: The maximum length of the url Defaults to `None` allowed_schemes: The allowed schemes Defaults to `None` host_required: Whether the host is required Defaults to `None` ..."}, {"qid": "", "rank": 11, "path": "pydantic/networks.py", "score": 0.33136487007141113, "span_start": null, "span_end": null, "passage": "- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`) - `fragment`: optional fragment (`fragment=is;this=bit`) \"\"\"\nAnyHttpUrl = Annotated[Url, UrlConstr..."}, {"qid": "", "rank": 12, "path": "pydantic/plugin/__init__.py", "score": 0.3225148022174835, "span_start": null, "span_end": null, "passage": "Args:\n            input: The JSON data to be validated strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators self_in..."}, {"qid": "", "rank": 13, "path": "pydantic/config.py", "score": 0.31841298937797546, "span_start": null, "span_end": null, "passage": "Defaults to `None` This provides a way to force the JSON schema generation to reflect a specific mode, e.g., to always use the\n    validation schema It can be useful when using frameworks (such as Fas..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_core_metadata.py", "score": 0.31769758462905884, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    pydantic_js_functions: list[GetJsonSchemaFunction]\n    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n\n    # If `pydantic_js_prefer_positional_arguments` is True, the JSON sche..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.31621354818344116, "span_start": null, "span_end": null, "passage": "Args:\n            arguments: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.31621354818344116, "span_start": null, "span_end": null, "passage": "Args:\n            arguments: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.31403130292892456, "span_start": null, "span_end": null, "passage": "This class is intended to eliminate the need to create a custom \"marker\" which defines the\n     `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` custom hook methods"}, {"qid": "", "rank": 18, "path": "pydantic/v1/schema.py", "score": 0.31183189153671265, "span_start": null, "span_end": null, "passage": "With all the sub-models defined in the ``definitions`` top-level\n    JSON key :param model: a Pydantic model (a class that inherits from BaseModel)\n    :param by_alias: generate the schemas using the ..."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.30862095952033997, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    annotation: type[Any] | None\n    default: Any\n    default_factory: typing.Callable[[], Any] | None\n    alias: str | None\n    alias_priority: int | None\n    validation_alias: str | AliasPath |..."}, {"qid": "", "rank": 20, "path": "pydantic/experimental/pipeline.py", "score": 0.30680596828460693, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}], "latency_ms": 4.124164581298828, "gold_paths": ["docs/contributing.md", "docs/migration.md", "docs/api/standard_library_types.md"]}
{"qid": "lens_main_rag_api_6", "query": "How do I upload files via the API?", "results": [{"qid": "", "rank": 1, "path": "pydantic/networks.py", "score": 0.33184200525283813, "span_start": null, "span_end": null, "passage": "* TLD not required\n* Host required\n\"\"\"\nWebsocketUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['ws', 'wss'])]\n\"\"\"A type that will accept any ws or wss URL * TLD not required\n* H..."}, {"qid": "", "rank": 2, "path": "docs/plugins/griffe_doclinks.py", "score": 0.33012479543685913, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n' f'    [`{api_link}`][{api_link}]<br>\\n\\n' f'{content}')\n\n    heading = file_path.stem.replace('_', ' ').title()\n    return f'!!"}, {"qid": "", "rank": 3, "path": "docs/plugins/griffe_doclinks.py", "score": 0.3045119047164917, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n'\n            f'    [`{api_link}`][{api_link}]<br>'\n            f'{content[heading_end:]}'\n        )\n\n    return f'!!"}, {"qid": "", "rank": 4, "path": "pydantic/experimental/pipeline.py", "score": 0.25427788496017456, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.24648623168468475, "span_start": null, "span_end": null, "passage": "\"\"\"\n        content_core_schema = schema.get('schema') or core_schema.any_schema()\n        content_json_schema = self.generate_inner(content_core_schema)\n        if self.mode == 'validation':\n        ..."}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.23880252242088318, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema = {'type': 'string', 'format': 'base64url' if self._config.ser_json_bytes == 'base64' else 'binary'}\n        self.update_with_validations(json_schema, schema, self.ValidationsM..."}, {"qid": "", "rank": 7, "path": "pydantic/config.py", "score": 0.23797889053821564, "span_start": null, "span_end": null, "passage": "- `'iso8601'` will serialize timedeltas to ISO 8601 durations - `'float'` will serialize timedeltas to the total number of seconds \"\"\"\n\n    ser_json_bytes: Literal['utf8', 'base64']\n    \"\"\"\n    The en..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generate_schema.py", "score": 0.23479199409484863, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 9, "path": "tests/test_fastapi_json_schema.py", "score": 0.2059324085712433, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def handle_invalid_for_json_schema(self, schema: CoreSchemaOrField, error_info: str) -> JsonSchemaValue:\n        # NOTE: I think it may be a good idea to rework this method to either not use ..."}, {"qid": "", "rank": 10, "path": "docs/plugins/griffe_doclinks.py", "score": 0.20286089181900024, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file})\\n'\n\n\ndef replace_links(m: re.Match, *, api_link: str) -> str:\n    path_group = m.group(1)\n    if '#' not in path_group:\n        # no head..."}, {"qid": "", "rank": 11, "path": "pydantic/types.py", "score": 0.2019343078136444, "span_start": null, "span_end": null, "passage": "Note:\n    Under the hood, `Base64Bytes` use standard library `base64.encodebytes` and `base64.decodebytes` functions As a result, attempting to decode url-safe base64 data using the `Base64Str` type m..."}, {"qid": "", "rank": 12, "path": "pydantic/json_schema.py", "score": 0.19631904363632202, "span_start": null, "span_end": null, "passage": "Args:\n            json_schema: The JSON schema to update core_schema: The core schema to get the validations from mapping: A mapping from core_schema attribute names to the corresponding JSON schema a..."}, {"qid": "", "rank": 13, "path": "pydantic/json_schema.py", "score": 0.1933799386024475, "span_start": null, "span_end": null, "passage": "\"\"\"\n        from .type_adapter import TypeAdapter, _type_has_config\n\n        config = self._config\n        try:\n            default = (\n                dft\n                if _type_has_config(type(dft..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.19282303750514984, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note: 'multi-host-uri' is a custom/pydantic-specific format, not part of the JSON Schema spec\n        json_schema = {'type': 'string', 'format': 'multi-host-uri', 'minLength': 1}\n       ..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.19195404648780823, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return base64.urlsafe_b64encode(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64url']:\n        \"\"\"Get the JSON format for the encoded data Returns:\n            The ..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.18963998556137085, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport contextlib\nimport datetime\nimport ipaddress\nimport json\nimport math\nfrom fractions import Fraction\nfrom typing import Callable, Dict, Type, Union, cast, overload\n\nimport hypothesis.strateg..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.18701784312725067, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 18, "path": "docs/plugins/using_update.py", "score": 0.18654008209705353, "span_start": null, "span_end": null, "passage": "from pathlib import Path\nfrom time import sleep\n\nimport requests\nimport tomli\n\nTHIS_DIR = Path(__file__).parent\n\nsession = requests.Session()\n\n\ndef update_lib(lib, *, retry=0):\n    repo = lib['repo']\n..."}, {"qid": "", "rank": 19, "path": "tests/mypy/outputs/1.0.1/pyproject-default_toml/success.py", "score": 0.18554942309856415, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport os\nfrom datetime import date, datetime, timedelta, timezone\nfrom pathlib import Path, PurePath\nfrom typing import Any, ClassVar, Dict, ForwardRef, Generic, List, Optional, Type, TypeVar\nfro..."}, {"qid": "", "rank": 20, "path": "tests/mypy/outputs/1.0.1/mypy-default_ini/success.py", "score": 0.18554942309856415, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport os\nfrom datetime import date, datetime, timedelta, timezone\nfrom pathlib import Path, PurePath\nfrom typing import Any, ClassVar, Dict, ForwardRef, Generic, List, Optional, Type, TypeVar\nfro..."}], "latency_ms": 4.0760040283203125, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_7", "query": "What is the API versioning strategy?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4576377272605896, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 2, "path": "pydantic/version.py", "score": 0.36886927485466003, "span_start": null, "span_end": null, "passage": "It parses normal version like `0.930` and extra info followed by a `+` sign\n    like `0.940+dev.04cac4b5d911c4f9529e6ce86a27b44f28846f5d.dirty` Args:\n        version: The mypy version string Returns:\n..."}, {"qid": "", "rank": 3, "path": "pydantic/json_schema.py", "score": 0.3520776331424713, "span_start": null, "span_end": null, "passage": "# At the end of schema generation, we use these to produce a JSON schema with more human-readable\n        # definitions, which would also work better in a generated OpenAPI client, etc"}, {"qid": "", "rank": 4, "path": "release/make_history.py", "score": 0.3481368124485016, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nimport argparse\nimport json\nimport re\nimport subprocess\nimport sys\nfrom datetime import date\nfrom pathlib import Path\n\nimport requests\n\n\ndef main():..."}, {"qid": "", "rank": 5, "path": "pydantic/warnings.py", "score": 0.3473101258277893, "span_start": null, "span_end": null, "passage": "It provides information on when the\n    deprecation was introduced and the expected version in which the corresponding functionality will be removed Attributes:\n        message: Description of the war..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/generics.py", "score": 0.3352838158607483, "span_start": null, "span_end": null, "passage": "if sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[CacheKey, Type[BaseModel]]\n    AssignedParameters = WeakKeyDictionary[Type[B..."}, {"qid": "", "rank": 7, "path": "pydantic/version.py", "score": 0.32760679721832275, "span_start": null, "span_end": null, "passage": "\"\"\"The `version` module holds the version information for Pydantic.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\n__all__ = 'VERSION', 'version_info'\n\nVERSION = '2.8.0'\n\"\"\"The version of Pyd..."}, {"qid": "", "rank": 8, "path": "pydantic/fields.py", "score": 0.3200756311416626, "span_start": null, "span_end": null, "passage": "field_title_generator: A callable that takes a field name and returns title for it description: Description of the computed field to include in the serialization JSON schema deprecated: A deprecation ..."}, {"qid": "", "rank": 9, "path": "tests/test_version.py", "score": 0.31693291664123535, "span_start": null, "span_end": null, "passage": "from unittest.mock import patch\n\nimport pytest\nfrom packaging.version import parse as parse_version\n\nimport pydantic\nfrom pydantic.version import version_info, version_short\n\n\ndef test_version_info():..."}, {"qid": "", "rank": 10, "path": "pydantic/experimental/pipeline.py", "score": 0.31578385829925537, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.3052672743797302, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.2981274724006653, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is\n    newer, or especially older, than we expect (or need) Args:\n        version: The mypy version string Return:\n        T..."}, {"qid": "", "rank": 13, "path": "pydantic/type_adapter.py", "score": 0.29616469144821167, "span_start": null, "span_end": null, "passage": "Args:\n            instance: The instance to be serialized indent: Number of spaces for JSON indentation include: Fields to include exclude: Fields to exclude by_alias: Whether to use alias names for f..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.2897835075855255, "span_start": null, "span_end": null, "passage": "Args:\n        schema: The JSON schema to update updates: A dictionary of key-value pairs to set in the schema Returns:\n        The updated JSON schema \"\"\"\n    schema.update(updates)\n    return schema\n..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.2860139012336731, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema = {'type': 'string', 'format': 'base64url' if self._config.ser_json_bytes == 'base64' else 'binary'}\n        self.update_with_validations(json_schema, schema, self.ValidationsM..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.2806120216846466, "span_start": null, "span_end": null, "passage": "if sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[GenericTypesCacheKey, 'type[BaseModel]']\nelse:\n    GenericTypesCache = WeakV..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/env_settings.py", "score": 0.2800747752189636, "span_start": null, "span_end": null, "passage": "This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),\n    Heroku and any 12 factor app design"}, {"qid": "", "rank": 18, "path": "docs/plugins/griffe_doclinks.py", "score": 0.27960872650146484, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file}#{slug})\\n'\n\n\ndef update_docstring(obj: GriffeObject) -> str:\n    return re.sub(\n        r'usage[\\- ]docs: ?https://docs\\.pydantic\\.dev/.+?..."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.2771506607532501, "span_start": null, "span_end": null, "passage": "discriminator: Field name or Discriminator for discriminating the type in a tagged union deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` b..."}, {"qid": "", "rank": 20, "path": "docs/plugins/using_update.py", "score": 0.276906818151474, "span_start": null, "span_end": null, "passage": "from pathlib import Path\nfrom time import sleep\n\nimport requests\nimport tomli\n\nTHIS_DIR = Path(__file__).parent\n\nsession = requests.Session()\n\n\ndef update_lib(lib, *, retry=0):\n    repo = lib['repo']\n..."}], "latency_ms": 5.696296691894531, "gold_paths": ["tests/test_fastapi_json_schema.py", "tests/benchmarks/test_fastapi_startup_generics.py", "tests/benchmarks/test_fastapi_startup_simple.py"]}
{"qid": "lens_main_rag_api_8", "query": "How do I filter API query results?", "results": [{"qid": "", "rank": 1, "path": "pydantic/networks.py", "score": 0.45834991335868835, "span_start": null, "span_end": null, "passage": "- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`) - `fragment`: optional fragment (`fragment=is;this=bit`) \"\"\"\nAnyHttpUrl = Annotated[Url, UrlConstr..."}, {"qid": "", "rank": 2, "path": "docs/plugins/griffe_doclinks.py", "score": 0.3469740152359009, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n'\n            f'    [`{api_link}`][{api_link}]<br>'\n            f'{content[heading_end:]}'\n        )\n\n    return f'!!"}, {"qid": "", "rank": 3, "path": "pydantic/json_schema.py", "score": 0.3258339464664459, "span_start": null, "span_end": null, "passage": "Args:\n            json_schema: The schema to resolve Returns:\n            The resolved schema"}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.3231324553489685, "span_start": null, "span_end": null, "passage": "Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 5, "path": ".github/actions/people/people.py", "score": 0.32280728220939636, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport requests\nimport logging\nimport subprocess\nimport sys\nfrom collections import Counter\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Any, Cont..."}, {"qid": "", "rank": 6, "path": "pydantic/experimental/pipeline.py", "score": 0.31150877475738525, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}, {"qid": "", "rank": 7, "path": "pydantic/main.py", "score": 0.2919436991214752, "span_start": null, "span_end": null, "passage": "Args:\n            indent: Indentation to use in the JSON output If None is passed, the output will be compact include: Field(s) to include in the JSON output exclude: Field(s) to exclude from the JSON..."}, {"qid": "", "rank": 8, "path": "pydantic/main.py", "score": 0.28889942169189453, "span_start": null, "span_end": null, "passage": "Returns:\n            A JSON string representation of the model"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generate_schema.py", "score": 0.2788136601448059, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 10, "path": "pydantic/type_adapter.py", "score": 0.2758644223213196, "span_start": null, "span_end": null, "passage": "Returns:\n            A tuple where:\n\n                - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n                    whose values are the JSON ..."}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.2758644223213196, "span_start": null, "span_end": null, "passage": "Returns:\n        A tuple where:\n            - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n                whose values are the JSON schema corres..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/main.py", "score": 0.2732959985733032, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if skip_defaults is not None:\n            warnings.warn(\n                f'{self.__class__.__name__}.dict(): \"skip_defaults\" is deprecated and replaced by \"exclude_unset\"',\n               ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.2707422971725464, "span_start": null, "span_end": null, "passage": "return None\n\n        if isinstance(node, TypeAlias):\n            self._api.fail(\n                'Type aliases inside BaseModel definitions are not supported at runtime',\n                node,\n       ..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/fields.py", "score": 0.2596031129360199, "span_start": null, "span_end": null, "passage": ":param alias: the public name of the field\n    :param title: can be any string, used in the schema\n    :param description: can be any string, used in the schema\n    :param exclude: exclude this field ..."}, {"qid": "", "rank": 15, "path": "docs/plugins/conversion_table.py", "score": 0.25658929347991943, "span_start": null, "span_end": null, "passage": "'\n            'See [speedate](https://docs.rs/speedate/latest/speedate/) Must be exact date.'\n        ),\n        valid_examples=[1493942400000, 1493942400],\n        invalid_examples=[1493942401000],\n ..."}, {"qid": "", "rank": 16, "path": "docs/plugins/conversion_table.py", "score": 0.2523297369480133, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/), (UTF-8).'\n        ),\n        valid_examples=[b'2017-05-05 10:10:10', b'2017-05-05T10:10:10.0002', b'2017-05-05 10:10:10+00:00'],\n        inva..."}, {"qid": "", "rank": 17, "path": "pydantic/networks.py", "score": 0.25166377425193787, "span_start": null, "span_end": null, "passage": "More: https://nats.io\n\"\"\"\nMySQLDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=[\n            'mysql',\n            'mysql+mysqlconnector',\n            'mysql+aiomysql',\n          ..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/env_settings.py", "score": 0.24984890222549438, "span_start": null, "span_end": null, "passage": "This is applied to a single field, hence filtering by env_var prefix"}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.24787890911102295, "span_start": null, "span_end": null, "passage": "\"\"\"\n        null_schema = {'type': 'null'}\n        inner_json_schema = self.generate_inner(schema['schema'])\n\n        if inner_json_schema == null_schema:\n            return null_schema\n        else:\n..."}, {"qid": "", "rank": 20, "path": "docs/plugins/griffe_doclinks.py", "score": 0.24714632332324982, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n' f'    [`{api_link}`][{api_link}]<br>\\n\\n' f'{content}')\n\n    heading = file_path.stem.replace('_', ' ').title()\n    return f'!!"}], "latency_ms": 4.2667388916015625, "gold_paths": ["docs/help_with_pydantic.md", "docs/index.md", "docs/migration.md"]}
{"qid": "lens_main_rag_api_9", "query": "What are the API timeout recommendations?", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.42397022247314453, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 2, "path": "docs/plugins/using_update.py", "score": 0.34894847869873047, "span_start": null, "span_end": null, "passage": "from pathlib import Path\nfrom time import sleep\n\nimport requests\nimport tomli\n\nTHIS_DIR = Path(__file__).parent\n\nsession = requests.Session()\n\n\ndef update_lib(lib, *, retry=0):\n    repo = lib['repo']\n..."}, {"qid": "", "rank": 3, "path": "pydantic/config.py", "score": 0.3096936345100403, "span_start": null, "span_end": null, "passage": "- `'iso8601'` will serialize timedeltas to ISO 8601 durations - `'float'` will serialize timedeltas to the total number of seconds \"\"\"\n\n    ser_json_bytes: Literal['utf8', 'base64']\n    \"\"\"\n    The en..."}, {"qid": "", "rank": 4, "path": "docs/plugins/conversion_table.py", "score": 0.30617260932922363, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/), (UTF-8).'\n        ),\n        valid_examples=[b'2017-05-05 10:10:10', b'2017-05-05T10:10:10.0002', b'2017-05-05 10:10:10+00:00'],\n        inva..."}, {"qid": "", "rank": 5, "path": "docs/plugins/conversion_table.py", "score": 0.2701151967048645, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/).',\n        valid_examples=[b'10:10:10.0002'],\n        invalid_examples=[b'1:1:1'],\n        core_schemas=[core_schema.TimeSchema],\n    ),\n    R..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/datetime_parse.py", "score": 0.2700424790382385, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if isinstance(value, datetime):\n        return value\n\n    number = get_numeric(value, 'datetime')\n    if number is not None:\n        return from_unix_seconds(number)\n\n    if isinstance(value, ..."}, {"qid": "", "rank": 7, "path": "pydantic/networks.py", "score": 0.2568727433681488, "span_start": null, "span_end": null, "passage": "Attributes:\n        max_length: The maximum length of the url Defaults to `None` allowed_schemes: The allowed schemes Defaults to `None` host_required: Whether the host is required Defaults to `None` ..."}, {"qid": "", "rank": 8, "path": "docs/plugins/conversion_table.py", "score": 0.2563191056251526, "span_start": null, "span_end": null, "passage": "'\n            'See [speedate](https://docs.rs/speedate/latest/speedate/) Must be exact date.'\n        ),\n        valid_examples=[1493942400000, 1493942400],\n        invalid_examples=[1493942401000],\n ..."}, {"qid": "", "rank": 9, "path": "docs/plugins/conversion_table.py", "score": 0.2559927999973297, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/), (UTF-8).',\n        valid_examples=[b'1 days 10:10', b'1 d 10:10'],\n        invalid_examples=[b'1 10:10'],\n        core_schemas=[core_schema.T..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/datetime_parse.py", "score": 0.24955633282661438, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if isinstance(value, timedelta):\n        return value\n\n    if isinstance(value, (int, float)):\n        # below code requires a string\n        value = f'{value:f}'\n    elif isinstance(value, by..."}, {"qid": "", "rank": 11, "path": "tests/benchmarks/generate_north_star_data.py", "score": 0.24370531737804413, "span_start": null, "span_end": null, "passage": "from datetime import datetime\nfrom typing import Any, Callable, List, TypeVar, Union\n\nfrom faker import Faker\n\nf = Faker()\nFaker.seed(0)\n\n\nT = TypeVar('T')\n\n## Helper functions\n\n# by default faker use..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/datetime_parse.py", "score": 0.24146077036857605, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if isinstance(value, time):\n        return value\n\n    number = get_numeric(value, 'time')\n    if number is not None:\n        if number >= 86400:\n            # doesn't make sense since the time..."}, {"qid": "", "rank": 13, "path": "docs/plugins/conversion_table.py", "score": 0.2394305169582367, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/).',\n        valid_examples=['1 days 10:10', '1 d 10:10'],\n        invalid_examples=['1 10:10'],\n        core_schemas=[core_schema.TimedeltaSche..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/datetime_parse.py", "score": 0.2290971577167511, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if isinstance(value, date):\n        if isinstance(value, datetime):\n            return value.date()\n        else:\n            return value\n\n    number = get_numeric(value, 'date')\n    if numbe..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.2289542555809021, "span_start": null, "span_end": null, "passage": "This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not You might want to enable this setting if you want to validate your data faster (basic..."}, {"qid": "", "rank": 16, "path": "docs/plugins/conversion_table.py", "score": 0.22818109393119812, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/).',\n        valid_examples=['10:10:10.0002'],\n        invalid_examples=['1:1:1'],\n        core_schemas=[core_schema.TimeSchema],\n    ),\n    Row..."}, {"qid": "", "rank": 17, "path": "pydantic/fields.py", "score": 0.22406373918056488, "span_start": null, "span_end": null, "passage": "decimal_places: Maximum number of decimal places allowed for numbers union_mode: The strategy to apply when validating a union Can be `smart` (the default), or `left_to_right` See [Union Mode](../conc..."}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.22381120920181274, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return Annotated[  # pyright: ignore[reportReturnType]\n        date,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n    ]..."}, {"qid": "", "rank": 19, "path": "tests/test_datetime.py", "score": 0.2120532989501953, "span_start": null, "span_end": null, "passage": "import re\nfrom datetime import date, datetime, time, timedelta, timezone\n\nimport pytest\nfrom dirty_equals import HasRepr\nfrom typing_extensions import Annotated\n\nfrom pydantic import (\n    AwareDateti..."}, {"qid": "", "rank": 20, "path": "docs/plugins/conversion_table.py", "score": 0.2102295458316803, "span_start": null, "span_end": null, "passage": "See [speedate](https://docs.rs/speedate/latest/speedate/).',\n        valid_examples=['2017-05-05 10:10:10', '2017-05-05T10:10:10.0002', '2017-05-05 10:10:10+00:00', '2017-05-05'],\n        invalid_exam..."}], "latency_ms": 4.047155380249023, "gold_paths": ["tests/benchmarks/test_fastapi_startup_generics.py", "docs/contributing.md", "docs/index.md"]}
