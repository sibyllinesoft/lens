{"qid": "lens_main_symbol_ce2d6d83", "query": "find function __getattr__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.5360432863235474, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 2, "path": "pydantic/deprecated/config.py", "score": 0.48936474323272705, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __getattr__(self, item: str) -> Any:\n        try:\n            obj = super().__getattribute__(item)\n            warnings.warn(_config.DEPRECATION_MESSAGE, DeprecationWarning)\n            r..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_decorators.py", "score": 0.4854819178581238, "span_start": null, "span_end": null, "passage": "\"\"\"\n        func = get_attribute_from_bases(cls_, cls_var_name)\n        if shim is not None:\n            func = shim(func)\n        func = unwrap_wrapped_function(func, unwrap_partial=False)\n        if..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators.py", "score": 0.4764070212841034, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if isinstance(tp, tuple):\n        for base in mro_for_bases(tp):\n            attribute = base.__dict__.get(name, _sentinel)\n            if attribute is not _sentinel:\n                attribute..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/error_wrappers.py", "score": 0.47599250078201294, "span_start": null, "span_end": null, "passage": "code = getattr(cls, 'code', None) or cls.__name__.replace('Error', '').lower()\n    return base_name + '.' + code"}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_typing_extra.py", "score": 0.47018325328826904, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/utils.py", "score": 0.4694027900695801, "span_start": null, "span_end": null, "passage": "def __repr_args__(self) -> 'ReprArgs':\n        return [(None, self._items)]\n\n\nclass ClassAttribute:\n    \"\"\"\n    Hide class attribute from its instances\n    \"\"\"\n\n    __slots__ = (\n        'name',\n     ..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_utils.py", "score": 0.45573318004608154, "span_start": null, "span_end": null, "passage": "def __repr_args__(self) -> _repr.ReprArgs:\n        return [(None, self._items)]\n\n\nif typing.TYPE_CHECKING:\n\n    def ClassAttribute(name: str, value: T) -> T: .."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_decorators.py", "score": 0.45382848381996155, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    wrapped: DecoratedType[ReturnType]\n    decorator_info: DecoratorInfo\n    shim: Callable[[Callable[..., Any]], Callable[..., Any]] | None = None\n\n    def __post_init__(self):\n        for attr ..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_decorators.py", "score": 0.4486429691314697, "span_start": null, "span_end": null, "passage": "Attributes:\n        cls_ref: The class ref cls_var_name: The decorated function name func: The decorated function shim: A wrapper function to wrap V1 style function info: The decorator info"}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_core_utils.py", "score": 0.44389039278030396, "span_start": null, "span_end": null, "passage": "\"\"\"\n    origin = get_origin(type_) or type_\n\n    args = get_args(type_) if is_generic_alias(type_) else (args_override or ())\n    generic_metadata = getattr(type_, '__pydantic_generic_metadata__', Non..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_typing_extra.py", "score": 0.44134360551834106, "span_start": null, "span_end": null, "passage": "type_hints.setdefault('return', function)\n        return type_hints\n\n    globalns = add_module_globals(function)\n    type_hints = {}\n    type_params: tuple[Any] = getattr(function, '__type_params__', ..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.44126975536346436, "span_start": null, "span_end": null, "passage": "r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    if is_classmethod:  # or is_staticmethod:\n        func.is_decorated = True\n        v = Var(na..."}, {"qid": "", "rank": 14, "path": "pydantic/main.py", "score": 0.43932443857192993, "span_start": null, "span_end": null, "passage": "# See `BaseModel.__repr_args__` for more details\n                try:\n                    pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n                except AttributeError:\n  ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/generics.py", "score": 0.43855029344558716, "span_start": null, "span_end": null, "passage": "# See: https://www.python.org/dev/peps/pep-0585\n            origin_type = getattr(typing, type_._name)\n        assert origin_type is not None\n        # PEP-604 syntax (Ex.: list | str) is represented ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.43855029344558716, "span_start": null, "span_end": null, "passage": "# See: https://www.python.org/dev/peps/pep-0585\n            origin_type = getattr(typing, type_._name)\n        assert origin_type is not None\n        # PEP-604 syntax (Ex.: list | str) is represented ..."}, {"qid": "", "rank": 17, "path": "pydantic/fields.py", "score": 0.4335254430770874, "span_start": null, "span_end": null, "passage": "\"\"\"\n            if item in {'__get__', '__set__', '__delete__'}:\n                if hasattr(self.default, item):\n                    return getattr(self.default, item)\n            raise AttributeError..."}, {"qid": "", "rank": 18, "path": "pydantic/decorator.py", "score": 0.43325257301330566, "span_start": null, "span_end": null, "passage": "\"\"\"The `decorator` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_typing_extra.py", "score": 0.433144748210907, "span_start": null, "span_end": null, "passage": "while hasattr(nsobj, '__wrapped__'):\n                    nsobj = nsobj.__wrapped__\n                globalns = getattr(nsobj, '__globals__', {})\n            if localns is None:\n                localns ..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.42996665835380554, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}], "latency_ms": 5.822181701660156, "gold_paths": ["pydantic/__init__.py"]}
{"qid": "lens_main_symbol_512ac469", "query": "find function __dir__", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/env_settings.py", "score": 0.41967061161994934, "span_start": null, "span_end": null, "passage": "\"\"\"\n    for f in dir_path.iterdir():\n        if f.name == file_name:\n            return f\n        elif not case_sensitive and f.name.lower() == file_name.lower():\n            return f\n    return None"}, {"qid": "", "rank": 2, "path": "pydantic/aliases.py", "score": 0.37458816170692444, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.path\n\n    def search_dict_for_path(self, d: dict) -> Any:\n        \"\"\"Searches a dictionary for the path specified by the alias Returns:\n            The value at the specified p..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generics.py", "score": 0.36100369691848755, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_core_utils.py", "score": 0.3503718972206116, "span_start": null, "span_end": null, "passage": "Args:\n        schema (core_schema.CoreSchema): The CoreSchema to process, it will not be modified f (Walk): A function to apply This function takes two arguments:\n          1 The current CoreSchema th..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3384030759334564, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 6, "path": "pydantic/type_adapter.py", "score": 0.3330746293067932, "span_start": null, "span_end": null, "passage": "On the other hand this function can be called with arbitrary objects,\n    including type aliases, where `__module__` (always `typing.py`) is not useful So instead we look at the globals in our parent ..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/env_settings.py", "score": 0.3266049027442932, "span_start": null, "span_end": null, "passage": "\"\"\"\n        secrets: Dict[str, Optional[str]] = {}\n\n        if self.secrets_dir is None:\n            return secrets\n\n        secrets_path = Path(self.secrets_dir).expanduser()\n\n        if not secrets_..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3079984188079834, "span_start": null, "span_end": null, "passage": "See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope\n    and suggestion at the end of the next comment by @gvanrossum WARNING 1: it matters exactly where this is calle..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_typing_extra.py", "score": 0.30754080414772034, "span_start": null, "span_end": null, "passage": "Using `f_back` would work sometimes but would be very wrong and confusing in many\n    other cases See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.3043646216392517, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 11, "path": "pydantic/aliases.py", "score": 0.30144619941711426, "span_start": null, "span_end": null, "passage": "Attributes:\n        path: A list of string or integer aliases \"\"\"\n\n    path: list[int | str]\n\n    def __init__(self, first_arg: str, *args: str | int) -> None:\n        self.path = [first_arg] + list(a..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_generics.py", "score": 0.2994948923587799, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except Attribu..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/config.py", "score": 0.29417815804481506, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\ndef get_config(config: Union[ConfigDict, Type[object], None]) -> Type[BaseConfig]:\n    if config is None:\n        return BaseConfig\n\n    else:\n        config_dict = (\n            co..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/class_validators.py", "score": 0.2941460609436035, "span_start": null, "span_end": null, "passage": "\"\"\"\n    f_cls = function if isinstance(function, classmethod) else classmethod(function)\n    if not in_ipython() and not allow_reuse:\n        ref = (\n            getattr(f_cls.__func__, '__module__', ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_utils.py", "score": 0.29290682077407837, "span_start": null, "span_end": null, "passage": "\"\"\"Bucket of reusable internal utilities This should be reduced as much as possible with functions only used in one place, moved to that place"}, {"qid": "", "rank": 16, "path": "docs/plugins/griffe_doclinks.py", "score": 0.29190585017204285, "span_start": null, "span_end": null, "passage": "import ast\nimport re\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Tuple\n\nfrom griffe.dataclasses import Object as GriffeObject\nfrom griffe.extensions import VisitorExtensi..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_decorators.py", "score": 0.29106733202934265, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_decorators.py", "score": 0.29030710458755493, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 19, "path": "pydantic/aliases.py", "score": 0.28339633345603943, "span_start": null, "span_end": null, "passage": "Attributes:\n        choices: A list containing a string or `AliasPath` \"\"\"\n\n    choices: list[str | AliasPath]\n\n    def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -> None..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_validators.py", "score": 0.2792131304740906, "span_start": null, "span_end": null, "passage": "So, for example, the following values of `dotted_path` result in the following returned values:\n    * 'collections': <module 'collections'>\n    * 'collections.abc': <module 'collections.abc'>\n    * 'c..."}], "latency_ms": 4.279851913452148, "gold_paths": ["pydantic/__init__.py"]}
{"qid": "lens_main_symbol_6f39089e", "query": "find function getattr_migration", "results": [{"qid": "", "rank": 1, "path": "pydantic/tools.py", "score": 0.5613550543785095, "span_start": null, "span_end": null, "passage": "\"\"\"The `tools` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 2, "path": "pydantic/utils.py", "score": 0.5448405742645264, "span_start": null, "span_end": null, "passage": "\"\"\"The `utils` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 3, "path": "pydantic/parse.py", "score": 0.543748140335083, "span_start": null, "span_end": null, "passage": "\"\"\"The `parse` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 4, "path": "pydantic/decorator.py", "score": 0.5395454168319702, "span_start": null, "span_end": null, "passage": "\"\"\"The `decorator` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 5, "path": "pydantic/schema.py", "score": 0.5245295166969299, "span_start": null, "span_end": null, "passage": "\"\"\"The `schema` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 6, "path": "pydantic/typing.py", "score": 0.5053408145904541, "span_start": null, "span_end": null, "passage": "\"\"\"`typing` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 7, "path": "pydantic/error_wrappers.py", "score": 0.50116366147995, "span_start": null, "span_end": null, "passage": "\"\"\"The `error_wrappers` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 8, "path": "pydantic/generics.py", "score": 0.5002784729003906, "span_start": null, "span_end": null, "passage": "\"\"\"The `generics` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 9, "path": "pydantic/json.py", "score": 0.4918155074119568, "span_start": null, "span_end": null, "passage": "\"\"\"The `json` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 10, "path": "pydantic/validators.py", "score": 0.49137043952941895, "span_start": null, "span_end": null, "passage": "\"\"\"The `validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 11, "path": "pydantic/datetime_parse.py", "score": 0.48657315969467163, "span_start": null, "span_end": null, "passage": "\"\"\"The `datetime_parse` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 12, "path": "pydantic/class_validators.py", "score": 0.4828457832336426, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 13, "path": "pydantic/env_settings.py", "score": 0.4571836292743683, "span_start": null, "span_end": null, "passage": "\"\"\"The `env_settings` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 14, "path": "tests/test_migration.py", "score": 0.45713546872138977, "span_start": null, "span_end": null, "passage": "'):\n        import_from('pydantic:BaseSettings')\n        assert False, 'pydantic:BaseSettings should not be importable'\n\n\ndef test_getattr_migration():\n    get_attr = getattr_migration(__name__)\n\n    ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/error_wrappers.py", "score": 0.4382998049259186, "span_start": null, "span_end": null, "passage": "code = getattr(cls, 'code', None) or cls.__name__.replace('Error', '').lower()\n    return base_name + '.' + code"}, {"qid": "", "rank": 16, "path": "pydantic/__init__.py", "score": 0.42873650789260864, "span_start": null, "span_end": null, "passage": "import typing\n\nfrom ._migration import getattr_migration\nfrom .version import VERSION\n\nif typing.TYPE_CHECKING:\n    # import of virtually everything is supported via `__getattr__` below,\n    # but we ..."}, {"qid": "", "rank": 17, "path": "tests/test_migration.py", "score": 0.3978126049041748, "span_start": null, "span_end": null, "passage": "import importlib\n\nimport pytest\n\nfrom pydantic._migration import DEPRECATED_MOVED_IN_V2, MOVED_IN_V2, REDIRECT_TO_V1, REMOVED_IN_V2, getattr_migration\nfrom pydantic.errors import PydanticImportError\n\n..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_decorators.py", "score": 0.39715495705604553, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if isinstance(tp, tuple):\n        for base in mro_for_bases(tp):\n            attribute = base.__dict__.get(name, _sentinel)\n            if attribute is not _sentinel:\n                attribute..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_decorators.py", "score": 0.38669055700302124, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 20, "path": "pydantic/_migration.py", "score": 0.36399707198143005, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if name == '__path__':\n            raise AttributeError(f'module {module!r} has no attribute {name!r}')\n\n        import warnings\n\n        from ._internal._validators import import_string\n\n..."}], "latency_ms": 4.739999771118164, "gold_paths": ["pydantic/_migration.py"]}
{"qid": "lens_main_symbol_c1f6b005", "query": "find function wrapper", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.6119025945663452, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  ..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_decorators.py", "score": 0.49788403511047363, "span_start": null, "span_end": null, "passage": "This handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod Args:\n        func: The function to unwrap unwrap_partial: If True (default), unwrap partial and partia..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_decorators.py", "score": 0.4634305536746979, "span_start": null, "span_end": null, "passage": "\"\"\"\n    sig = signature(unwrap_wrapped_function(function))\n    first = next(iter(sig.parameters.values()), None)\n    if first and first.name == 'self':\n        return True\n    return False\n\n\ndef ensur..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_typing_extra.py", "score": 0.45791929960250854, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_decorators.py", "score": 0.44578835368156433, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    cls_ref: str\n    cls_var_name: str\n    func: Callable[..., Any]\n    shim: Callable[[Any], Any] | None\n    info: DecoratorInfoType\n\n    @staticmethod\n    def build(\n        cls_: Any,\n        ..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/decorator.py", "score": 0.4435001313686371, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def validate(_func: 'AnyCallable') -> 'AnyCallable':\n        vd = ValidatedFunction(_func, config)\n\n        @wraps(_func)\n        def wrapper_function(*args: Any, **kwargs: Any) -> Any:\n     ..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.44325271248817444, "span_start": null, "span_end": null, "passage": "This class' __get__ returns the wrapped item's __get__ result,\n    which makes it transparent for classmethods and staticmethods Attributes:\n        wrapped: The decorator that has to be wrapped decor..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_decorators.py", "score": 0.43531325459480286, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    wrapped: DecoratedType[ReturnType]\n    decorator_info: DecoratorInfo\n    shim: Callable[[Callable[..., Any]], Callable[..., Any]] | None = None\n\n    def __post_init__(self):\n        for attr ..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_decorators.py", "score": 0.43218958377838135, "span_start": null, "span_end": null, "passage": "Attributes:\n        cls_ref: The class ref cls_var_name: The decorated function name func: The decorated function shim: A wrapper function to wrap V1 style function info: The decorator info"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_decorators.py", "score": 0.4074634611606598, "span_start": null, "span_end": null, "passage": "unwrap_types = (\n        (property, cached_property)\n        + ((partial, partialmethod) if unwrap_partial else ())\n        + ((staticmethod, classmethod) if unwrap_class_static_method else ())\n    )\n..."}, {"qid": "", "rank": 11, "path": "pydantic/functional_serializers.py", "score": 0.3908856511116028, "span_start": null, "span_end": null, "passage": "Args:\n        f: The function to be decorated mode: The serialization mode - `'plain'` means the function will be called instead of the default serialization logic\n            - `'wrap'` means the fun..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.38919639587402344, "span_start": null, "span_end": null, "passage": "\"\"\"\n        func = get_attribute_from_bases(cls_, cls_var_name)\n        if shim is not None:\n            func = shim(func)\n        func = unwrap_wrapped_function(func, unwrap_partial=False)\n        if..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_typing_extra.py", "score": 0.38822057843208313, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 14, "path": "pydantic/fields.py", "score": 0.3882197141647339, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def dec(f: Any) -> Any:\n        nonlocal description, deprecated, return_type, alias_priority\n        unwrapped = _decorators.unwrap_wrapped_function(f)\n\n        if description is None and un..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_decorators.py", "score": 0.3822740912437439, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 16, "path": "pydantic/validate_call_decorator.py", "score": 0.380389004945755, "span_start": null, "span_end": null, "passage": "\"\"\"\n    local_ns = _typing_extra.parent_frame_namespace()\n\n    def validate(function: AnyCallableT) -> AnyCallableT:\n        if isinstance(function, (classmethod, staticmethod)):\n            name = ty..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3796754479408264, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    @typing.no_type_check\n    def get_type_hints(  # noqa: C901\n        obj: Any,\n        globalns: dict[str, Any] | None = None,\n        localns: dict[str, Any] | None = None,\n        include_ex..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.3767108619213104, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._function_schema(schema)\n\n    def function_wrap_schema(self, schema: core_schema.WrapValidatorFunctionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matche..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_decorators.py", "score": 0.3728080093860626, "span_start": null, "span_end": null, "passage": "a partial object\n            return self.wrapped  # type: ignore[return-value]\n\n    def __set_name__(self, instance: Any, name: str) -> None:\n        if hasattr(self.wrapped, '__set_name__'):\n        ..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_serializers.py", "score": 0.3725176453590393, "span_start": null, "span_end": null, "passage": "- `plain` means the function will be called instead of the default serialization logic,\n            - `wrap` means the function will be called with an argument to optionally call the\n               de..."}], "latency_ms": 4.027605056762695, "gold_paths": ["pydantic/_migration.py"]}
{"qid": "lens_main_symbol_183278f9", "query": "find constant MOVED_IN_V2", "results": [{"qid": "", "rank": 1, "path": "tests/test_migration.py", "score": 0.34363701939582825, "span_start": null, "span_end": null, "passage": "import importlib\n\nimport pytest\n\nfrom pydantic._migration import DEPRECATED_MOVED_IN_V2, MOVED_IN_V2, REDIRECT_TO_V1, REMOVED_IN_V2, getattr_migration\nfrom pydantic.errors import PydanticImportError\n\n..."}, {"qid": "", "rank": 2, "path": "pydantic/_migration.py", "score": 0.32247963547706604, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if name == '__path__':\n            raise AttributeError(f'module {module!r} has no attribute {name!r}')\n\n        import warnings\n\n        from ._internal._validators import import_string\n\n..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_decorators.py", "score": 0.3085159659385681, "span_start": null, "span_end": null, "passage": "If we do replace any functions we put the replacement into the position\n        the replaced function was in; that is, we maintain the order"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_config.py", "score": 0.2531355023384094, "span_start": null, "span_end": null, "passage": "\"\"\"\n    deprecated_removed_keys = V2_REMOVED_KEYS & config_dict.keys()\n    deprecated_renamed_keys = V2_RENAMED_KEYS.keys() & config_dict.keys()\n    if deprecated_removed_keys or deprecated_renamed_ke..."}, {"qid": "", "rank": 5, "path": "tests/check_usage_docs.py", "score": 0.2527718245983124, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport re\nimport sys\nfrom pathlib import Path\n\nROOT_DIR = Path(__file__).parent.parent\nPYDANTIC_DIR = ROOT_DIR / 'pydantic'\nversion_file = PYDANTIC_DIR / 'version.py'\n\n\nversion = re.search(rb\"VER..."}, {"qid": "", "rank": 6, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.2452854961156845, "span_start": null, "span_end": null, "passage": "This makes our timing comparison incorrect\n        # However, the value must be different, otherwise *our* __dict__ == right.__dict__\n        # fast-path prevents our correct code from running\n       ..."}, {"qid": "", "rank": 7, "path": "tests/test_edge_cases.py", "score": 0.24376827478408813, "span_start": null, "span_end": null, "passage": "functools.cached_property,\n    which caches the computed values in the instance's __dict__\n    \"\"\"\n\n    class Model(BaseModel):\n        attr: int\n\n        @functools.cached_property\n        def cached..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/generics.py", "score": 0.24192848801612854, "span_start": null, "span_end": null, "passage": "continue\n            elif cls in _assigned_parameters:\n                if base_model in _assigned_parameters:\n                    # cls is partially parameterised but not from base_model\n             ..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_core_utils.py", "score": 0.23855403065681458, "span_start": null, "span_end": null, "passage": "if current_recursion_ref_count[ref] != 0:\n                involved_in_recursion[ref] = True\n            return s\n\n        current_recursion_ref_count[ref] += 1\n        recurse(definitions[ref], count_..."}, {"qid": "", "rank": 10, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.23748674988746643, "span_start": null, "span_end": null, "passage": "This makes our timing comparison incorrect\n        # However, the value must be different, otherwise *our* __dict__ == right.__dict__\n        # fast-path prevents our correct code from running\n       ..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.22865667939186096, "span_start": null, "span_end": null, "passage": "\"\"\"\n    parameters = list(sig.parameters.values())\n    return sum(\n        1\n        for param in parameters\n        if can_be_positional(param)\n        # First argument is the value being validated/s..."}, {"qid": "", "rank": 12, "path": "pydantic/main.py", "score": 0.22693996131420135, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not force and cls.__pydantic_complete__:\n            return None\n        else:\n            if '__pydantic_core_schema__' in cls.__dict__:\n                delattr(cls, '__pydantic_core_s..."}, {"qid": "", "rank": 13, "path": "docs/plugins/conversion_table.py", "score": 0.2267693281173706, "span_start": null, "span_end": null, "passage": "`val % 1 == 0`, raises error for `nan`, `inf`.',\n        valid_examples=[2.0],\n        invalid_examples=[2.1, 2.2250738585072011e308, float('nan'), float('inf')],\n        core_schemas=[core_schema.Int..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/config.py", "score": 0.2208942323923111, "span_start": null, "span_end": null, "passage": "# Pydantic v2 doesn't depend on Cython at all"}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.2208738923072815, "span_start": null, "span_end": null, "passage": "dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n    return dedent_source\n\n\ndef _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n    frame = inspect.currentframe()\n\n    whil..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.2197534590959549, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # We need to iteratively simplify the definitions until we reach a fixed point # The reason for this is that outer definitions may reference inner definitions that get simplified\n        #..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/json.py", "score": 0.21427340805530548, "span_start": null, "span_end": null, "passage": "\"\"\"\n    minutes, seconds = divmod(td.seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    return f'{\"-\" if td.days < 0 else \"\"}P{abs(td.days)}DT{hours:d}H{minutes:d}M{seconds:d}.{td.microseconds:..."}, {"qid": "", "rank": 18, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.21385163068771362, "span_start": null, "span_end": null, "passage": "This makes our timing comparison incorrect\n        # However, the value must be different, otherwise *our* __dict__ == right.__dict__\n        # fast-path prevents our correct code from running\n       ..."}, {"qid": "", "rank": 19, "path": "tests/test_types.py", "score": 0.21171152591705322, "span_start": null, "span_end": null, "passage": "str_min_length: constr(min_length=5) = .. str_email: EmailStr = .. name_email: NameEmail = .."}, {"qid": "", "rank": 20, "path": "tests/test_types.py", "score": 0.21171152591705322, "span_start": null, "span_end": null, "passage": "str_min_length: constr(min_length=5) = .. str_email: EmailStr = .. name_email: NameEmail = .."}], "latency_ms": 4.73332405090332, "gold_paths": ["pydantic/_migration.py"]}
{"qid": "lens_main_symbol_29894507", "query": "find constant DEPRECATED_MOVED_IN_V2", "results": [{"qid": "", "rank": 1, "path": "pydantic/_migration.py", "score": 0.4791848063468933, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if name == '__path__':\n            raise AttributeError(f'module {module!r} has no attribute {name!r}')\n\n        import warnings\n\n        from ._internal._validators import import_string\n\n..."}, {"qid": "", "rank": 2, "path": "tests/test_warnings.py", "score": 0.47379070520401, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V2.1 to be removed in V3.0.'\n\n\ndef test_pydantic_deprecation_warning_2_0_migration_guide_link():\n    warning = PydanticDeprecationWarning('Warning message', since=(2, 0))\n\n    a..."}, {"qid": "", "rank": 3, "path": "pydantic/warnings.py", "score": 0.43910810351371765, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V{self.since[0]}.{self.since[1]}'\n            f' to be removed in V{self.expected_removal[0]}.{self.expected_removal[1]}.'\n        )\n        if self.since == (2, 0):\n           ..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_model_construction.py", "score": 0.4372115731239319, "span_start": null, "span_end": null, "passage": "Attributes:\n        msg: The deprecation message to be emitted wrapped_property: The property instance if the deprecated field is a computed field, or `None` field_name: The name of the field being de..."}, {"qid": "", "rank": 5, "path": "tests/test_warnings.py", "score": 0.4260699152946472, "span_start": null, "span_end": null, "passage": "See Pydantic V2 Migration Guide at https://errors.pydantic.dev/{version_short()}/migration/'\n    )\n\n\ndef test_pydantic_deprecated_since_2_0_warning():\n    warning = PydanticDeprecatedSince20('Warning ..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_config.py", "score": 0.425638347864151, "span_start": null, "span_end": null, "passage": "\"\"\"\n    deprecated_removed_keys = V2_REMOVED_KEYS & config_dict.keys()\n    deprecated_renamed_keys = V2_RENAMED_KEYS.keys() & config_dict.keys()\n    if deprecated_removed_keys or deprecated_renamed_ke..."}, {"qid": "", "rank": 7, "path": "tests/test_warnings.py", "score": 0.41430720686912537, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V2.1 to be removed in V4.0.'\n    assert warning.args[0] == 'Warning message.'\n\n\ndef test_pydantic_deprecation_warning_calculated_expected_removal():\n    warning = PydanticDeprec..."}, {"qid": "", "rank": 8, "path": "pydantic/warnings.py", "score": 0.40293192863464355, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific warnings.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom .version import version_short\n\n__all__ = (\n    'PydanticDeprecatedSince20',\n    'PydanticDeprecationWarning'..."}, {"qid": "", "rank": 9, "path": "pydantic/warnings.py", "score": 0.38579893112182617, "span_start": null, "span_end": null, "passage": "It provides information on when the\n    deprecation was introduced and the expected version in which the corresponding functionality will be removed Attributes:\n        message: Description of the war..."}, {"qid": "", "rank": 10, "path": "tests/test_warnings.py", "score": 0.38191789388656616, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V2.1 to be removed in V4.0.'\n    assert warning.args[0] == 'Warning message'\n    assert warning.args[1] == 'Arbitrary argument'\n\n\ndef test_pydantic_deprecation_warning_tailing_d..."}, {"qid": "", "rank": 11, "path": "tests/test_migration.py", "score": 0.3744408190250397, "span_start": null, "span_end": null, "passage": "import importlib\n\nimport pytest\n\nfrom pydantic._migration import DEPRECATED_MOVED_IN_V2, MOVED_IN_V2, REDIRECT_TO_V1, REMOVED_IN_V2, getattr_migration\nfrom pydantic.errors import PydanticImportError\n\n..."}, {"qid": "", "rank": 12, "path": "tests/test_main.py", "score": 0.36301863193511963, "span_start": null, "span_end": null, "passage": "m.__dict__['c'] = 1\n    assert hash(m) == h\n\n    # Order of keys can be changed, e.g with the deprecated copy method, which shouldn't matter m.__dict__ = {'b': 2, 'a': 1}\n    assert hash(m) == h\n\n    ..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_generics.py", "score": 0.3610866963863373, "span_start": null, "span_end": null, "passage": "if sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[GenericTypesCacheKey, 'type[BaseModel]']\nelse:\n    GenericTypesCache = WeakV..."}, {"qid": "", "rank": 14, "path": "pydantic/deprecated/config.py", "score": 0.3525628447532654, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nimport warnings\nfrom typing import TYPE_CHECKING, Any\n\nfrom typing_extensions import Literal, deprecated\n\nfrom .._internal import _config\nfrom ..war..."}, {"qid": "", "rank": 15, "path": "pydantic/fields.py", "score": 0.34579259157180786, "span_start": null, "span_end": null, "passage": "\"\"\"\n        metadata: list[Any] = []\n        general_metadata = {}\n        for key, value in list(kwargs.items()):\n            try:\n                marker = FieldInfo.metadata_lookup[key]\n            ..."}, {"qid": "", "rank": 16, "path": "pydantic/deprecated/tools.py", "score": 0.345769464969635, "span_start": null, "span_end": null, "passage": "parse_obj_as no longer creates temporary models',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    return TypeAdapter(type_).validate_python(obj)\n\n\n@deprecated(\n    '`schema_of`..."}, {"qid": "", "rank": 17, "path": "tests/test_warnings.py", "score": 0.3360642194747925, "span_start": null, "span_end": null, "passage": "from pydantic import PydanticDeprecatedSince20, PydanticDeprecationWarning\nfrom pydantic.version import version_short\n\n\ndef test_pydantic_deprecation_warning():\n    warning = PydanticDeprecationWarnin..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/generics.py", "score": 0.3359369933605194, "span_start": null, "span_end": null, "passage": "if sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[CacheKey, Type[BaseModel]]\n    AssignedParameters = WeakKeyDictionary[Type[B..."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.3314977288246155, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    decorator_repr: ClassVar[str] = '@computed_field'\n    wrapped_property: property\n    return_type: Any\n    alias: str | None\n    alias_priority: int | None\n    title: str | None\n    field_titl..."}, {"qid": "", "rank": 20, "path": "pydantic/deprecated/json.py", "score": 0.33135050535202026, "span_start": null, "span_end": null, "passage": "import datetime\nimport warnings\nfrom collections import deque\nfrom decimal import Decimal\nfrom enum import Enum\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interfac..."}], "latency_ms": 4.77147102355957, "gold_paths": ["pydantic/_migration.py"]}
{"qid": "lens_main_symbol_81d3193d", "query": "find constant REDIRECT_TO_V1", "results": [{"qid": "", "rank": 1, "path": "pydantic/_migration.py", "score": 0.3524472713470459, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if name == '__path__':\n            raise AttributeError(f'module {module!r} has no attribute {name!r}')\n\n        import warnings\n\n        from ._internal._validators import import_string\n\n..."}, {"qid": "", "rank": 2, "path": "pydantic/networks.py", "score": 0.31464630365371704, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    max_length: int | None = None\n    allowed_schemes: list[str] | None = None\n    host_required: bool | None = None\n    default_host: str | None = None\n    default_port: int | None = None\n    de..."}, {"qid": "", "rank": 3, "path": "docs/plugins/griffe_doclinks.py", "score": 0.30999556183815, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file})\\n'\n\n\ndef replace_links(m: re.Match, *, api_link: str) -> str:\n    path_group = m.group(1)\n    if '#' not in path_group:\n        # no head..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/networks.py", "score": 0.3067295551300049, "span_start": null, "span_end": null, "passage": "host1.db.net,host2.db.net\n    \"\"\"\n    global _multi_host_url_regex_cache\n    if _multi_host_url_regex_cache is None:\n        _multi_host_url_regex_cache = re.compile(\n            rf'{_scheme_regex}{_u..."}, {"qid": "", "rank": 5, "path": "tests/test_networks.py", "score": 0.3025973439216614, "span_start": null, "span_end": null, "passage": "# https://www.rabbitmq.com/uri-spec.html\n    m = Model(a='amqps://')\n    assert m.a.scheme == 'amqps'\n    assert m.a.host is None\n    assert m.a.port is None\n    assert m.a.path is None\n\n\ndef test_red..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_typing_extra.py", "score": 0.29898160696029663, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return typing.ForwardRef(arg, is_argument)\n\nelse:\n    _make_forward_ref = typing.ForwardRef\n\n\nif sys.version_info >= (3, 10):\n    get_type_hints = typing.get_type_hints\n\nelse:\n    \"\"\"\n    ..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/networks.py", "score": 0.2934185266494751, "span_start": null, "span_end": null, "passage": "\"\"\"\n        host, tld, host_type, rebuild = cls.validate_host(parts)\n\n        return cls(\n            None if rebuild else url,\n            scheme=parts['scheme'],\n            user=parts['user'],\n    ..."}, {"qid": "", "rank": 8, "path": "pydantic/aliases.py", "score": 0.28183111548423767, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.path\n\n    def search_dict_for_path(self, d: dict) -> Any:\n        \"\"\"Searches a dictionary for the path specified by the alias Returns:\n            The value at the specified p..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2796890139579773, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return isinstance(type_, test_new_type.__class__) and hasattr(type_, '__supertype__')  # type: ignore[arg-type]\n\n\ndef _check_classvar(v: type[Any] | None) -> bool:\n    if v is None:\n        re..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2766539454460144, "span_start": null, "span_end": null, "passage": "Unlike `typing.get_type_hints`, this function will not error if a forward reference is not resolvable"}, {"qid": "", "rank": 11, "path": "pydantic/v1/typing.py", "score": 0.2765810191631317, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if v is None:\n        return False\n\n    return v.__class__ == Final.__class__ and (sys.version_info < (3, 8) or getattr(v, '_name', None) == 'Final')\n\n\ndef is_classvar(ann_type: Type[Any]) -> ..."}, {"qid": "", "rank": 12, "path": "tests/conftest.py", "score": 0.27229639887809753, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if isinstance(source_code_or_function, FunctionType):\n            source_code = _extract_source_code_from_function(source_code_or_function)\n        else:\n            source_code = source_c..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2677115201950073, "span_start": null, "span_end": null, "passage": "type_hints.setdefault('return', function)\n        return type_hints\n\n    globalns = add_module_globals(function)\n    type_hints = {}\n    type_params: tuple[Any] = getattr(function, '__type_params__', ..."}, {"qid": "", "rank": 14, "path": "tests/check_usage_docs.py", "score": 0.26654744148254395, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport re\nimport sys\nfrom pathlib import Path\n\nROOT_DIR = Path(__file__).parent.parent\nPYDANTIC_DIR = ROOT_DIR / 'pydantic'\nversion_file = PYDANTIC_DIR / 'version.py'\n\n\nversion = re.search(rb\"VER..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.26456302404403687, "span_start": null, "span_end": null, "passage": "def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n        args = get_args(obj)\n        if args:\n            args = tuple([self._resolve_forward_re..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/networks.py", "score": 0.2640354633331299, "span_start": null, "span_end": null, "passage": "Additionally to `url_regex` it allows to match multiple hosts E.g"}, {"qid": "", "rank": 17, "path": "tests/test_migration.py", "score": 0.25927120447158813, "span_start": null, "span_end": null, "passage": "import importlib\n\nimport pytest\n\nfrom pydantic._migration import DEPRECATED_MOVED_IN_V2, MOVED_IN_V2, REDIRECT_TO_V1, REMOVED_IN_V2, getattr_migration\nfrom pydantic.errors import PydanticImportError\n\n..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generics.py", "score": 0.2586696445941925, "span_start": null, "span_end": null, "passage": "\"\"\"\n    previously_seen_type_refs = _generic_recursion_cache.get()\n    if previously_seen_type_refs is None:\n        previously_seen_type_refs = set()\n        token = _generic_recursion_cache.set(prev..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2581990659236908, "span_start": null, "span_end": null, "passage": "* prefixing `typing.` where appropriate\n        * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument https://github.com/python/cpython/blob/aaaf5174241496afca7ce4..."}, {"qid": "", "rank": 20, "path": "docs/plugins/griffe_doclinks.py", "score": 0.2506594657897949, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file}#{slug})\\n'\n\n\ndef update_docstring(obj: GriffeObject) -> str:\n    return re.sub(\n        r'usage[\\- ]docs: ?https://docs\\.pydantic\\.dev/.+?..."}], "latency_ms": 4.84466552734375, "gold_paths": ["pydantic/_migration.py"]}
{"qid": "lens_main_symbol_a85f2c49", "query": "find constant REMOVED_IN_V2", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_config.py", "score": 0.4188455641269684, "span_start": null, "span_end": null, "passage": "\"\"\"\n    deprecated_removed_keys = V2_REMOVED_KEYS & config_dict.keys()\n    deprecated_renamed_keys = V2_RENAMED_KEYS.keys() & config_dict.keys()\n    if deprecated_removed_keys or deprecated_renamed_ke..."}, {"qid": "", "rank": 2, "path": "tests/test_warnings.py", "score": 0.4010893702507019, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V2.1 to be removed in V4.0.'\n    assert warning.args[0] == 'Warning message.'\n\n\ndef test_pydantic_deprecation_warning_calculated_expected_removal():\n    warning = PydanticDeprec..."}, {"qid": "", "rank": 3, "path": "pydantic/fields.py", "score": 0.38961756229400635, "span_start": null, "span_end": null, "passage": "const = extra.pop('const', None)  # type: ignore\n    if const is not None:\n        raise PydanticUserError('`const` is removed, use `Literal` instead', code='removed-kwargs')\n\n    min_items = extra.po..."}, {"qid": "", "rank": 4, "path": "pydantic/warnings.py", "score": 0.38339728116989136, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    message: str\n    since: tuple[int, int]\n    expected_removal: tuple[int, int]\n\n    def __init__(\n        self, message: str, *args: object, since: tuple[int, int], expected_removal: tuple[int..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_utils.py", "score": 0.3787204325199127, "span_start": null, "span_end": null, "passage": "\"\"\"\n    result: list[T] = []\n    result_names: list[str] = []\n    for v in input_list:\n        v_name = name_factory(v)\n        if v_name not in result_names:\n            result_names.append(v_name)\n ..."}, {"qid": "", "rank": 6, "path": "pydantic/experimental/pipeline.py", "score": 0.3695448040962219, "span_start": null, "span_end": null, "passage": "import inspect\n\n            try:\n                # remove ')' suffix, can use removesuffix once we drop 3.8\n                source = inspect.getsource(func).strip()\n                if source.endswith(..."}, {"qid": "", "rank": 7, "path": "pydantic/warnings.py", "score": 0.3638128638267517, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V{self.since[0]}.{self.since[1]}'\n            f' to be removed in V{self.expected_removal[0]}.{self.expected_removal[1]}.'\n        )\n        if self.since == (2, 0):\n           ..."}, {"qid": "", "rank": 8, "path": "tests/test_warnings.py", "score": 0.3533499836921692, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V2.1 to be removed in V4.0.'\n    assert warning.args[0] == 'Warning message'\n    assert warning.args[1] == 'Arbitrary argument'\n\n\ndef test_pydantic_deprecation_warning_tailing_d..."}, {"qid": "", "rank": 9, "path": "tests/test_warnings.py", "score": 0.35228681564331055, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V2.1 to be removed in V3.0.'\n\n\ndef test_pydantic_deprecation_warning_2_0_migration_guide_link():\n    warning = PydanticDeprecationWarning('Warning message', since=(2, 0))\n\n    a..."}, {"qid": "", "rank": 10, "path": "pydantic/deprecated/copy_internals.py", "score": 0.3493316173553467, "span_start": null, "span_end": null, "passage": "import BaseModel\n\n    if isinstance(v, BaseModel):\n        if to_dict:\n            return v.model_dump(\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                ..."}, {"qid": "", "rank": 11, "path": "pydantic/main.py", "score": 0.34214121103286743, "span_start": null, "span_end": null, "passage": "'\n            'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n            category=PydanticDeprecatedSince20,\n        )\n        from .deprecated impor..."}, {"qid": "", "rank": 12, "path": "tests/test_main.py", "score": 0.33796072006225586, "span_start": null, "span_end": null, "passage": "m.__dict__['c'] = 1\n    assert hash(m) == h\n\n    # Order of keys can be changed, e.g with the deprecated copy method, which shouldn't matter m.__dict__ = {'b': 2, 'a': 1}\n    assert hash(m) == h\n\n    ..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.33645811676979065, "span_start": null, "span_end": null, "passage": "When the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in\n    calls to `repr()` and `str()` If the value _is_ empty, it is displayed as `''`"}, {"qid": "", "rank": 14, "path": "tests/check_usage_docs.py", "score": 0.33135855197906494, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport re\nimport sys\nfrom pathlib import Path\n\nROOT_DIR = Path(__file__).parent.parent\nPYDANTIC_DIR = ROOT_DIR / 'pydantic'\nversion_file = PYDANTIC_DIR / 'version.py'\n\n\nversion = re.search(rb\"VER..."}, {"qid": "", "rank": 15, "path": "pydantic/main.py", "score": 0.3307304084300995, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not force and cls.__pydantic_complete__:\n            return None\n        else:\n            if '__pydantic_core_schema__' in cls.__dict__:\n                delattr(cls, '__pydantic_core_s..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.3266165852546692, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def __init__(self, size_limit: int = _LIMITED_DICT_SIZE):\n            self.size_limit = size_limit\n            super().__init__()\n\n        def __setitem__(self, key: Any, value: Any, /) -..."}, {"qid": "", "rank": 17, "path": "pydantic/fields.py", "score": 0.3258725106716156, "span_start": null, "span_end": null, "passage": "It will be removed, use `exclude` instead', DeprecationWarning)\n\n    return FieldInfo.from_field(\n        default,\n        default_factory=default_factory,\n        alias=alias,\n        alias_priority=..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_model_construction.py", "score": 0.32154667377471924, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if d is None:\n        return None\n    result = {}\n    for k, v in d.items():\n        try:\n            proxy = _PydanticWeakRef(v)\n        except TypeError:\n            proxy = v\n        result..."}, {"qid": "", "rank": 19, "path": "docs/plugins/main.py", "score": 0.3184703290462494, "span_start": null, "span_end": null, "passage": "https://youtrack.jetbrains.com/issue/IDEA-297873 & https://python-markdown.github.io/extensions/fenced_code_blocks/\n    \"\"\"\n\n    def remove_attrs(match: re.Match[str]) -> str:\n        suffix = re.sub(..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.3174501061439514, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}], "latency_ms": 3.96728515625, "gold_paths": ["pydantic/_migration.py"]}
{"qid": "lens_main_symbol_766c3e00", "query": "find function to_pascal", "results": [{"qid": "", "rank": 1, "path": "pydantic/alias_generators.py", "score": 0.35853514075279236, "span_start": null, "span_end": null, "passage": "\"\"\"Alias generators for converting between different capitalization conventions.\"\"\"\n\nimport re\n\n__all__ = ('to_pascal', 'to_camel', 'to_snake')\n\n# TODO: in V3, change the argument names to be more des..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.30571311712265015, "span_start": null, "span_end": null, "passage": "\"\"\"\n        inner_discriminator = choice['discriminator']\n        return inner_discriminator == self.discriminator or (\n            isinstance(inner_discriminator, list)\n            and (self.discrimi..."}, {"qid": "", "rank": 3, "path": "pydantic/config.py", "score": 0.2592742443084717, "span_start": null, "span_end": null, "passage": "Here's an example with\n    a basic callable:\n\n    ```py\n    from pydantic import BaseModel, ConfigDict\n    from pydantic.alias_generators import to_pascal\n\n    class Voice(BaseModel):\n        model_co..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/color.py", "score": 0.2541552186012268, "span_start": null, "span_end": null, "passage": "`<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg"}, {"qid": "", "rank": 5, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.2502424716949463, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 6, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.2502424716949463, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 7, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.2502424716949463, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 8, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.2502424716949463, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 9, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.2502424716949463, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 10, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.2502424716949463, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 11, "path": "pydantic/main.py", "score": 0.2502424716949463, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 12, "path": "pydantic/v1/color.py", "score": 0.24939247965812683, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_generics.py", "score": 0.2410946786403656, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.23751088976860046, "span_start": null, "span_end": null, "passage": "\"\"\"\n        num_masked = len(self) - 10  # len(bin) + len(last4) == 10\n        return f'{self.bin}{\"*\" * num_masked}{self.last4}'\n\n    @classmethod\n    def validate_digits(cls, card_number: str) -> No..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_decorators.py", "score": 0.23548837006092072, "span_start": null, "span_end": null, "passage": "return\n            candidate: type[Any] | None = None\n            for seq in non_empty:  # Find merge candidates among seq heads candidate = seq[0]\n                not_head = [s for s in non_empty if ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_decorators.py", "score": 0.23478876054286957, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.2299581617116928, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_decorators.py", "score": 0.22892610728740692, "span_start": null, "span_end": null, "passage": "If we do replace any functions we put the replacement into the position\n        the replaced function was in; that is, we maintain the order"}, {"qid": "", "rank": 19, "path": "pydantic/v1/mypy.py", "score": 0.22835542261600494, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.22835542261600494, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}], "latency_ms": 3.7031173706054688, "gold_paths": ["pydantic/alias_generators.py"]}
{"qid": "lens_main_symbol_e2b08db4", "query": "find function to_camel", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/decorator.py", "score": 0.438346266746521, "span_start": null, "span_end": null, "passage": "from functools import wraps\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Mapping, Optional, Tuple, Type, TypeVar, Union, overload\n\nfrom pydantic.v1 import validator\nfrom pydantic.v1.co..."}, {"qid": "", "rank": 2, "path": "tests/test_computed_fields.py", "score": 0.42923057079315186, "span_start": null, "span_end": null, "passage": "import random\nimport sys\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Callable, ClassVar, Generic, List, Tuple, TypeVar\n\nimport pytest\nfrom pydantic_core import ValidationError, core_sc..."}, {"qid": "", "rank": 3, "path": "pydantic/alias_generators.py", "score": 0.4223555326461792, "span_start": null, "span_end": null, "passage": "\"\"\"\n    camel = snake.title()\n    return re.sub('([0-9A-Za-z])_(?=[0-9A-Z])', lambda m: m.group(1), camel)\n\n\ndef to_camel(snake: str) -> str:\n    \"\"\"Convert a snake_case string to camelCase Args:\n    ..."}, {"qid": "", "rank": 4, "path": "pydantic/alias_generators.py", "score": 0.4208577275276184, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # If the string is already in camelCase and does not contain a digit followed\n    # by a lowercase letter, return it as it is\n    if re.match('^[a-z]+[A-Za-z0-9]*$', snake) and not re.search(r..."}, {"qid": "", "rank": 5, "path": "tests/test_aliases.py", "score": 0.4160144329071045, "span_start": null, "span_end": null, "passage": "from contextlib import nullcontext as does_not_raise\nfrom inspect import signature\nfrom typing import Any, ContextManager, List, Optional\n\nimport pytest\nfrom dirty_equals import IsStr\nfrom pydantic_co..."}, {"qid": "", "rank": 6, "path": "pydantic/_migration.py", "score": 0.40683650970458984, "span_start": null, "span_end": null, "passage": "import sys\nfrom typing import Any, Callable, Dict\n\nfrom .version import version_short\n\nMOVED_IN_V2 = {\n    'pydantic.utils:version_info': 'pydantic.version:version_info',\n    'pydantic.error_wrappers:..."}, {"qid": "", "rank": 7, "path": "pydantic/alias_generators.py", "score": 0.4004111886024475, "span_start": null, "span_end": null, "passage": "\"\"\"Alias generators for converting between different capitalization conventions.\"\"\"\n\nimport re\n\n__all__ = ('to_pascal', 'to_camel', 'to_snake')\n\n# TODO: in V3, change the argument names to be more des..."}, {"qid": "", "rank": 8, "path": "pydantic/alias_generators.py", "score": 0.3360901474952698, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # `(?<=[a-zA-Z])(?=[0-9])` matches the space between a letter and a digit\n    # `(?<=[a-z0-9])(?=[A-Z])` matches the space between a lowercase letter / digit and uppercase letter\n    # `(?<=[A..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_decorators.py", "score": 0.3112342357635498, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 10, "path": "tests/test_validate_call.py", "score": 0.3102637529373169, "span_start": null, "span_end": null, "passage": "This test is just to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n    globs = {}\n    exec(\n        \"\"\"\nfrom typing import Iterable\nfrom pydantic import validate_call\n\n@validate..."}, {"qid": "", "rank": 11, "path": "pydantic/config.py", "score": 0.30718332529067993, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import AliasGenerator, BaseModel, ConfigDict\n    from pydantic.alias_generators import to_camel, to_pascal\n\n    class Athlete(BaseModel):\n        first_name: str\n        last_n..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.30101490020751953, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 13, "path": "docs/plugins/griffe_doclinks.py", "score": 0.29575788974761963, "span_start": null, "span_end": null, "passage": "import ast\nimport re\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Tuple\n\nfrom griffe.dataclasses import Object as GriffeObject\nfrom griffe.extensions import VisitorExtensi..."}, {"qid": "", "rank": 14, "path": "pydantic/experimental/pipeline.py", "score": 0.2943894565105438, "span_start": null, "span_end": null, "passage": "import inspect\n\n            try:\n                # remove ')' suffix, can use removesuffix once we drop 3.8\n                source = inspect.getsource(func).strip()\n                if source.endswith(..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2934424877166748, "span_start": null, "span_end": null, "passage": "Unlike `typing.get_type_hints`, this function will not error if a forward reference is not resolvable"}, {"qid": "", "rank": 16, "path": "pydantic/plugin/_schema_validator.py", "score": 0.2848077416419983, "span_start": null, "span_end": null, "passage": "are missing\n    or are inherited from the protocol \"\"\"\n    handler = getattr(handler_cls, method_name, None)\n    if handler is None:\n        return False\n    elif handler.__module__ == 'pydantic.plugi..."}, {"qid": "", "rank": 17, "path": "pydantic/type_adapter.py", "score": 0.27941858768463135, "span_start": null, "span_end": null, "passage": "On the other hand this function can be called with arbitrary objects,\n    including type aliases, where `__module__` (always `typing.py`) is not useful So instead we look at the globals in our parent ..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.27895763516426086, "span_start": null, "span_end": null, "passage": "Args:\n        cls: The class of the Pydantic model to inspect use_inspect: Whether to skip usage of frames to find the object and use\n            the `inspect` module instead Returns:\n        A mappin..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/mypy.py", "score": 0.2784719467163086, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    self_ty..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_generics.py", "score": 0.27823132276535034, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}], "latency_ms": 3.702878952026367, "gold_paths": ["pydantic/alias_generators.py"]}
{"qid": "lens_main_symbol_b62e11a1", "query": "find function to_snake", "results": [{"qid": "", "rank": 1, "path": "pydantic/alias_generators.py", "score": 0.4961315095424652, "span_start": null, "span_end": null, "passage": "Returns:\n        The converted string in snake_case"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generics.py", "score": 0.4020121097564697, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 3, "path": "pydantic/alias_generators.py", "score": 0.40152454376220703, "span_start": null, "span_end": null, "passage": "\"\"\"Alias generators for converting between different capitalization conventions.\"\"\"\n\nimport re\n\n__all__ = ('to_pascal', 'to_camel', 'to_snake')\n\n# TODO: in V3, change the argument names to be more des..."}, {"qid": "", "rank": 4, "path": "pydantic/alias_generators.py", "score": 0.3948478400707245, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # `(?<=[a-zA-Z])(?=[0-9])` matches the space between a letter and a digit\n    # `(?<=[a-z0-9])(?=[A-Z])` matches the space between a lowercase letter / digit and uppercase letter\n    # `(?<=[A..."}, {"qid": "", "rank": 5, "path": "pydantic/aliases.py", "score": 0.37319737672805786, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.path\n\n    def search_dict_for_path(self, d: dict) -> Any:\n        \"\"\"Searches a dictionary for the path specified by the alias Returns:\n            The value at the specified p..."}, {"qid": "", "rank": 6, "path": "pydantic/alias_generators.py", "score": 0.372378408908844, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # If the string is already in camelCase and does not contain a digit followed\n    # by a lowercase letter, return it as it is\n    if re.match('^[a-z]+[A-Za-z0-9]*$', snake) and not re.search(r..."}, {"qid": "", "rank": 7, "path": "pydantic/alias_generators.py", "score": 0.36404743790626526, "span_start": null, "span_end": null, "passage": "\"\"\"\n    camel = snake.title()\n    return re.sub('([0-9A-Za-z])_(?=[0-9A-Z])', lambda m: m.group(1), camel)\n\n\ndef to_camel(snake: str) -> str:\n    \"\"\"Convert a snake_case string to camelCase Args:\n    ..."}, {"qid": "", "rank": 8, "path": "pydantic/mypy.py", "score": 0.3636521100997925, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3614463210105896, "span_start": null, "span_end": null, "passage": "* prefixing `typing.` where appropriate\n        * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument https://github.com/python/cpython/blob/aaaf5174241496afca7ce4..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_core_utils.py", "score": 0.3608325719833374, "span_start": null, "span_end": null, "passage": "Args:\n        schema (core_schema.CoreSchema): The CoreSchema to process, it will not be modified f (Walk): A function to apply This function takes two arguments:\n          1 The current CoreSchema th..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/errors.py", "score": 0.35955503582954407, "span_start": null, "span_end": null, "passage": "Note: the callable can't be a lambda as pickle looks in the namespace to find it\n    \"\"\"\n    return cls(**ctx)\n\n\nclass PydanticErrorMixin:\n    code: str\n    msg_template: str\n\n    def __init__(self, *..."}, {"qid": "", "rank": 12, "path": "pydantic/experimental/pipeline.py", "score": 0.34775108098983765, "span_start": null, "span_end": null, "passage": "import inspect\n\n            try:\n                # remove ')' suffix, can use removesuffix once we drop 3.8\n                source = inspect.getsource(func).strip()\n                if source.endswith(..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_generics.py", "score": 0.34736397862434387, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except Attribu..."}, {"qid": "", "rank": 14, "path": "pydantic/type_adapter.py", "score": 0.3438853621482849, "span_start": null, "span_end": null, "passage": "On the other hand this function can be called with arbitrary objects,\n    including type aliases, where `__module__` (always `typing.py`) is not useful So instead we look at the globals in our parent ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.34311068058013916, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.3394460678100586, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    self_ty..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_typing_extra.py", "score": 0.33776330947875977, "span_start": null, "span_end": null, "passage": "See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope\n    and suggestion at the end of the next comment by @gvanrossum WARNING 1: it matters exactly where this is calle..."}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.3370879888534546, "span_start": null, "span_end": null, "passage": "\"\"\"This module includes classes and functions designed specifically for use with the mypy plugin.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom configparser import ConfigParser\nfrom typing i..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3366590440273285, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 20, "path": "docs/plugins/griffe_doclinks.py", "score": 0.3324747383594513, "span_start": null, "span_end": null, "passage": "import ast\nimport re\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Tuple\n\nfrom griffe.dataclasses import Object as GriffeObject\nfrom griffe.extensions import VisitorExtensi..."}], "latency_ms": 3.5333633422851562, "gold_paths": ["pydantic/alias_generators.py"]}
{"qid": "lens_main_symbol_0c5d01a7", "query": "find function __init__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generics.py", "score": 0.4171063303947449, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.40831226110458374, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_dataclasses.py", "score": 0.3932117521762848, "span_start": null, "span_end": null, "passage": "def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -> None:\n        __tracebackhide__ = True\n        s = __dataclass_self__\n        s.__pydantic_validator__.validate_python..."}, {"qid": "", "rank": 4, "path": "pydantic/dataclasses.py", "score": 0.3917386531829834, "span_start": null, "span_end": null, "passage": "def _call_initvar(*args: Any, **kwargs: Any) -> NoReturn:\n        \"\"\"This function does nothing but raise an error that is as similar as possible to what you'd get\n        if you were to try calling `..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_validate_call.py", "score": 0.36800476908683777, "span_start": null, "span_end": null, "passage": "import _generate_schema, _typing_extra\nfrom ._config import ConfigWrapper\n\n\nclass ValidateCallWrapper:\n    \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optiona..."}, {"qid": "", "rank": 6, "path": "pydantic/errors.py", "score": 0.36481308937072754, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, message: str, *, code: PydanticErrorCodes | None) -> None:\n        self.message = message\n        self.code = code\n\n    def __str__(self) -> str:\n        if self.code is No..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3647959232330322, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 8, "path": "pydantic/dataclasses.py", "score": 0.3563225269317627, "span_start": null, "span_end": null, "passage": "Raises:\n        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.355609267950058, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.35129937529563904, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3511527180671692, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 14, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 15, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.3478943109512329, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = s..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 19, "path": "pydantic/root_model.py", "score": 0.3416903018951416, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __pydantic_root_model__ = True\n    __pydantic_private__ = None\n    __pydantic_extra__ = None\n\n    root: RootModelRootType\n\n    def __init_subclass__(cls, **kwargs):\n        extra = cls.model_..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.3403377830982208, "span_start": null, "span_end": null, "passage": "\"\"\"This module includes classes and functions designed specifically for use with the mypy plugin.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom configparser import ConfigParser\nfrom typing i..."}], "latency_ms": 3.6067962646484375, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_3dc10b0f", "query": "find function convert_to_aliases", "results": [{"qid": "", "rank": 1, "path": "pydantic/aliases.py", "score": 0.5801225900650024, "span_start": null, "span_end": null, "passage": "Attributes:\n        choices: A list containing a string or `AliasPath` \"\"\"\n\n    choices: list[str | AliasPath]\n\n    def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -> None..."}, {"qid": "", "rank": 2, "path": "pydantic/aliases.py", "score": 0.5628973841667175, "span_start": null, "span_end": null, "passage": "Attributes:\n        path: A list of string or integer aliases \"\"\"\n\n    path: list[int | str]\n\n    def __init__(self, first_arg: str, *args: str | int) -> None:\n        self.path = [first_arg] + list(a..."}, {"qid": "", "rank": 3, "path": "tests/test_aliases.py", "score": 0.5541108846664429, "span_start": null, "span_end": null, "passage": "The specific alias, if specified, or\n        # 2 The alias, if specified, or\n        # 3 The generated alias (i.e"}, {"qid": "", "rank": 4, "path": "pydantic/v1/utils.py", "score": 0.5397104024887085, "span_start": null, "span_end": null, "passage": "This is mostly useful for ``mypy``, docs:\n    https://mypy.readthedocs.io/en/latest/literal_types.html#exhaustive-checks\n    \"\"\"\n    raise TypeError(msg)\n\n\ndef get_unique_discriminator_alias(all_alias..."}, {"qid": "", "rank": 5, "path": "pydantic/aliases.py", "score": 0.5374274849891663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    alias: Callable[[str], str] | None = None\n    validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None\n    serialization_alias: Callable[[str], str] | None = None\n\n    ..."}, {"qid": "", "rank": 6, "path": "pydantic/aliases.py", "score": 0.5184727907180786, "span_start": null, "span_end": null, "passage": "Returns None if the alias generator is None Raises:\n            TypeError: If the alias generator produces an invalid type \"\"\"\n        alias = None\n        if alias_generator := getattr(self, alias_ki..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5174098014831543, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance computed_field_info: The ComputedFieldInfo instance to which the alias_generator i..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5086308121681213, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance field_info: The FieldInfo instance to which the alias_generator is (maybe) applied..."}, {"qid": "", "rank": 9, "path": "pydantic/aliases.py", "score": 0.5017349720001221, "span_start": null, "span_end": null, "passage": "\"\"\"\n        aliases: list[list[str | int]] = []\n        for c in self.choices:\n            if isinstance(c, AliasPath):\n                aliases.append(c.convert_to_aliases())\n            else:\n       ..."}, {"qid": "", "rank": 10, "path": "pydantic/aliases.py", "score": 0.49736785888671875, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of `{allowed_types}`'\n                )\n        return alias\n\n    def generate_aliases(self, field_name: str) -> tuple[str | None, str | AliasPath | AliasChoi..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.49610328674316406, "span_start": null, "span_end": null, "passage": "- If discriminator fields have different aliases - If discriminator field not of type `Literal`"}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.4764613211154938, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.4764613211154938, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4637549817562103, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n\n        if (\n            computed_field_info.alias_priority is None\n            or computed_field_info.alias_priority <= 1\n            or computed_fiel..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/generics.py", "score": 0.4619649350643158, "span_start": null, "span_end": null, "passage": "if type_args:\n        resolved_type_args = tuple(replace_types(arg, type_map) for arg in type_args)\n        if all_identical(type_args, resolved_type_args):\n            # If all arguments are the same..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.4619649350643158, "span_start": null, "span_end": null, "passage": "if type_args:\n        resolved_type_args = tuple(replace_types(arg, type_map) for arg in type_args)\n        if all_identical(type_args, resolved_type_args):\n            # If all arguments are the same..."}, {"qid": "", "rank": 17, "path": "pydantic/aliases.py", "score": 0.45942163467407227, "span_start": null, "span_end": null, "passage": "\"\"\"\n        v = d\n        for k in self.path:\n            if isinstance(v, str):\n                # disallow indexing into a str, like for AliasPath('x', 0) and x='abc'\n                return PydanticU..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.4591200351715088, "span_start": null, "span_end": null, "passage": "Args:\n            argument: The core schema Returns:\n            The name of the argument \"\"\"\n        name = argument['name']\n        if self.by_alias:\n            alias = argument.get('alias')\n      ..."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.4519053101539612, "span_start": null, "span_end": null, "passage": "it should be `str`, `AliasChoices`, or `AliasPath`')\n\n    if serialization_alias in (_Unset, None) and isinstance(alias, str):\n        serialization_alias = alias\n\n    if validation_alias in (_Unset, ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.44831332564353943, "span_start": null, "span_end": null, "passage": "self.discriminator = discriminator\n\n        # `definitions` should contain a mapping of schema ref to schema for all schemas which might\n        # be referenced by some choice\n        self.definitions..."}], "latency_ms": 3.693103790283203, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_76307c9a", "query": "find function search_dict_for_path", "results": [{"qid": "", "rank": 1, "path": "pydantic/aliases.py", "score": 0.7454957365989685, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.path\n\n    def search_dict_for_path(self, d: dict) -> Any:\n        \"\"\"Searches a dictionary for the path specified by the alias Returns:\n            The value at the specified p..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.5469396114349365, "span_start": null, "span_end": null, "passage": "See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope\n    and suggestion at the end of the next comment by @gvanrossum WARNING 1: it matters exactly where this is calle..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/env_settings.py", "score": 0.49480774998664856, "span_start": null, "span_end": null, "passage": "\"\"\"\n        secrets: Dict[str, Optional[str]] = {}\n\n        if self.secrets_dir is None:\n            return secrets\n\n        secrets_path = Path(self.secrets_dir).expanduser()\n\n        if not secrets_..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators.py", "score": 0.4718397855758667, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if isinstance(tp, tuple):\n        for base in mro_for_bases(tp):\n            attribute = base.__dict__.get(name, _sentinel)\n            if attribute is not _sentinel:\n                attribute..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_config.py", "score": 0.4571916162967682, "span_start": null, "span_end": null, "passage": "Args:\n        config_dict: The input config"}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.45037510991096497, "span_start": null, "span_end": null, "passage": "found_fields: dict[str, PydanticModelField] = {}\n        found_class_vars: dict[str, PydanticModelClassVar] = {}\n        for info in reversed(cls.info.mro[1:-1]):  # 0 is the current class, -2 is Base..."}, {"qid": "", "rank": 7, "path": "tests/check_usage_docs.py", "score": 0.4396197199821472, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport re\nimport sys\nfrom pathlib import Path\n\nROOT_DIR = Path(__file__).parent.parent\nPYDANTIC_DIR = ROOT_DIR / 'pydantic'\nversion_file = PYDANTIC_DIR / 'version.py'\n\n\nversion = re.search(rb\"VER..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_typing_extra.py", "score": 0.42706090211868286, "span_start": null, "span_end": null, "passage": "- If no dict arguments are passed, an attempt is made to use the\n          globals from obj (or the respective module's globals for classes),\n          and these are also used as the locals If the obj..."}, {"qid": "", "rank": 9, "path": "pydantic/main.py", "score": 0.4200442135334015, "span_start": null, "span_end": null, "passage": "# getter(self.__dict__) is much faster than any 'safe' method that accounts\n                    # for missing keys, and wrapping it in a `try` doesn't slow things down much\n                    # in th..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/config.py", "score": 0.4193517863750458, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\ndef get_config(config: Union[ConfigDict, Type[object], None]) -> Type[BaseConfig]:\n    if config is None:\n        return BaseConfig\n\n    else:\n        config_dict = (\n            co..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_validators.py", "score": 0.41124048829078674, "span_start": null, "span_end": null, "passage": "So, for example, the following values of `dotted_path` result in the following returned values:\n    * 'collections': <module 'collections'>\n    * 'collections.abc': <module 'collections.abc'>\n    * 'c..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/utils.py", "score": 0.4089636206626892, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return list(self)\n\n    def values(self) -> List[Any]:\n        return [self[k] for k in self]\n\n    def items(self) -> Iterator[Tuple[str, Any]]:\n        for k in self:\n            yield k, ..."}, {"qid": "", "rank": 13, "path": "tests/test_validate_call.py", "score": 0.4063098728656769, "span_start": null, "span_end": null, "passage": "This test is just to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n    globs = {}\n    exec(\n        \"\"\"\nfrom typing import Iterable\nfrom pydantic import validate_call\n\n@validate..."}, {"qid": "", "rank": 14, "path": "docs/plugins/griffe_doclinks.py", "score": 0.40619707107543945, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file})\\n'\n\n\ndef replace_links(m: re.Match, *, api_link: str) -> str:\n    path_group = m.group(1)\n    if '#' not in path_group:\n        # no head..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/env_settings.py", "score": 0.40366706252098083, "span_start": null, "span_end": null, "passage": "\"\"\"\n    for f in dir_path.iterdir():\n        if f.name == file_name:\n            return f\n        elif not case_sensitive and f.name.lower() == file_name.lower():\n            return f\n    return None"}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_typing_extra.py", "score": 0.40274637937545776, "span_start": null, "span_end": null, "passage": "- If two dict arguments are passed, they specify globals and\n          locals, respectively \"\"\"\n        if getattr(obj, '__no_type_check__', None):\n            return {}\n        # Classes require a sp..."}, {"qid": "", "rank": 17, "path": "docs/plugins/griffe_doclinks.py", "score": 0.3977585434913635, "span_start": null, "span_end": null, "passage": "import ast\nimport re\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Tuple\n\nfrom griffe.dataclasses import Object as GriffeObject\nfrom griffe.extensions import VisitorExtensi..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.39311105012893677, "span_start": null, "span_end": null, "passage": "pass\n            else:\n                block_lines = inspect.getblock(lines[lnum - 1 :])\n                dedent_source = _dedent_source_lines(block_lines)\n                try:\n                    bloc..."}, {"qid": "", "rank": 19, "path": "pydantic/aliases.py", "score": 0.39243775606155396, "span_start": null, "span_end": null, "passage": "\"\"\"\n        v = d\n        for k in self.path:\n            if isinstance(v, str):\n                # disallow indexing into a str, like for AliasPath('x', 0) and x='abc'\n                return PydanticU..."}, {"qid": "", "rank": 20, "path": "pydantic/main.py", "score": 0.3910330533981323, "span_start": null, "span_end": null, "passage": "\"\"\"\n        m = cls.__new__(cls)\n        fields_values: dict[str, Any] = {}\n        fields_set = set()\n\n        for name, field in cls.model_fields.items():\n            if field.alias is not None and ..."}], "latency_ms": 4.352569580078125, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_0c5d01a7", "query": "find function __init__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generics.py", "score": 0.4171063303947449, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.40831226110458374, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_dataclasses.py", "score": 0.3932117521762848, "span_start": null, "span_end": null, "passage": "def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -> None:\n        __tracebackhide__ = True\n        s = __dataclass_self__\n        s.__pydantic_validator__.validate_python..."}, {"qid": "", "rank": 4, "path": "pydantic/dataclasses.py", "score": 0.3917386531829834, "span_start": null, "span_end": null, "passage": "def _call_initvar(*args: Any, **kwargs: Any) -> NoReturn:\n        \"\"\"This function does nothing but raise an error that is as similar as possible to what you'd get\n        if you were to try calling `..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_validate_call.py", "score": 0.36800476908683777, "span_start": null, "span_end": null, "passage": "import _generate_schema, _typing_extra\nfrom ._config import ConfigWrapper\n\n\nclass ValidateCallWrapper:\n    \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optiona..."}, {"qid": "", "rank": 6, "path": "pydantic/errors.py", "score": 0.36481308937072754, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, message: str, *, code: PydanticErrorCodes | None) -> None:\n        self.message = message\n        self.code = code\n\n    def __str__(self) -> str:\n        if self.code is No..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3647959232330322, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 8, "path": "pydantic/dataclasses.py", "score": 0.3563225269317627, "span_start": null, "span_end": null, "passage": "Raises:\n        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.355609267950058, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.35129937529563904, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3511527180671692, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 14, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 15, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.3478943109512329, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = s..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 19, "path": "pydantic/root_model.py", "score": 0.3416903018951416, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __pydantic_root_model__ = True\n    __pydantic_private__ = None\n    __pydantic_extra__ = None\n\n    root: RootModelRootType\n\n    def __init_subclass__(cls, **kwargs):\n        extra = cls.model_..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.3403377830982208, "span_start": null, "span_end": null, "passage": "\"\"\"This module includes classes and functions designed specifically for use with the mypy plugin.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom configparser import ConfigParser\nfrom typing i..."}], "latency_ms": 5.509614944458008, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_3dc10b0f", "query": "find function convert_to_aliases", "results": [{"qid": "", "rank": 1, "path": "pydantic/aliases.py", "score": 0.5801225900650024, "span_start": null, "span_end": null, "passage": "Attributes:\n        choices: A list containing a string or `AliasPath` \"\"\"\n\n    choices: list[str | AliasPath]\n\n    def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -> None..."}, {"qid": "", "rank": 2, "path": "pydantic/aliases.py", "score": 0.5628973841667175, "span_start": null, "span_end": null, "passage": "Attributes:\n        path: A list of string or integer aliases \"\"\"\n\n    path: list[int | str]\n\n    def __init__(self, first_arg: str, *args: str | int) -> None:\n        self.path = [first_arg] + list(a..."}, {"qid": "", "rank": 3, "path": "tests/test_aliases.py", "score": 0.5541108846664429, "span_start": null, "span_end": null, "passage": "The specific alias, if specified, or\n        # 2 The alias, if specified, or\n        # 3 The generated alias (i.e"}, {"qid": "", "rank": 4, "path": "pydantic/v1/utils.py", "score": 0.5397104024887085, "span_start": null, "span_end": null, "passage": "This is mostly useful for ``mypy``, docs:\n    https://mypy.readthedocs.io/en/latest/literal_types.html#exhaustive-checks\n    \"\"\"\n    raise TypeError(msg)\n\n\ndef get_unique_discriminator_alias(all_alias..."}, {"qid": "", "rank": 5, "path": "pydantic/aliases.py", "score": 0.5374274849891663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    alias: Callable[[str], str] | None = None\n    validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None\n    serialization_alias: Callable[[str], str] | None = None\n\n    ..."}, {"qid": "", "rank": 6, "path": "pydantic/aliases.py", "score": 0.5184727907180786, "span_start": null, "span_end": null, "passage": "Returns None if the alias generator is None Raises:\n            TypeError: If the alias generator produces an invalid type \"\"\"\n        alias = None\n        if alias_generator := getattr(self, alias_ki..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5174098014831543, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance computed_field_info: The ComputedFieldInfo instance to which the alias_generator i..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5086308121681213, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance field_info: The FieldInfo instance to which the alias_generator is (maybe) applied..."}, {"qid": "", "rank": 9, "path": "pydantic/aliases.py", "score": 0.5017349720001221, "span_start": null, "span_end": null, "passage": "\"\"\"\n        aliases: list[list[str | int]] = []\n        for c in self.choices:\n            if isinstance(c, AliasPath):\n                aliases.append(c.convert_to_aliases())\n            else:\n       ..."}, {"qid": "", "rank": 10, "path": "pydantic/aliases.py", "score": 0.49736785888671875, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of `{allowed_types}`'\n                )\n        return alias\n\n    def generate_aliases(self, field_name: str) -> tuple[str | None, str | AliasPath | AliasChoi..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.49610328674316406, "span_start": null, "span_end": null, "passage": "- If discriminator fields have different aliases - If discriminator field not of type `Literal`"}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.4764613211154938, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.4764613211154938, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4637549817562103, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n\n        if (\n            computed_field_info.alias_priority is None\n            or computed_field_info.alias_priority <= 1\n            or computed_fiel..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/generics.py", "score": 0.4619649350643158, "span_start": null, "span_end": null, "passage": "if type_args:\n        resolved_type_args = tuple(replace_types(arg, type_map) for arg in type_args)\n        if all_identical(type_args, resolved_type_args):\n            # If all arguments are the same..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.4619649350643158, "span_start": null, "span_end": null, "passage": "if type_args:\n        resolved_type_args = tuple(replace_types(arg, type_map) for arg in type_args)\n        if all_identical(type_args, resolved_type_args):\n            # If all arguments are the same..."}, {"qid": "", "rank": 17, "path": "pydantic/aliases.py", "score": 0.45942163467407227, "span_start": null, "span_end": null, "passage": "\"\"\"\n        v = d\n        for k in self.path:\n            if isinstance(v, str):\n                # disallow indexing into a str, like for AliasPath('x', 0) and x='abc'\n                return PydanticU..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.4591200351715088, "span_start": null, "span_end": null, "passage": "Args:\n            argument: The core schema Returns:\n            The name of the argument \"\"\"\n        name = argument['name']\n        if self.by_alias:\n            alias = argument.get('alias')\n      ..."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.4519053101539612, "span_start": null, "span_end": null, "passage": "it should be `str`, `AliasChoices`, or `AliasPath`')\n\n    if serialization_alias in (_Unset, None) and isinstance(alias, str):\n        serialization_alias = alias\n\n    if validation_alias in (_Unset, ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.44831332564353943, "span_start": null, "span_end": null, "passage": "self.discriminator = discriminator\n\n        # `definitions` should contain a mapping of schema ref to schema for all schemas which might\n        # be referenced by some choice\n        self.definitions..."}], "latency_ms": 4.083156585693359, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_1bec8db8", "query": "find function _generate_alias", "results": [{"qid": "", "rank": 1, "path": "tests/test_aliases.py", "score": 0.6273165345191956, "span_start": null, "span_end": null, "passage": "The specific alias, if specified, or\n        # 2 The alias, if specified, or\n        # 3 The generated alias (i.e"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6222851276397705, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance computed_field_info: The ComputedFieldInfo instance to which the alias_generator i..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6110566854476929, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance field_info: The FieldInfo instance to which the alias_generator is (maybe) applied..."}, {"qid": "", "rank": 4, "path": "pydantic/aliases.py", "score": 0.5678950548171997, "span_start": null, "span_end": null, "passage": "Returns None if the alias generator is None Raises:\n            TypeError: If the alias generator produces an invalid type \"\"\"\n        alias = None\n        if alias_generator := getattr(self, alias_ki..."}, {"qid": "", "rank": 5, "path": "pydantic/aliases.py", "score": 0.5515090823173523, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of `{allowed_types}`'\n                )\n        return alias\n\n    def generate_aliases(self, field_name: str) -> tuple[str | None, str | AliasPath | AliasChoi..."}, {"qid": "", "rank": 6, "path": "pydantic/aliases.py", "score": 0.5503749847412109, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    alias: Callable[[str], str] | None = None\n    validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None\n    serialization_alias: Callable[[str], str] | None = None\n\n    ..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generate_schema.py", "score": 0.541598379611969, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n\n        if (\n            computed_field_info.alias_priority is None\n            or computed_field_info.alias_priority <= 1\n            or computed_fiel..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/mypy.py", "score": 0.515358567237854, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 9, "path": "pydantic/mypy.py", "score": 0.515358567237854, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5151407718658447, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n        if (\n            field_info.alias_priority is None\n            or field_info.alias_priority <= 1\n            or field_info.alias is None\n       ..."}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.5043287873268127, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not config.populate_by_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_extra:\n       ..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.4987015128135681, "span_start": null, "span_end": null, "passage": "This will be called when `warn_required_dynamic_aliases=True`"}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.4934529662132263, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not config.allow_population_by_field_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_..."}, {"qid": "", "rank": 14, "path": "pydantic/aliases.py", "score": 0.48605653643608093, "span_start": null, "span_end": null, "passage": "\"\"\"\n        aliases: list[list[str | int]] = []\n        for c in self.choices:\n            if isinstance(c, AliasPath):\n                aliases.append(c.convert_to_aliases())\n            else:\n       ..."}, {"qid": "", "rank": 15, "path": "pydantic/mypy.py", "score": 0.4788316488265991, "span_start": null, "span_end": null, "passage": "if name is None or name == 'default':\n                    return arg.__class__ is not EllipsisExpr\n                if name == 'default_factory':\n                    return not (isinstance(arg, NameExp..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generate_schema.py", "score": 0.47489410638809204, "span_start": null, "span_end": null, "passage": "Use case: serialization_alias (argument a) and alias (argument b) are both defined, and serialization_alias is '' This function will return serialization_alias, which is the first argument, even thoug..."}, {"qid": "", "rank": 17, "path": "pydantic/aliases.py", "score": 0.47008049488067627, "span_start": null, "span_end": null, "passage": "Attributes:\n        choices: A list containing a string or `AliasPath` \"\"\"\n\n    choices: list[str | AliasPath]\n\n    def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -> None..."}, {"qid": "", "rank": 18, "path": "pydantic/aliases.py", "score": 0.470063716173172, "span_start": null, "span_end": null, "passage": "\"\"\"\n        alias = self._generate_alias('alias', (str,), field_name)\n        validation_alias = self._generate_alias('validation_alias', (str, AliasChoices, AliasPath), field_name)\n        serializat..."}, {"qid": "", "rank": 19, "path": "pydantic/config.py", "score": 0.46951809525489807, "span_start": null, "span_end": null, "passage": "If you want to use different alias generators for validation and serialization, you can use\n    [`AliasGenerator`][pydantic.aliases.AliasGenerator] instead If data source field names do not match your..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/utils.py", "score": 0.4659951329231262, "span_start": null, "span_end": null, "passage": "This is mostly useful for ``mypy``, docs:\n    https://mypy.readthedocs.io/en/latest/literal_types.html#exhaustive-checks\n    \"\"\"\n    raise TypeError(msg)\n\n\ndef get_unique_discriminator_alias(all_alias..."}], "latency_ms": 3.960847854614258, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_9b500636", "query": "find function generate_aliases", "results": [{"qid": "", "rank": 1, "path": "tests/test_aliases.py", "score": 0.6211633682250977, "span_start": null, "span_end": null, "passage": "The specific alias, if specified, or\n        # 2 The alias, if specified, or\n        # 3 The generated alias (i.e"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6198732852935791, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance computed_field_info: The ComputedFieldInfo instance to which the alias_generator i..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6026747226715088, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance field_info: The FieldInfo instance to which the alias_generator is (maybe) applied..."}, {"qid": "", "rank": 4, "path": "pydantic/aliases.py", "score": 0.5831753015518188, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    alias: Callable[[str], str] | None = None\n    validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None\n    serialization_alias: Callable[[str], str] | None = None\n\n    ..."}, {"qid": "", "rank": 5, "path": "pydantic/aliases.py", "score": 0.5827172994613647, "span_start": null, "span_end": null, "passage": "Returns None if the alias generator is None Raises:\n            TypeError: If the alias generator produces an invalid type \"\"\"\n        alias = None\n        if alias_generator := getattr(self, alias_ki..."}, {"qid": "", "rank": 6, "path": "pydantic/aliases.py", "score": 0.5789595246315002, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of `{allowed_types}`'\n                )\n        return alias\n\n    def generate_aliases(self, field_name: str) -> tuple[str | None, str | AliasPath | AliasChoi..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/utils.py", "score": 0.5554780960083008, "span_start": null, "span_end": null, "passage": "This is mostly useful for ``mypy``, docs:\n    https://mypy.readthedocs.io/en/latest/literal_types.html#exhaustive-checks\n    \"\"\"\n    raise TypeError(msg)\n\n\ndef get_unique_discriminator_alias(all_alias..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5435997247695923, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n\n        if (\n            computed_field_info.alias_priority is None\n            or computed_field_info.alias_priority <= 1\n            or computed_fiel..."}, {"qid": "", "rank": 9, "path": "pydantic/aliases.py", "score": 0.5319931507110596, "span_start": null, "span_end": null, "passage": "\"\"\"\n        aliases: list[list[str | int]] = []\n        for c in self.choices:\n            if isinstance(c, AliasPath):\n                aliases.append(c.convert_to_aliases())\n            else:\n       ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.5278868675231934, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not config.populate_by_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_extra:\n       ..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/mypy.py", "score": 0.5231073498725891, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.5231073498725891, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 13, "path": "pydantic/aliases.py", "score": 0.5217505097389221, "span_start": null, "span_end": null, "passage": "Attributes:\n        choices: A list containing a string or `AliasPath` \"\"\"\n\n    choices: list[str | AliasPath]\n\n    def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -> None..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5167443752288818, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n        if (\n            field_info.alias_priority is None\n            or field_info.alias_priority <= 1\n            or field_info.alias is None\n       ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/mypy.py", "score": 0.5082098841667175, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not config.allow_population_by_field_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_..."}, {"qid": "", "rank": 16, "path": "pydantic/aliases.py", "score": 0.5065757036209106, "span_start": null, "span_end": null, "passage": "Attributes:\n        path: A list of string or integer aliases \"\"\"\n\n    path: list[int | str]\n\n    def __init__(self, first_arg: str, *args: str | int) -> None:\n        self.path = [first_arg] + list(a..."}, {"qid": "", "rank": 17, "path": "pydantic/config.py", "score": 0.5035153031349182, "span_start": null, "span_end": null, "passage": "If you want to use different alias generators for validation and serialization, you can use\n    [`AliasGenerator`][pydantic.aliases.AliasGenerator] instead If data source field names do not match your..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4935283064842224, "span_start": null, "span_end": null, "passage": "- If discriminator fields have different aliases - If discriminator field not of type `Literal`"}, {"qid": "", "rank": 19, "path": "pydantic/mypy.py", "score": 0.4923560619354248, "span_start": null, "span_end": null, "passage": "if name is None or name == 'default':\n                    return arg.__class__ is not EllipsisExpr\n                if name == 'default_factory':\n                    return not (isinstance(arg, NameExp..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.49085789918899536, "span_start": null, "span_end": null, "passage": "This will be called when `warn_required_dynamic_aliases=True`"}], "latency_ms": 3.824472427368164, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_f76f2259", "query": "find class AliasPath", "results": [{"qid": "", "rank": 1, "path": "pydantic/aliases.py", "score": 0.490766704082489, "span_start": null, "span_end": null, "passage": "\"\"\"Support for alias configurations.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing import Any, Callable, Literal\n\nfrom pydantic_core import PydanticUndefined\n\nfrom ._internal ..."}, {"qid": "", "rank": 2, "path": "pydantic/aliases.py", "score": 0.4891885817050934, "span_start": null, "span_end": null, "passage": "\"\"\"\n        v = d\n        for k in self.path:\n            if isinstance(v, str):\n                # disallow indexing into a str, like for AliasPath('x', 0) and x='abc'\n                return PydanticU..."}, {"qid": "", "rank": 3, "path": "pydantic/aliases.py", "score": 0.47084322571754456, "span_start": null, "span_end": null, "passage": "\"\"\"\n        aliases: list[list[str | int]] = []\n        for c in self.choices:\n            if isinstance(c, AliasPath):\n                aliases.append(c.convert_to_aliases())\n            else:\n       ..."}, {"qid": "", "rank": 4, "path": "pydantic/aliases.py", "score": 0.44473838806152344, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.path\n\n    def search_dict_for_path(self, d: dict) -> Any:\n        \"\"\"Searches a dictionary for the path specified by the alias Returns:\n            The value at the specified p..."}, {"qid": "", "rank": 5, "path": "tests/test_aliases.py", "score": 0.4437314569950104, "span_start": null, "span_end": null, "passage": "The specific alias, if specified, or\n        # 2 The alias, if specified, or\n        # 3 The generated alias (i.e"}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_decorators.py", "score": 0.42108526825904846, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 7, "path": "pydantic/aliases.py", "score": 0.4145960807800293, "span_start": null, "span_end": null, "passage": "Returns None if the alias generator is None Raises:\n            TypeError: If the alias generator produces an invalid type \"\"\"\n        alias = None\n        if alias_generator := getattr(self, alias_ki..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/utils.py", "score": 0.4083574414253235, "span_start": null, "span_end": null, "passage": "Import a dotted module path and return the attribute/class designated by the\n    last name in the path Raise ImportError if the import fails"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4060934782028198, "span_start": null, "span_end": null, "passage": "- If discriminator fields have different aliases - If discriminator field not of type `Literal`"}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.4006825089454651, "span_start": null, "span_end": null, "passage": "if name is None or name == 'default':\n                    return arg.__class__ is not EllipsisExpr\n                if name == 'default_factory':\n                    return not (isinstance(arg, NameExp..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3813222050666809, "span_start": null, "span_end": null, "passage": "self.discriminator = discriminator\n\n        # `definitions` should contain a mapping of schema ref to schema for all schemas which might\n        # be referenced by some choice\n        self.definitions..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_generate_schema.py", "score": 0.37821653485298157, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n\n        if (\n            computed_field_info.alias_priority is None\n            or computed_field_info.alias_priority <= 1\n            or computed_fiel..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_generate_schema.py", "score": 0.37719395756721497, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance field_info: The FieldInfo instance to which the alias_generator is (maybe) applied..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.3717048764228821, "span_start": null, "span_end": null, "passage": "for alias_path in schema['discriminator']:\n                if not isinstance(alias_path, list):\n                    break  # this means that the discriminator is not a list of alias paths\n            ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generics.py", "score": 0.36913442611694336, "span_start": null, "span_end": null, "passage": "This is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,\n    since __parameters__ of (nested) generic BaseModel subclasses won't show up in that list"}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.3659697473049164, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 17, "path": "pydantic/mypy.py", "score": 0.3659697473049164, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_model_construction.py", "score": 0.36475083231925964, "span_start": null, "span_end": null, "passage": "Args:\n        cls: BaseModel or dataclass bases: Parents of the class, generally `cls.__bases__` config_wrapper: The config wrapper instance types_namespace: Optional extra namespace to look for types..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/mypy.py", "score": 0.36444199085235596, "span_start": null, "span_end": null, "passage": "if node.is_classvar:\n                continue\n\n            is_required = self.get_is_required(cls, stmt, lhs)\n            alias, has_dynamic_alias = self.get_alias_info(stmt)\n            if (\n        ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3633522391319275, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n        if (\n            field_info.alias_priority is None\n            or field_info.alias_priority <= 1\n            or field_info.alias is None\n       ..."}], "latency_ms": 4.0111541748046875, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_e8db5eb6", "query": "find class AliasChoices", "results": [{"qid": "", "rank": 1, "path": "pydantic/aliases.py", "score": 0.5389497876167297, "span_start": null, "span_end": null, "passage": "\"\"\"\n        aliases: list[list[str | int]] = []\n        for c in self.choices:\n            if isinstance(c, AliasPath):\n                aliases.append(c.convert_to_aliases())\n            else:\n       ..."}, {"qid": "", "rank": 2, "path": "pydantic/aliases.py", "score": 0.5253848433494568, "span_start": null, "span_end": null, "passage": "\"\"\"Support for alias configurations.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing import Any, Callable, Literal\n\nfrom pydantic_core import PydanticUndefined\n\nfrom ._internal ..."}, {"qid": "", "rank": 3, "path": "pydantic/aliases.py", "score": 0.5138061046600342, "span_start": null, "span_end": null, "passage": "\"\"\"\n        v = d\n        for k in self.path:\n            if isinstance(v, str):\n                # disallow indexing into a str, like for AliasPath('x', 0) and x='abc'\n                return PydanticU..."}, {"qid": "", "rank": 4, "path": "tests/test_aliases.py", "score": 0.501471996307373, "span_start": null, "span_end": null, "passage": "The specific alias, if specified, or\n        # 2 The alias, if specified, or\n        # 3 The generated alias (i.e"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4832664728164673, "span_start": null, "span_end": null, "passage": "- If discriminator fields have different aliases - If discriminator field not of type `Literal`"}, {"qid": "", "rank": 6, "path": "pydantic/aliases.py", "score": 0.45529159903526306, "span_start": null, "span_end": null, "passage": "Returns None if the alias generator is None Raises:\n            TypeError: If the alias generator produces an invalid type \"\"\"\n        alias = None\n        if alias_generator := getattr(self, alias_ki..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4549921751022339, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n\n        if (\n            computed_field_info.alias_priority is None\n            or computed_field_info.alias_priority <= 1\n            or computed_fiel..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4511968493461609, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n        if (\n            field_info.alias_priority is None\n            or field_info.alias_priority <= 1\n            or field_info.alias is None\n       ..."}, {"qid": "", "rank": 9, "path": "pydantic/mypy.py", "score": 0.44852328300476074, "span_start": null, "span_end": null, "passage": "if name is None or name == 'default':\n                    return arg.__class__ is not EllipsisExpr\n                if name == 'default_factory':\n                    return not (isinstance(arg, NameExp..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generics.py", "score": 0.4420664310455322, "span_start": null, "span_end": null, "passage": "This is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,\n    since __parameters__ of (nested) generic BaseModel subclasses won't show up in that list"}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.43842893838882446, "span_start": null, "span_end": null, "passage": "self.discriminator = discriminator\n\n        # `definitions` should contain a mapping of schema ref to schema for all schemas which might\n        # be referenced by some choice\n        self.definitions..."}, {"qid": "", "rank": 12, "path": "pydantic/aliases.py", "score": 0.42769724130630493, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    alias: Callable[[str], str] | None = None\n    validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None\n    serialization_alias: Callable[[str], str] | None = None\n\n    ..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/utils.py", "score": 0.4259969890117645, "span_start": null, "span_end": null, "passage": "This is mostly useful for ``mypy``, docs:\n    https://mypy.readthedocs.io/en/latest/literal_types.html#exhaustive-checks\n    \"\"\"\n    raise TypeError(msg)\n\n\ndef get_unique_discriminator_alias(all_alias..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/mypy.py", "score": 0.4229578971862793, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if isinstance(type_, AnyType):\n            # Annotated as Any\n            return True\n        if isinstance(type_, UnionType) and any(\n            isinstance(item, NoneType) or isinstance(..."}, {"qid": "", "rank": 15, "path": "pydantic/fields.py", "score": 0.41570350527763367, "span_start": null, "span_end": null, "passage": "it should be `str`, `AliasChoices`, or `AliasPath`')\n\n    if serialization_alias in (_Unset, None) and isinstance(alias, str):\n        serialization_alias = alias\n\n    if validation_alias in (_Unset, ..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.41404032707214355, "span_start": null, "span_end": null, "passage": "for alias_path in schema['discriminator']:\n                if not isinstance(alias_path, list):\n                    break  # this means that the discriminator is not a list of alias paths\n            ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/config.py", "score": 0.408224880695343, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        fields_value = cls.fields.get(name)\n\n        if isinstance(fields_value, str):\n            field_info: Dict[str, Any] = {'alias': fields_value}\n        elif isinstance(fields_value, dict)..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4045569896697998, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance field_info: The FieldInfo instance to which the alias_generator is (maybe) applied..."}, {"qid": "", "rank": 19, "path": "tests/test_dataclasses.py", "score": 0.4029621183872223, "span_start": null, "span_end": null, "passage": "This is essentially a limitation of typing._GenericAlias"}, {"qid": "", "rank": 20, "path": "pydantic/aliases.py", "score": 0.402243047952652, "span_start": null, "span_end": null, "passage": "Attributes:\n        choices: A list containing a string or `AliasPath` \"\"\"\n\n    choices: list[str | AliasPath]\n\n    def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -> None..."}], "latency_ms": 3.971099853515625, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_c4f077f6", "query": "find class AliasGenerator", "results": [{"qid": "", "rank": 1, "path": "pydantic/aliases.py", "score": 0.5337150692939758, "span_start": null, "span_end": null, "passage": "\"\"\"\n        aliases: list[list[str | int]] = []\n        for c in self.choices:\n            if isinstance(c, AliasPath):\n                aliases.append(c.convert_to_aliases())\n            else:\n       ..."}, {"qid": "", "rank": 2, "path": "pydantic/aliases.py", "score": 0.5025106072425842, "span_start": null, "span_end": null, "passage": "Returns None if the alias generator is None Raises:\n            TypeError: If the alias generator produces an invalid type \"\"\"\n        alias = None\n        if alias_generator := getattr(self, alias_ki..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.49820101261138916, "span_start": null, "span_end": null, "passage": "- If discriminator fields have different aliases - If discriminator field not of type `Literal`"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generate_schema.py", "score": 0.48810210824012756, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n\n        if (\n            computed_field_info.alias_priority is None\n            or computed_field_info.alias_priority <= 1\n            or computed_fiel..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generate_schema.py", "score": 0.48555147647857666, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n        if (\n            field_info.alias_priority is None\n            or field_info.alias_priority <= 1\n            or field_info.alias is None\n       ..."}, {"qid": "", "rank": 6, "path": "tests/test_aliases.py", "score": 0.4850987195968628, "span_start": null, "span_end": null, "passage": "The specific alias, if specified, or\n        # 2 The alias, if specified, or\n        # 3 The generated alias (i.e"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generate_schema.py", "score": 0.46512851119041443, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance field_info: The FieldInfo instance to which the alias_generator is (maybe) applied..."}, {"qid": "", "rank": 8, "path": "pydantic/aliases.py", "score": 0.45630306005477905, "span_start": null, "span_end": null, "passage": "\"\"\"Support for alias configurations.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing import Any, Callable, Literal\n\nfrom pydantic_core import PydanticUndefined\n\nfrom ._internal ..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generate_schema.py", "score": 0.44320443272590637, "span_start": null, "span_end": null, "passage": "Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance computed_field_info: The ComputedFieldInfo instance to which the alias_generator i..."}, {"qid": "", "rank": 10, "path": "pydantic/aliases.py", "score": 0.44237372279167175, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of `{allowed_types}`'\n                )\n        return alias\n\n    def generate_aliases(self, field_name: str) -> tuple[str | None, str | AliasPath | AliasChoi..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generics.py", "score": 0.4409068524837494, "span_start": null, "span_end": null, "passage": "This is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,\n    since __parameters__ of (nested) generic BaseModel subclasses won't show up in that list"}, {"qid": "", "rank": 12, "path": "tests/test_aliases.py", "score": 0.4389675259590149, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of'\n        ):\n\n            class Foo(BaseModel):\n                a: str\n\n                model_config = ConfigDict(alias_generator=AliasGenerator(**{alias_ki..."}, {"qid": "", "rank": 13, "path": "pydantic/aliases.py", "score": 0.43552058935165405, "span_start": null, "span_end": null, "passage": "\"\"\"\n        v = d\n        for k in self.path:\n            if isinstance(v, str):\n                # disallow indexing into a str, like for AliasPath('x', 0) and x='abc'\n                return PydanticU..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4275069236755371, "span_start": null, "span_end": null, "passage": "self.discriminator = discriminator\n\n        # `definitions` should contain a mapping of schema ref to schema for all schemas which might\n        # be referenced by some choice\n        self.definitions..."}, {"qid": "", "rank": 15, "path": "pydantic/mypy.py", "score": 0.42657601833343506, "span_start": null, "span_end": null, "passage": "if name is None or name == 'default':\n                    return arg.__class__ is not EllipsisExpr\n                if name == 'default_factory':\n                    return not (isinstance(arg, NameExp..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/utils.py", "score": 0.4203466773033142, "span_start": null, "span_end": null, "passage": "This is mostly useful for ``mypy``, docs:\n    https://mypy.readthedocs.io/en/latest/literal_types.html#exhaustive-checks\n    \"\"\"\n    raise TypeError(msg)\n\n\ndef get_unique_discriminator_alias(all_alias..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.41607579588890076, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if isinstance(type_, AnyType):\n            # Annotated as Any\n            return True\n        if isinstance(type_, UnionType) and any(\n            isinstance(item, NoneType) or isinstance(..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/generics.py", "score": 0.41272327303886414, "span_start": null, "span_end": null, "passage": "\"\"\"\n        param_names = [display_as_type(param) for param in params]\n        params_component = ', '.join(param_names)\n        return f'{cls.__name__}[{params_component}]'\n\n    @classmethod\n    def ..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_decorators.py", "score": 0.4043586850166321, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 20, "path": "tests/test_dataclasses.py", "score": 0.40031975507736206, "span_start": null, "span_end": null, "passage": "This is essentially a limitation of typing._GenericAlias"}], "latency_ms": 4.044532775878906, "gold_paths": ["pydantic/aliases.py"]}
{"qid": "lens_main_symbol_8b32ffac", "query": "find function __call__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generics.py", "score": 0.4525706470012665, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.42853912711143494, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_decorators.py", "score": 0.4089837968349457, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_core_utils.py", "score": 0.3968643546104431, "span_start": null, "span_end": null, "passage": "Args:\n        schema (core_schema.CoreSchema): The CoreSchema to process, it will not be modified f (Walk): A function to apply This function takes two arguments:\n          1 The current CoreSchema th..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generics.py", "score": 0.3883066773414612, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except Attribu..."}, {"qid": "", "rank": 6, "path": "pydantic/type_adapter.py", "score": 0.38780641555786133, "span_start": null, "span_end": null, "passage": "On the other hand this function can be called with arbitrary objects,\n    including type aliases, where `__module__` (always `typing.py`) is not useful So instead we look at the globals in our parent ..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.38477450609207153, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  ..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.3755843937397003, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 9, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.3752177655696869, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 10, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.3752177655696869, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3717053532600403, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.3707035481929779, "span_start": null, "span_end": null, "passage": "first = [Argument(Var('__pydantic_self__'), self_type, None, ARG_POS)]\n    args = first + args\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/errors.py", "score": 0.36739885807037354, "span_start": null, "span_end": null, "passage": "Note: the callable can't be a lambda as pickle looks in the namespace to find it\n    \"\"\"\n    return cls(**ctx)\n\n\nclass PydanticErrorMixin:\n    code: str\n    msg_template: str\n\n    def __init__(self, *..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.3585675358772278, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    cls_ref: str\n    cls_var_name: str\n    func: Callable[..., Any]\n    shim: Callable[[Any], Any] | None\n    info: DecoratorInfoType\n\n    @staticmethod\n    def build(\n        cls_: Any,\n        ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_decorators.py", "score": 0.35664159059524536, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    wrapped: DecoratedType[ReturnType]\n    decorator_info: DecoratorInfo\n    shim: Callable[[Callable[..., Any]], Callable[..., Any]] | None = None\n\n    def __post_init__(self):\n        for attr ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_decorators.py", "score": 0.3551378548145294, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.35074174404144287, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.35074174404144287, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 19, "path": "pydantic/validate_call_decorator.py", "score": 0.35063636302948, "span_start": null, "span_end": null, "passage": "\"\"\"Decorator for validating function calls.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport functools\nfrom typing import TYPE_CHECKING, Any, Callable, TypeVar, overload\n\nfrom ._internal..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/mypy.py", "score": 0.3476901948451996, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    self_ty..."}], "latency_ms": 3.862619400024414, "gold_paths": ["pydantic/annotated_handlers.py"]}
{"qid": "lens_main_symbol_82752dd1", "query": "find function resolve_ref_schema", "results": [{"qid": "", "rank": 1, "path": "pydantic/annotated_handlers.py", "score": 0.7184858322143555, "span_start": null, "span_end": null, "passage": "Returns:\n            CoreSchema: The `pydantic-core` CoreSchema generated \"\"\"\n        raise NotImplementedError\n\n    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema, /) -> core_s..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.7054678201675415, "span_start": null, "span_end": null, "passage": "Args:\n            maybe_ref_schema: The input core schema that may contains reference Returns:\n            Resolved core schema Raises:\n            LookupError: If it can't find the definition for ref..."}, {"qid": "", "rank": 3, "path": "pydantic/annotated_handlers.py", "score": 0.6943023800849915, "span_start": null, "span_end": null, "passage": "\"\"\"\n        raise NotImplementedError\n\n    def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue, /) -> JsonSchemaValue:\n        \"\"\"Get the real schema for a `{\"$ref\": ...}` schema If th..."}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.6594093441963196, "span_start": null, "span_end": null, "passage": "Args:\n            json_schema: The schema to resolve Returns:\n            The resolved schema"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.6464088559150696, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if maybe_ref_schema['type'] == 'definition-ref':\n            ref = maybe_ref_schema['schema_ref']\n            if ref not in self._generate_schema.defs.definitions:\n                raise Lo..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.605292558670044, "span_start": null, "span_end": null, "passage": "This returns the input json schema if there is no `$ref` in json schema Args:\n            maybe_ref_json_schema: The input json schema that may contains `$ref` Returns:\n            Resolved json schem..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5923426151275635, "span_start": null, "span_end": null, "passage": "At present the following types can be named/recursive:\n\n        - BaseModel\n        - Dataclasses\n        - TypedDict\n        - TypeAliasType\n        \"\"\"\n        ref = get_type_ref(tp)\n        # retur..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.5881505012512207, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if '$ref' not in maybe_ref_json_schema:\n            return maybe_ref_json_schema\n        ref = maybe_ref_json_schema['$ref']\n        json_schema = self.generate_json_schema.get_schema_from..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5871184468269348, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def get_ref(s: CoreSchema) -> str:\n            return s['ref']  # type: ignore\n\n        if schema['type'] == 'definitions':\n            self.defs.definitions.update({get_ref(s): s for s i..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_core_utils.py", "score": 0.5864566564559937, "span_start": null, "span_end": null, "passage": "arg_ref = f'{arg}:str-{id(arg)}'\n        else:\n            arg_ref = f'{_repr.display_as_type(arg)}:{id(arg)}'\n        arg_refs.append(arg_ref)\n    if arg_refs:\n        type_ref = f'{type_ref}[{\",\".jo..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/schema.py", "score": 0.5854016542434692, "span_start": null, "span_end": null, "passage": "The resulting generated schemas will still be at the\n      top-level key ``definitions``, so you can extract them from there But all the references will have the set\n      prefix :param ref_template: ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/schema.py", "score": 0.580703854560852, "span_start": null, "span_end": null, "passage": ":param known_models: used to solve circular references\n    :return: tuple of the schema for this field and additional definitions\n    \"\"\"\n    s, schema_overrides = get_field_info_schema(field)\n\n    va..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5754189491271973, "span_start": null, "span_end": null, "passage": "During this recursion, we allow references to be resolved from the definitions\n    # that are originally present on the original, outermost `schema` Before `apply_discriminators` is called,\n    # `sim..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_core_utils.py", "score": 0.5713156461715698, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return f(schema.copy(), _dispatch)\n\n\ndef simplify_schema_references(schema: core_schema.CoreSchema) -> core_schema.CoreSchema:  # noqa: C901\n    definitions: dict[str, core_schema.CoreSchema] ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_core_utils.py", "score": 0.5627737045288086, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return s.get('ref', None)\n\n\ndef collect_definitions(schema: core_schema.CoreSchema) -> dict[str, core_schema.CoreSchema]:\n    defs: dict[str, CoreSchema] = {}\n\n    def _record_valid_refs(s: co..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.546841561794281, "span_start": null, "span_end": null, "passage": "Args:\n            core_ref: The core reference to get the definitions reference for Returns:\n            A tuple of the definitions reference and the JSON schema that will refer to it"}, {"qid": "", "rank": 17, "path": "pydantic/v1/schema.py", "score": 0.544913113117218, "span_start": null, "span_end": null, "passage": "Update it if you want the schemas to reference the definitions somewhere\n      else, e.g for OpenAPI use ``#/components/schemas/`` The resulting generated schemas will still be at the\n      top-level ..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.5438158512115479, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, generate_json_schema: GenerateJsonSchema, handler_override: HandlerOverride | None) -> None:\n        self.generate_json_schema = generate_json_schema\n        self.handler =..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5426371693611145, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # avoid calling `__get_pydantic_core_schema__` if we've already visited this object\n        if is_self_type(obj):\n            obj = self.model_type_stack.get()\n        with self.defs.get_s..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5358141660690308, "span_start": null, "span_end": null, "passage": "Args:\n        schema: The input schema discriminator: The name of the field which will serve as the discriminator definitions: A mapping of schema ref to schema Returns:\n        The new core schema Ra..."}], "latency_ms": 3.8595199584960938, "gold_paths": ["pydantic/annotated_handlers.py"]}
{"qid": "lens_main_symbol_8b32ffac", "query": "find function __call__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generics.py", "score": 0.4525706470012665, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.42853912711143494, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_decorators.py", "score": 0.4089837968349457, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_core_utils.py", "score": 0.3968643546104431, "span_start": null, "span_end": null, "passage": "Args:\n        schema (core_schema.CoreSchema): The CoreSchema to process, it will not be modified f (Walk): A function to apply This function takes two arguments:\n          1 The current CoreSchema th..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generics.py", "score": 0.3883066773414612, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except Attribu..."}, {"qid": "", "rank": 6, "path": "pydantic/type_adapter.py", "score": 0.38780641555786133, "span_start": null, "span_end": null, "passage": "On the other hand this function can be called with arbitrary objects,\n    including type aliases, where `__module__` (always `typing.py`) is not useful So instead we look at the globals in our parent ..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.38477450609207153, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  ..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.3755843937397003, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 9, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.3752177655696869, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 10, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.3752177655696869, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3717053532600403, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.3707035481929779, "span_start": null, "span_end": null, "passage": "first = [Argument(Var('__pydantic_self__'), self_type, None, ARG_POS)]\n    args = first + args\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/errors.py", "score": 0.36739885807037354, "span_start": null, "span_end": null, "passage": "Note: the callable can't be a lambda as pickle looks in the namespace to find it\n    \"\"\"\n    return cls(**ctx)\n\n\nclass PydanticErrorMixin:\n    code: str\n    msg_template: str\n\n    def __init__(self, *..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.3585675358772278, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    cls_ref: str\n    cls_var_name: str\n    func: Callable[..., Any]\n    shim: Callable[[Any], Any] | None\n    info: DecoratorInfoType\n\n    @staticmethod\n    def build(\n        cls_: Any,\n        ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_decorators.py", "score": 0.35664159059524536, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    wrapped: DecoratedType[ReturnType]\n    decorator_info: DecoratorInfo\n    shim: Callable[[Callable[..., Any]], Callable[..., Any]] | None = None\n\n    def __post_init__(self):\n        for attr ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_decorators.py", "score": 0.3551378548145294, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.35074174404144287, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.35074174404144287, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 19, "path": "pydantic/validate_call_decorator.py", "score": 0.35063636302948, "span_start": null, "span_end": null, "passage": "\"\"\"Decorator for validating function calls.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport functools\nfrom typing import TYPE_CHECKING, Any, Callable, TypeVar, overload\n\nfrom ._internal..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/mypy.py", "score": 0.3476901948451996, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    self_ty..."}], "latency_ms": 3.6520957946777344, "gold_paths": ["pydantic/annotated_handlers.py"]}
{"qid": "lens_main_symbol_f575552d", "query": "find function generate_schema", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6362804174423218, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def get_ref(s: CoreSchema) -> str:\n            return s['ref']  # type: ignore\n\n        if schema['type'] == 'definitions':\n            self.defs.definitions.update({get_ref(s): s for s i..."}, {"qid": "", "rank": 2, "path": "pydantic/annotated_handlers.py", "score": 0.6222550868988037, "span_start": null, "span_end": null, "passage": "\"\"\"\n        raise NotImplementedError\n\n    def generate_schema(self, source_type: Any, /) -> core_schema.CoreSchema:\n        \"\"\"Generate a schema unrelated to the current context Use this function if ..."}, {"qid": "", "rank": 3, "path": "pydantic/json_schema.py", "score": 0.6127130389213562, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._function_schema(schema)\n\n    def function_plain_schema(self, schema: core_schema.PlainValidatorFunctionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matc..."}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 7, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 9, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 12, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 13, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.6108488440513611, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.6060622930526733, "span_start": null, "span_end": null, "passage": "return self.generate_inner(schema['schema'])\n\n        # function-plain\n        return self.handle_invalid_for_json_schema(\n            schema, f'core_schema.PlainValidatorFunctionSchema ({schema[\"func..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.6006348133087158, "span_start": null, "span_end": null, "passage": "This function looks through `field_class_to_schema` for a class that matches the given `field_type`,\n    and then modifies the given `schema` with the information from that type"}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.5814592838287354, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._function_schema(schema)\n\n    def function_after_schema(self, schema: core_schema.AfterValidatorFunctionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matc..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.5774844288825989, "span_start": null, "span_end": null, "passage": "Args:\n                schema_or_field: The core schema to generate a JSON schema from Returns:\n                The generated JSON schema Raises:\n                TypeError: If an unexpected schema type..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.5747610330581665, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.generate_inner(schema['schema'])\n\n    def json_schema(self, schema: core_schema.JsonSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that de..."}, {"qid": "", "rank": 20, "path": "pydantic/type_adapter.py", "score": 0.570436954498291, "span_start": null, "span_end": null, "passage": "Args:\n            by_alias: Whether to use alias names for field names ref_template: The format string used for generating $ref strings schema_generator: The generator class used for creating the sche..."}], "latency_ms": 3.752470016479492, "gold_paths": ["pydantic/annotated_handlers.py"]}
{"qid": "lens_main_symbol_82752dd1", "query": "find function resolve_ref_schema", "results": [{"qid": "", "rank": 1, "path": "pydantic/annotated_handlers.py", "score": 0.7184858322143555, "span_start": null, "span_end": null, "passage": "Returns:\n            CoreSchema: The `pydantic-core` CoreSchema generated \"\"\"\n        raise NotImplementedError\n\n    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema, /) -> core_s..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.7054678201675415, "span_start": null, "span_end": null, "passage": "Args:\n            maybe_ref_schema: The input core schema that may contains reference Returns:\n            Resolved core schema Raises:\n            LookupError: If it can't find the definition for ref..."}, {"qid": "", "rank": 3, "path": "pydantic/annotated_handlers.py", "score": 0.6943023800849915, "span_start": null, "span_end": null, "passage": "\"\"\"\n        raise NotImplementedError\n\n    def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue, /) -> JsonSchemaValue:\n        \"\"\"Get the real schema for a `{\"$ref\": ...}` schema If th..."}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.6594093441963196, "span_start": null, "span_end": null, "passage": "Args:\n            json_schema: The schema to resolve Returns:\n            The resolved schema"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.6464088559150696, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if maybe_ref_schema['type'] == 'definition-ref':\n            ref = maybe_ref_schema['schema_ref']\n            if ref not in self._generate_schema.defs.definitions:\n                raise Lo..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.605292558670044, "span_start": null, "span_end": null, "passage": "This returns the input json schema if there is no `$ref` in json schema Args:\n            maybe_ref_json_schema: The input json schema that may contains `$ref` Returns:\n            Resolved json schem..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5923426151275635, "span_start": null, "span_end": null, "passage": "At present the following types can be named/recursive:\n\n        - BaseModel\n        - Dataclasses\n        - TypedDict\n        - TypeAliasType\n        \"\"\"\n        ref = get_type_ref(tp)\n        # retur..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.5881505012512207, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if '$ref' not in maybe_ref_json_schema:\n            return maybe_ref_json_schema\n        ref = maybe_ref_json_schema['$ref']\n        json_schema = self.generate_json_schema.get_schema_from..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5871184468269348, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def get_ref(s: CoreSchema) -> str:\n            return s['ref']  # type: ignore\n\n        if schema['type'] == 'definitions':\n            self.defs.definitions.update({get_ref(s): s for s i..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_core_utils.py", "score": 0.5864566564559937, "span_start": null, "span_end": null, "passage": "arg_ref = f'{arg}:str-{id(arg)}'\n        else:\n            arg_ref = f'{_repr.display_as_type(arg)}:{id(arg)}'\n        arg_refs.append(arg_ref)\n    if arg_refs:\n        type_ref = f'{type_ref}[{\",\".jo..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/schema.py", "score": 0.5854016542434692, "span_start": null, "span_end": null, "passage": "The resulting generated schemas will still be at the\n      top-level key ``definitions``, so you can extract them from there But all the references will have the set\n      prefix :param ref_template: ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/schema.py", "score": 0.580703854560852, "span_start": null, "span_end": null, "passage": ":param known_models: used to solve circular references\n    :return: tuple of the schema for this field and additional definitions\n    \"\"\"\n    s, schema_overrides = get_field_info_schema(field)\n\n    va..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5754189491271973, "span_start": null, "span_end": null, "passage": "During this recursion, we allow references to be resolved from the definitions\n    # that are originally present on the original, outermost `schema` Before `apply_discriminators` is called,\n    # `sim..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_core_utils.py", "score": 0.5713156461715698, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return f(schema.copy(), _dispatch)\n\n\ndef simplify_schema_references(schema: core_schema.CoreSchema) -> core_schema.CoreSchema:  # noqa: C901\n    definitions: dict[str, core_schema.CoreSchema] ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_core_utils.py", "score": 0.5627737045288086, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return s.get('ref', None)\n\n\ndef collect_definitions(schema: core_schema.CoreSchema) -> dict[str, core_schema.CoreSchema]:\n    defs: dict[str, CoreSchema] = {}\n\n    def _record_valid_refs(s: co..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.546841561794281, "span_start": null, "span_end": null, "passage": "Args:\n            core_ref: The core reference to get the definitions reference for Returns:\n            A tuple of the definitions reference and the JSON schema that will refer to it"}, {"qid": "", "rank": 17, "path": "pydantic/v1/schema.py", "score": 0.544913113117218, "span_start": null, "span_end": null, "passage": "Update it if you want the schemas to reference the definitions somewhere\n      else, e.g for OpenAPI use ``#/components/schemas/`` The resulting generated schemas will still be at the\n      top-level ..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.5438158512115479, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, generate_json_schema: GenerateJsonSchema, handler_override: HandlerOverride | None) -> None:\n        self.generate_json_schema = generate_json_schema\n        self.handler =..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5426371693611145, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # avoid calling `__get_pydantic_core_schema__` if we've already visited this object\n        if is_self_type(obj):\n            obj = self.model_type_stack.get()\n        with self.defs.get_s..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5358141660690308, "span_start": null, "span_end": null, "passage": "Args:\n        schema: The input schema discriminator: The name of the field which will serve as the discriminator definitions: A mapping of schema ref to schema Returns:\n        The new core schema Ra..."}], "latency_ms": 3.839254379272461, "gold_paths": ["pydantic/annotated_handlers.py"]}
{"qid": "lens_main_symbol_6e72f6f9", "query": "find function field_name", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6016488075256348, "span_start": null, "span_end": null, "passage": "field_name: The name of the field from which to generate the title"}, {"qid": "", "rank": 2, "path": "pydantic/v1/schema.py", "score": 0.5204590559005737, "span_start": null, "span_end": null, "passage": "This function looks through `field_class_to_schema` for a class that matches the given `field_type`,\n    and then modifies the given `schema` with the information from that type"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_signature.py", "score": 0.5141797065734863, "span_start": null, "span_end": null, "passage": "Assuming the field has a valid alias, this will return the alias Otherwise, it will return the field name First priority is given to the validation_alias, then the alias, then the field name Args:\n   ..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/schema.py", "score": 0.47192662954330444, "span_start": null, "span_end": null, "passage": "\"\"\"\n    flat_models: TypeModelSet = set()\n    for model in models:\n        flat_models |= get_flat_models_from_model(model)\n    return flat_models\n\n\ndef get_long_model_name(model: TypeModelOrEnum) -> ..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/mypy.py", "score": 0.4670250415802002, "span_start": null, "span_end": null, "passage": "\"\"\"\n        expr = stmt.rvalue\n        if isinstance(expr, TempNode):\n            # TempNode means annotation-only\n            return None, False\n\n        if not (\n            isinstance(expr, CallExp..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.45006033778190613, "span_start": null, "span_end": null, "passage": "\"\"\"\n        expr = stmt.rvalue\n        if isinstance(expr, TempNode):\n            # TempNode means annotation-only\n            return None, False\n\n        if not (\n            isinstance(expr, CallExp..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.44975516200065613, "span_start": null, "span_end": null, "passage": "{\"_\" + var_name!r} instead of {var_name!r}.'\n                )\n            private_attributes[var_name] = value\n            del namespace[var_name]\n        elif isinstance(value, FieldInfo) and not is..."}, {"qid": "", "rank": 8, "path": "pydantic/mypy.py", "score": 0.4475817084312439, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4422803223133087, "span_start": null, "span_end": null, "passage": "Args:\n        info: The field info field: The field name to check Returns:\n        `True` if field name is in validator fields, `False` otherwise \"\"\"\n    if '*' in info.fields:\n        return True\n   ..."}, {"qid": "", "rank": 10, "path": "pydantic/fields.py", "score": 0.44188016653060913, "span_start": null, "span_end": null, "passage": "Returns:\n            An instance of the field metadata"}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.43617844581604004, "span_start": null, "span_end": null, "passage": "Args:\n            name: The name to retrieve a title from Returns:\n            The title \"\"\"\n        return name.title().replace('_', ' ')\n\n    def field_title_should_be_set(self, schema: CoreSchemaOr..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.4186987578868866, "span_start": null, "span_end": null, "passage": "if name is None or name == 'default':\n                    return arg.__class__ is not EllipsisExpr\n                if name == 'default_factory':\n                    return not (isinstance(arg, NameExp..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_fields.py", "score": 0.41524094343185425, "span_start": null, "span_end": null, "passage": "\"\"\"\n    from ..fields import FieldInfo\n\n    fields: dict[str, FieldInfo] = {}\n    dataclass_fields: dict[str, dataclasses.Field] = cls.__dataclass_fields__\n    cls_localns = dict(vars(cls))  # this ma..."}, {"qid": "", "rank": 14, "path": "pydantic/main.py", "score": 0.41302043199539185, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n\n        __class_vars..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.41033339500427246, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if _core_utils.is_core_schema_field(schema):\n            if schema['type'] == 'computed-field':\n                field_schema = schema['return_schema']\n            else:\n                fie..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generate_schema.py", "score": 0.40929925441741943, "span_start": null, "span_end": null, "passage": "\"\"\"\n        field_title_generator = field_info.field_title_generator or config_wrapper.field_title_generator\n\n        if field_title_generator is None:\n            return\n\n        if field_info.title ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/schema.py", "score": 0.40861237049102783, "span_start": null, "span_end": null, "passage": "\"\"\"\n    for type_, t_schema in field_class_to_schema:\n        # Fallback for `typing.Pattern` and `re.Pattern` as they are not a valid class\n        if lenient_issubclass(field_type, type_) or field_t..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/error_wrappers.py", "score": 0.40535080432891846, "span_start": null, "span_end": null, "passage": "code = getattr(cls, 'code', None) or cls.__name__.replace('Error', '').lower()\n    return base_name + '.' + code"}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_fields.py", "score": 0.4049586057662964, "span_start": null, "span_end": null, "passage": "\"\"\"\n    from ..fields import FieldInfo\n\n    type_hints = get_cls_type_hints_lenient(cls, types_namespace)\n\n    # https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-o..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/mypy.py", "score": 0.404818594455719, "span_start": null, "span_end": null, "passage": "\"\"\"\n        ctx = self._ctx\n        set_str = ctx.api.named_type(f'{BUILTINS_NAME}.set', [ctx.api.named_type(f'{BUILTINS_NAME}.str')])\n        optional_set_str = UnionType([set_str, NoneType()])\n     ..."}], "latency_ms": 3.751516342163086, "gold_paths": ["pydantic/annotated_handlers.py"]}
{"qid": "lens_main_symbol_4212c7c0", "query": "find function _get_types_namespace", "results": [{"qid": "", "rank": 1, "path": "pydantic/type_adapter.py", "score": 0.527068018913269, "span_start": null, "span_end": null, "passage": "def __init__(\n        self,\n        type: Any,\n        *,\n        config: ConfigDict | None = None,\n        _parent_depth: int = 2,\n        module: str | None = None,\n    ) -> None:\n        \"\"\"Initial..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_model_construction.py", "score": 0.5226612091064453, "span_start": null, "span_end": null, "passage": "Args:\n        cls: BaseModel or dataclass bases: Parents of the class, generally `cls.__bases__` config_wrapper: The config wrapper instance types_namespace: Optional extra namespace to look for types..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_fields.py", "score": 0.5214203000068665, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_dataclasses.py", "score": 0.5158703327178955, "span_start": null, "span_end": null, "passage": "Args:\n        cls: The class types_namespace: The types namespace, defaults to `None` config_wrapper: The config wrapper instance, defaults to `None`"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_fields.py", "score": 0.4941270649433136, "span_start": null, "span_end": null, "passage": "It uses the `typing.get_type_hints`, The only thing that we do here is fetching\n    global namespace from `obj.__module__` if it is not `None` Args:\n        obj: The object to get its type hints local..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_typing_extra.py", "score": 0.49177253246307373, "span_start": null, "span_end": null, "passage": "Using `f_back` would work sometimes but would be very wrong and confusing in many\n    other cases See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659"}, {"qid": "", "rank": 7, "path": "pydantic/v1/generics.py", "score": 0.491029292345047, "span_start": null, "span_end": null, "passage": "\"\"\"\n        param_names = [display_as_type(param) for param in params]\n        params_component = ', '.join(param_names)\n        return f'{cls.__name__}[{params_component}]'\n\n    @classmethod\n    def ..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.4858408272266388, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_model_construction.py", "score": 0.48425209522247314, "span_start": null, "span_end": null, "passage": "bases_str = ', '.join([x.__name__ for x in bases] + [generic_type_label])\n                            error_message += (\n                                f' Note: `typing.Generic` must go last: `class ..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_fields.py", "score": 0.4800504744052887, "span_start": null, "span_end": null, "passage": "import _typing_extra\nfrom ._config import ConfigWrapper\nfrom ._docs_extraction import extract_docstrings_from_cls\nfrom ._repr import Representation\nfrom ._typing_extra import get_cls_type_hints_lenien..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.468417763710022, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.4676905870437622, "span_start": null, "span_end": null, "passage": "It gets the return type from the type annotation if `explicit_return_type` is `None` Otherwise, it returns `explicit_return_type` Args:\n        func: The function to get its return type explicit_retur..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_repr.py", "score": 0.45382925868034363, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if isinstance(obj, types.FunctionType):\n        return obj.__name__\n    elif obj is ...:\n        return '...'\n    elif isinstance(obj, Representation):\n        return repr(obj)\n    elif isinst..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/main.py", "score": 0.449160635471344, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/mypy.py", "score": 0.4470163881778717, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    self_ty..."}, {"qid": "", "rank": 16, "path": "pydantic/dataclasses.py", "score": 0.44299012422561646, "span_start": null, "span_end": null, "passage": "_types_namespace: The types namespace, defaults to `None` Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required If rebuilding _was_ required, returns `Tru..."}, {"qid": "", "rank": 17, "path": "pydantic/dataclasses.py", "score": 0.4413650929927826, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not force and cls.__pydantic_complete__:\n        return None\n    else:\n        if _types_namespace is not None:\n            types_namespace: dict[str, Any] | None = _types_namespace.copy()\n..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_model_construction.py", "score": 0.4377743601799011, "span_start": null, "span_end": null, "passage": "private attributes)\n            for name, obj in private_attributes.items():\n                obj.__set_name__(cls, name)\n\n            if __pydantic_reset_parent_namespace__:\n                cls.__pyda..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_typing_extra.py", "score": 0.43423014879226685, "span_start": null, "span_end": null, "passage": "See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope\n    and suggestion at the end of the next comment by @gvanrossum WARNING 1: it matters exactly where this is calle..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_typing_extra.py", "score": 0.4203488826751709, "span_start": null, "span_end": null, "passage": "\"\"\"\n    frame = sys._getframe(parent_depth)\n    # if f_back is None, it's the global module namespace and we don't need to include it here\n    if frame.f_back is None:\n        return None\n    else:\n  ..."}], "latency_ms": 4.2629241943359375, "gold_paths": ["pydantic/annotated_handlers.py"]}
{"qid": "lens_main_symbol_53a08647", "query": "find class GetJsonSchemaHandler", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.4903479218482971, "span_start": null, "span_end": null, "passage": "\"\"\"Types and utility functions used by various other internal tools.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import core_schema\nfrom..."}, {"qid": "", "rank": 2, "path": "pydantic/annotated_handlers.py", "score": 0.44774097204208374, "span_start": null, "span_end": null, "passage": "Returns:\n            JsonSchemaValue: A JsonSchemaValue that has no `$ref` \"\"\"\n        raise NotImplementedError\n\n\nclass GetCoreSchemaHandler:\n    \"\"\"Handler to call into the next CoreSchema schema ge..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.41213804483413696, "span_start": null, "span_end": null, "passage": "import _known_annotated_metadata, _typing_extra, _validators\nfrom ._core_utils import get_type_ref\nfrom ._internal_dataclass import slots_true\nfrom ._schema_generation_shared import GetCoreSchemaHandl..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators.py", "score": 0.3993273079395294, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 5, "path": "pydantic/types.py", "score": 0.3944030702114105, "span_start": null, "span_end": null, "passage": "The parent directory must already exist.\"\"\"\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ JSON TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif TYPE_CHECKING:\n    # Json[list[str]] will be recognized by type checke..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.39144083857536316, "span_start": null, "span_end": null, "passage": "return core_schema.is_instance_schema(\n            enum_type,\n            metadata={'pydantic_js_functions': [get_json_schema_no_cases]},\n        )\n\n\n@dataclasses.dataclass(**slots_true)\nclass InnerSc..."}, {"qid": "", "rank": 7, "path": "pydantic/annotated_handlers.py", "score": 0.38890156149864197, "span_start": null, "span_end": null, "passage": "\"\"\"Type annotations to use with `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__`.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom typing import TYPE_CHECKING, Any, Union\n..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generate_schema.py", "score": 0.38009315729141235, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 9, "path": "pydantic/__init__.py", "score": 0.3760462999343872, "span_start": null, "span_end": null, "passage": "import dataclasses\n    from ._internal._generate_schema import GenerateSchema as GenerateSchema\n    from .aliases import AliasChoices, AliasGenerator, AliasPath\n    from .annotated_handlers import Get..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.37080028653144836, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n\nclass PydanticJsonSchemaWarning(UserWarning):\n    \"\"\"This class is used to emit warnings produced during JSON schema generation See the [`GenerateJsonSchema.emit_warning`][pydantic.json_schema.G..."}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.37001389265060425, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def __class_getitem__(cls, item: AnyType) -> AnyType:\n            return Annotated[item, cls()]\n\n        def __get_pydantic_json_schema__(\n            self, core_schema: CoreSchema, handl..."}, {"qid": "", "rank": 12, "path": "pydantic/main.py", "score": 0.36300164461135864, "span_start": null, "span_end": null, "passage": "if not cls.__pydantic_generic_metadata__['origin']:\n                return cls.__pydantic_core_schema__\n\n        return handler(source)\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.36109814047813416, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/main.py", "score": 0.3564063012599945, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.3564003109931946, "span_start": null, "span_end": null, "passage": "```py\n        from pydantic import BaseModel, ImportString\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # Create an instance\n        m = ImportThings(obj='math.cos'..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.35583844780921936, "span_start": null, "span_end": null, "passage": "import ConfigDict\n    from ._internal._core_utils import CoreSchemaField, CoreSchemaOrField\n    from ._internal._dataclasses import PydanticDataclass\n    from ._internal._schema_generation_shared impo..."}, {"qid": "", "rank": 17, "path": "tests/test_deprecated.py", "score": 0.35310614109039307, "span_start": null, "span_end": null, "passage": "'\n        'Use `__get_pydantic_json_schema__` instead in class `SomeLongName`.',\n    ):\n\n        class B(BaseModel):\n            model_config = ConfigDict(arbitrary_types_allowed=True)\n\n            a:..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3479498028755188, "span_start": null, "span_end": null, "passage": "Args:\n        schema_or_field: The schema data to generate a JSON schema from handler: The `GetCoreSchemaHandler` instance cls: The model-like class title: The title to set for the model's schema, def..."}, {"qid": "", "rank": 19, "path": "pydantic/functional_validators.py", "score": 0.34743383526802063, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item, SkipValidation()]\n\n        @classmethod\n        def __get_pydantic_core_schema__(cls, source: Any, handler..."}, {"qid": "", "rank": 20, "path": "pydantic/json_schema.py", "score": 0.34642887115478516, "span_start": null, "span_end": null, "passage": "While I suspect it is unlikely to be necessary, you can in\n        principle override this class in a subclass of GenerateJsonSchema (by inheriting from\n        GenerateJsonSchema.ValidationsMapping) ..."}], "latency_ms": 4.366874694824219, "gold_paths": ["pydantic/annotated_handlers.py"]}
{"qid": "lens_main_symbol_531c529f", "query": "find class GetCoreSchemaHandler", "results": [{"qid": "", "rank": 1, "path": "pydantic/annotated_handlers.py", "score": 0.5310136079788208, "span_start": null, "span_end": null, "passage": "Returns:\n            JsonSchemaValue: A JsonSchemaValue that has no `$ref` \"\"\"\n        raise NotImplementedError\n\n\nclass GetCoreSchemaHandler:\n    \"\"\"Handler to call into the next CoreSchema schema ge..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.45687931776046753, "span_start": null, "span_end": null, "passage": "import _known_annotated_metadata, _typing_extra, _validators\nfrom ._core_utils import get_type_ref\nfrom ._internal_dataclass import slots_true\nfrom ._schema_generation_shared import GetCoreSchemaHandl..."}, {"qid": "", "rank": 3, "path": "pydantic/functional_validators.py", "score": 0.45498254895210266, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item, SkipValidation()]\n\n        @classmethod\n        def __get_pydantic_core_schema__(cls, source: Any, handler..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4367447793483734, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.42124825716018677, "span_start": null, "span_end": null, "passage": "return core_schema.is_instance_schema(\n            enum_type,\n            metadata={'pydantic_js_functions': [get_json_schema_no_cases]},\n        )\n\n\n@dataclasses.dataclass(**slots_true)\nclass InnerSc..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_decorators.py", "score": 0.4179849922657013, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.4175647497177124, "span_start": null, "span_end": null, "passage": "\"\"\"Types and utility functions used by various other internal tools.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import core_schema\nfrom..."}, {"qid": "", "rank": 8, "path": "pydantic/functional_validators.py", "score": 0.4155255854129791, "span_start": null, "span_end": null, "passage": "import GetCoreSchemaHandler as _GetCoreSchemaHandler\nfrom ._internal import _core_metadata, _decorators, _generics, _internal_dataclass\nfrom .annotated_handlers import GetCoreSchemaHandler\nfrom .error..."}, {"qid": "", "rank": 9, "path": "tests/test_main.py", "score": 0.41276049613952637, "span_start": null, "span_end": null, "passage": "When we use the TypeAdapter\n    received_schemas: dict[str, list[str]] = defaultdict(list)\n\n    @dataclass\n    class Marker:\n        name: str\n\n        def __get_pydantic_core_schema__(self, source_ty..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.40954306721687317, "span_start": null, "span_end": null, "passage": "Used internally by Pydantic, please do not rely on this implementation See `GetCoreSchemaHandler` for the handler API"}, {"qid": "", "rank": 11, "path": "pydantic/functional_serializers.py", "score": 0.4091135263442993, "span_start": null, "span_end": null, "passage": "\"\"\"\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class SerializeAsAny:  # noqa: D101\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item,..."}, {"qid": "", "rank": 12, "path": "pydantic/types.py", "score": 0.4079902470111847, "span_start": null, "span_end": null, "passage": "```py\n        from pydantic import BaseModel, ImportString\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # Create an instance\n        m = ImportThings(obj='math.cos'..."}, {"qid": "", "rank": 13, "path": "pydantic/functional_serializers.py", "score": 0.4057510495185852, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    func: core_schema.WrapSerializerFunction\n    return_type: Any = PydanticUndefined\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always'\n\n    def __get_pydanti..."}, {"qid": "", "rank": 14, "path": "tests/test_types.py", "score": 0.4026312530040741, "span_start": null, "span_end": null, "passage": "@classmethod\n        def __get_pydantic_core_schema__(\n            cls,\n            source_type: Any,\n            handler: GetCoreSchemaHandler,\n        ) -> CoreSchema:\n            schema = handler.g..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.39682841300964355, "span_start": null, "span_end": null, "passage": "Args:\n        schema_or_field: The schema data to generate a JSON schema from handler: The `GetCoreSchemaHandler` instance cls: The model-like class title: The title to set for the model's schema, def..."}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.3797205686569214, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def _display(self) -> str | bytes:\n        return '**********' if self.get_secret_value() else ''\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCo..."}, {"qid": "", "rank": 17, "path": "pydantic/functional_serializers.py", "score": 0.3784340023994446, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    func: core_schema.SerializerFunction\n    return_type: Any = PydanticUndefined\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always'\n\n    def __get_pydantic_co..."}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.3746025562286377, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_core_utils.py", "score": 0.36990034580230713, "span_start": null, "span_end": null, "passage": "Returns:\n        core_schema.CoreSchema: A processed CoreSchema"}, {"qid": "", "rank": 20, "path": "pydantic/v1/mypy.py", "score": 0.3663904368877411, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}], "latency_ms": 4.3392181396484375, "gold_paths": ["pydantic/annotated_handlers.py"]}
{"qid": "lens_main_symbol_c7adc651", "query": "find function __init__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generics.py", "score": 0.4171063303947449, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.40831226110458374, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_dataclasses.py", "score": 0.3932117521762848, "span_start": null, "span_end": null, "passage": "def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -> None:\n        __tracebackhide__ = True\n        s = __dataclass_self__\n        s.__pydantic_validator__.validate_python..."}, {"qid": "", "rank": 4, "path": "pydantic/dataclasses.py", "score": 0.3917386531829834, "span_start": null, "span_end": null, "passage": "def _call_initvar(*args: Any, **kwargs: Any) -> NoReturn:\n        \"\"\"This function does nothing but raise an error that is as similar as possible to what you'd get\n        if you were to try calling `..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_validate_call.py", "score": 0.36800476908683777, "span_start": null, "span_end": null, "passage": "import _generate_schema, _typing_extra\nfrom ._config import ConfigWrapper\n\n\nclass ValidateCallWrapper:\n    \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optiona..."}, {"qid": "", "rank": 6, "path": "pydantic/errors.py", "score": 0.36481308937072754, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, message: str, *, code: PydanticErrorCodes | None) -> None:\n        self.message = message\n        self.code = code\n\n    def __str__(self) -> str:\n        if self.code is No..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3647959232330322, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 8, "path": "pydantic/dataclasses.py", "score": 0.3563225269317627, "span_start": null, "span_end": null, "passage": "Raises:\n        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.355609267950058, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.35129937529563904, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3511527180671692, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 14, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 15, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.3478943109512329, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = s..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 19, "path": "pydantic/root_model.py", "score": 0.3416903018951416, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __pydantic_root_model__ = True\n    __pydantic_private__ = None\n    __pydantic_extra__ = None\n\n    root: RootModelRootType\n\n    def __init_subclass__(cls, **kwargs):\n        extra = cls.model_..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.3403377830982208, "span_start": null, "span_end": null, "passage": "\"\"\"This module includes classes and functions designed specifically for use with the mypy plugin.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom configparser import ConfigParser\nfrom typing i..."}], "latency_ms": 3.647327423095703, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_9e173315", "query": "find function __getitem__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.46648886799812317, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.37931400537490845, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generics.py", "score": 0.3782079517841339, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 4, "path": "pydantic/types.py", "score": 0.35980963706970215, "span_start": null, "span_end": null, "passage": "```py\n        from pydantic import BaseModel, ImportString\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # Create an instance\n        m = ImportThings(obj='math.cos'..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3556235432624817, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 6, "path": "pydantic/functional_validators.py", "score": 0.3524971008300781, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item, SkipValidation()]\n\n        @classmethod\n        def __get_pydantic_core_schema__(cls, source: Any, handler..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.33379292488098145, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.3207916021347046, "span_start": null, "span_end": null, "passage": "dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n    return dedent_source\n\n\ndef _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n    frame = inspect.currentframe()\n\n    whil..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.31649625301361084, "span_start": null, "span_end": null, "passage": "try:\n            source, _ = inspect.getsourcelines(cls)\n        except OSError:\n            return {}\n    else:\n        source = _extract_source_from_frame(cls)\n\n    if not source:\n        return {}\n..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generics.py", "score": 0.3139762282371521, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except Attribu..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_model_construction.py", "score": 0.3050391674041748, "span_start": null, "span_end": null, "passage": "# It would be nice to remove this error and still have things behave as expected, it's just\n                            # challenging because we are using a custom `__class_getitem__` to parametrize g..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/color.py", "score": 0.30395597219467163, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = 'r', 'g', 'b', 'alpha', '_tuple'\n\n    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):\n        self.r = r\n        self.g = g\n        self.b = b\n        se..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_core_utils.py", "score": 0.3004379868507385, "span_start": null, "span_end": null, "passage": "Args:\n        schema (core_schema.CoreSchema): The CoreSchema to process, it will not be modified f (Walk): A function to apply This function takes two arguments:\n          1 The current CoreSchema th..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.29918792843818665, "span_start": null, "span_end": null, "passage": "pass\n            else:\n                block_lines = inspect.getblock(lines[lnum - 1 :])\n                dedent_source = _dedent_source_lines(block_lines)\n                try:\n                    bloc..."}, {"qid": "", "rank": 15, "path": "pydantic/type_adapter.py", "score": 0.2976533770561218, "span_start": null, "span_end": null, "passage": "On the other hand this function can be called with arbitrary objects,\n    including type aliases, where `__module__` (always `typing.py`) is not useful So instead we look at the globals in our parent ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_core_utils.py", "score": 0.29265904426574707, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n\ndef is_core_schema(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[CoreSchema]:\n    return schema['type'] not in _CORE_SCHEMA_FIELD_TYPES\n\n\ndef is_core_schema_field(\n    schema: CoreSchemaOrField..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2904313802719116, "span_start": null, "span_end": null, "passage": "base_globals, base_locals = base_locals, base_globals\n                for name, value in ann.items():\n                    if value is None:\n                        value = type(None)\n                 ..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2852284908294678, "span_start": null, "span_end": null, "passage": "See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope\n    and suggestion at the end of the next comment by @gvanrossum WARNING 1: it matters exactly where this is calle..."}, {"qid": "", "rank": 19, "path": "pydantic/annotated_handlers.py", "score": 0.2851298153400421, "span_start": null, "span_end": null, "passage": "Returns:\n            JsonSchemaValue: A JsonSchemaValue that has no `$ref` \"\"\"\n        raise NotImplementedError\n\n\nclass GetCoreSchemaHandler:\n    \"\"\"Handler to call into the next CoreSchema schema ge..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/error_wrappers.py", "score": 0.28391319513320923, "span_start": null, "span_end": null, "passage": "code = getattr(cls, 'code', None) or cls.__name__.replace('Error', '').lower()\n    return base_name + '.' + code"}], "latency_ms": 3.611326217651367, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_c7adc651", "query": "find function __init__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generics.py", "score": 0.4171063303947449, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.40831226110458374, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_dataclasses.py", "score": 0.3932117521762848, "span_start": null, "span_end": null, "passage": "def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -> None:\n        __tracebackhide__ = True\n        s = __dataclass_self__\n        s.__pydantic_validator__.validate_python..."}, {"qid": "", "rank": 4, "path": "pydantic/dataclasses.py", "score": 0.3917386531829834, "span_start": null, "span_end": null, "passage": "def _call_initvar(*args: Any, **kwargs: Any) -> NoReturn:\n        \"\"\"This function does nothing but raise an error that is as similar as possible to what you'd get\n        if you were to try calling `..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_validate_call.py", "score": 0.36800476908683777, "span_start": null, "span_end": null, "passage": "import _generate_schema, _typing_extra\nfrom ._config import ConfigWrapper\n\n\nclass ValidateCallWrapper:\n    \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optiona..."}, {"qid": "", "rank": 6, "path": "pydantic/errors.py", "score": 0.36481308937072754, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, message: str, *, code: PydanticErrorCodes | None) -> None:\n        self.message = message\n        self.code = code\n\n    def __str__(self) -> str:\n        if self.code is No..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3647959232330322, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 8, "path": "pydantic/dataclasses.py", "score": 0.3563225269317627, "span_start": null, "span_end": null, "passage": "Raises:\n        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.355609267950058, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.35129937529563904, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3511527180671692, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 14, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 15, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.3478943109512329, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = s..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 19, "path": "pydantic/root_model.py", "score": 0.3416903018951416, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __pydantic_root_model__ = True\n    __pydantic_private__ = None\n    __pydantic_extra__ = None\n\n    root: RootModelRootType\n\n    def __init_subclass__(cls, **kwargs):\n        extra = cls.model_..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.3403377830982208, "span_start": null, "span_end": null, "passage": "\"\"\"This module includes classes and functions designed specifically for use with the mypy plugin.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom configparser import ConfigParser\nfrom typing i..."}], "latency_ms": 4.804134368896484, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_8592bc6e", "query": "find function __get_pydantic_json_schema__", "results": [{"qid": "", "rank": 1, "path": "pydantic/main.py", "score": 0.7212873101234436, "span_start": null, "span_end": null, "passage": "if not cls.__pydantic_generic_metadata__['origin']:\n                return cls.__pydantic_core_schema__\n\n        return handler(source)\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        ..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_core_metadata.py", "score": 0.6876157522201538, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    pydantic_js_functions: list[GetJsonSchemaFunction]\n    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n\n    # If `pydantic_js_prefer_positional_arguments` is True, the JSON sche..."}, {"qid": "", "rank": 3, "path": "pydantic/annotated_handlers.py", "score": 0.6702313423156738, "span_start": null, "span_end": null, "passage": "This will call the next JSON schema modifying function up until it calls\n        into `pydantic.json_schema.GenerateJsonSchema`, which will raise a\n        `pydantic.errors.PydanticInvalidForJsonSchem..."}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.667873740196228, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._used:\n            raise PydanticUserError(\n                'This JSON schema generator has already been used to generate a JSON schema"}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.6675740480422974, "span_start": null, "span_end": null, "passage": "\"\"\"\nUsage docs: https://docs.pydantic.dev/2.5/concepts/json_schema/\n\nThe `json_schema` module contains classes and functions to allow the way [JSON Schema](https://json-schema.org/)\nis generated to be..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6554029583930969, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if field_info.default_factory:\n        return core_schema.with_default_schema(\n            schema, default_factory=field_info.default_factory, validate_default=field_info.validate_default\n    ..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_core_metadata.py", "score": 0.6503839492797852, "span_start": null, "span_end": null, "passage": "Attributes:\n        pydantic_js_functions: List of JSON schema functions pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n            prefer positional over keyword argument..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.6438835859298706, "span_start": null, "span_end": null, "passage": "Returns:\n            A dictionary containing the mapping of `CoreSchemaOrFieldType` to a handler method Raises:\n            TypeError: If no method has been defined for generating a JSON schema for a ..."}, {"qid": "", "rank": 9, "path": "pydantic/functional_serializers.py", "score": 0.630081057548523, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    func: core_schema.WrapSerializerFunction\n    return_type: Any = PydanticUndefined\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always'\n\n    def __get_pydanti..."}, {"qid": "", "rank": 10, "path": "tests/test_deprecated.py", "score": 0.6215007305145264, "span_start": null, "span_end": null, "passage": "Use `pydantic.TypeAdapter.validate_python` instead',\n        '`schema_json_of` is deprecated Use `pydantic.TypeAdapter.json_schema` instead',\n        '`schema_of` is deprecated Use `pydantic.TypeAdapt..."}, {"qid": "", "rank": 11, "path": "pydantic/deprecated/tools.py", "score": 0.6182748079299927, "span_start": null, "span_end": null, "passage": "Use `pydantic.TypeAdapter.json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return json.dumps(\n        schema_of(type_, title=title, by_alias=by_alias..."}, {"qid": "", "rank": 12, "path": "pydantic/functional_serializers.py", "score": 0.6167828440666199, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    func: core_schema.SerializerFunction\n    return_type: Any = PydanticUndefined\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always'\n\n    def __get_pydantic_co..."}, {"qid": "", "rank": 13, "path": "tests/test_deprecated.py", "score": 0.616728663444519, "span_start": null, "span_end": null, "passage": "'\n        'Use `__get_pydantic_json_schema__` instead in class `Model`.',\n    ):\n\n        class Model(BaseModel):\n            @classmethod\n            def __modify_schema__(cls, field_schema: Dict[str..."}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.6094408631324768, "span_start": null, "span_end": null, "passage": "```py\nimport uuid\n\nfrom pydantic import UUID5, BaseModel\n\nclass Model(BaseModel):\n    uuid5: UUID5\n\nModel(uuid5=uuid.uuid5(uuid.NAMESPACE_DNS, 'pydantic.org'))\n```\n\"\"\"\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.604153037071228, "span_start": null, "span_end": null, "passage": "```py\n        from pydantic import BaseModel, ImportString\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # Create an instance\n        m = ImportThings(obj='math.cos'..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.6038594245910645, "span_start": null, "span_end": null, "passage": "Use `tuple_schema` instead.',\n            PydanticDeprecatedSince26,\n            stacklevel=2,\n        )\n        return self.tuple_schema(schema)\n\n    def tuple_schema(self, schema: core_schema.TupleS..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.6028152704238892, "span_start": null, "span_end": null, "passage": "This class is intended to eliminate the need to create a custom \"marker\" which defines the\n     `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` custom hook methods"}, {"qid": "", "rank": 18, "path": "pydantic/v1/tools.py", "score": 0.6020367741584778, "span_start": null, "span_end": null, "passage": "import json\nfrom functools import lru_cache\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Optional, Type, TypeVar, Union\n\nfrom pydantic.v1.parse import Protocol, load_file,..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.5992077589035034, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    json_schema: JsonSchemaValue | None\n    mode: Literal['validation', 'serialization'] | None = None\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, ha..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5955473184585571, "span_start": null, "span_end": null, "passage": "'\n                f'Use `__get_pydantic_json_schema__` instead{f\" in class `{cls_name}`\" if cls_name else \"\"}.',\n                code='custom-json-schema',\n            )\n\n    # handle GenericAlias' bu..."}], "latency_ms": 4.539966583251953, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_f277f6d0", "query": "find function original", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.4152517318725586, "span_start": null, "span_end": null, "passage": "If we do replace any functions we put the replacement into the position\n        the replaced function was in; that is, we maintain the order"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_decorators.py", "score": 0.32394275069236755, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  ..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3131736218929291, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.2871904969215393, "span_start": null, "span_end": null, "passage": "dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n    return dedent_source\n\n\ndef _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n    frame = inspect.currentframe()\n\n    whil..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/mypy.py", "score": 0.2764989733695984, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.2764989733695984, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/schema.py", "score": 0.2746540606021881, "span_start": null, "span_end": null, "passage": "This function looks through `field_class_to_schema` for a class that matches the given `field_type`,\n    and then modifies the given `schema` with the information from that type"}, {"qid": "", "rank": 8, "path": "pydantic/experimental/pipeline.py", "score": 0.2743265926837921, "span_start": null, "span_end": null, "passage": "import inspect\n\n            try:\n                # remove ')' suffix, can use removesuffix once we drop 3.8\n                source = inspect.getsource(func).strip()\n                if source.endswith(..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_decorators.py", "score": 0.26709842681884766, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generics.py", "score": 0.2643449306488037, "span_start": null, "span_end": null, "passage": "# `typing.Callable[[int, str], int]` is an example for this if isinstance(type_, (List, list)):\n        resolved_list = list(replace_types(element, type_map) for element in type_)\n        if all_ident..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generics.py", "score": 0.263966828584671, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except Attribu..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/class_validators.py", "score": 0.2573339641094208, "span_start": null, "span_end": null, "passage": "\"\"\"\n    f_cls = function if isinstance(function, classmethod) else classmethod(function)\n    if not in_ipython() and not allow_reuse:\n        ref = (\n            getattr(f_cls.__func__, '__module__', ..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_decorators.py", "score": 0.24552810192108154, "span_start": null, "span_end": null, "passage": "unwrap_types = (\n        (property, cached_property)\n        + ((partial, partialmethod) if unwrap_partial else ())\n        + ((staticmethod, classmethod) if unwrap_class_static_method else ())\n    )\n..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.24380424618721008, "span_start": null, "span_end": null, "passage": "\"\"\"Bucket of reusable internal utilities This should be reduced as much as possible with functions only used in one place, moved to that place"}, {"qid": "", "rank": 15, "path": "pydantic/v1/mypy.py", "score": 0.24345803260803223, "span_start": null, "span_end": null, "passage": "r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    if is_classmethod:  # or is_staticmethod:\n        func.is_decorated = True\n        v = Var(na..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_core_utils.py", "score": 0.24291858077049255, "span_start": null, "span_end": null, "passage": "Args:\n        schema (core_schema.CoreSchema): The CoreSchema to process, it will not be modified f (Walk): A function to apply This function takes two arguments:\n          1 The current CoreSchema th..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.2409188449382782, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2397480607032776, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.23855453729629517, "span_start": null, "span_end": null, "passage": "copied_definitions = deepcopy(definitions)\n        definitions_schema = {'$defs': copied_definitions}\n        for _iter in range(100):  # prevent an infinite loop in the case of a bug, 100 iterations ..."}, {"qid": "", "rank": 20, "path": "pydantic/warnings.py", "score": 0.2327253371477127, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    message: str\n    since: tuple[int, int]\n    expected_removal: tuple[int, int]\n\n    def __init__(\n        self, message: str, *args: object, since: tuple[int, int], expected_removal: tuple[int..."}], "latency_ms": 4.546642303466797, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_3ef90843", "query": "find function as_named", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/mypy.py", "score": 0.44952288269996643, "span_start": null, "span_end": null, "passage": "\"\"\"\n    fn = x.fullname\n    if callable(fn):  # pragma: no cover\n        return fn()\n    return fn\n\n\ndef get_name(x: Union[FuncBase, SymbolNode]) -> str:\n    \"\"\"\n    Used for compatibility with mypy 0..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generics.py", "score": 0.4268081784248352, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 3, "path": "pydantic/type_adapter.py", "score": 0.4137663245201111, "span_start": null, "span_end": null, "passage": "On the other hand this function can be called with arbitrary objects,\n    including type aliases, where `__module__` (always `typing.py`) is not useful So instead we look at the globals in our parent ..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_typing_extra.py", "score": 0.41360342502593994, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3984544575214386, "span_start": null, "span_end": null, "passage": "Using `f_back` would work sometimes but would be very wrong and confusing in many\n    other cases See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659"}, {"qid": "", "rank": 6, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.3919859230518341, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 7, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.3919859230518341, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 8, "path": "pydantic/v1/mypy.py", "score": 0.3918636441230774, "span_start": null, "span_end": null, "passage": "r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    if is_classmethod:  # or is_staticmethod:\n        func.is_decorated = True\n        v = Var(na..."}, {"qid": "", "rank": 9, "path": "pydantic/mypy.py", "score": 0.38758546113967896, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_typing_extra.py", "score": 0.385439932346344, "span_start": null, "span_end": null, "passage": "See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope\n    and suggestion at the end of the next comment by @gvanrossum WARNING 1: it matters exactly where this is calle..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_model_construction.py", "score": 0.3794263005256653, "span_start": null, "span_end": null, "passage": "{\"_\" + var_name!r} instead of {var_name!r}.'\n                )\n            private_attributes[var_name] = value\n            del namespace[var_name]\n        elif isinstance(value, FieldInfo) and not is..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/main.py", "score": 0.37659916281700134, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/error_wrappers.py", "score": 0.3746579587459564, "span_start": null, "span_end": null, "passage": "code = getattr(cls, 'code', None) or cls.__name__.replace('Error', '').lower()\n    return base_name + '.' + code"}, {"qid": "", "rank": 14, "path": "pydantic/v1/typing.py", "score": 0.37335634231567383, "span_start": null, "span_end": null, "passage": "`Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`\n    \"\"\"\n    if not is_literal_type(type_):\n        return (type_,)\n\n    values = literal_values(type_)\n    return tuple(x for value in values for x..."}, {"qid": "", "rank": 15, "path": "tests/test_typing.py", "score": 0.3724539279937744, "span_start": null, "span_end": null, "passage": "import sys\nimport typing\nfrom collections import namedtuple\nfrom typing import Callable, ClassVar, ForwardRef, NamedTuple\n\nimport pytest\nfrom typing_extensions import Literal, get_origin\n\nfrom pydanti..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3702813684940338, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.3669678270816803, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    self_ty..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.36365509033203125, "span_start": null, "span_end": null, "passage": "`model_name` is accepted for the purpose of producing useful error messages"}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_decorators.py", "score": 0.35996830463409424, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_decorators.py", "score": 0.3548445701599121, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}], "latency_ms": 4.792690277099609, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_c01b7565", "query": "find function as_hex", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/color.py", "score": 0.5425588488578796, "span_start": null, "span_end": null, "passage": "`<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg"}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.4193291664123535, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/color.py", "score": 0.417304664850235, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 4, "path": "pydantic/color.py", "score": 0.41176116466522217, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/color.py", "score": 0.39092937111854553, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.3819093704223633, "span_start": null, "span_end": null, "passage": "Hex string representing the color can be 3, 4, 6, or 8 characters depending on whether the string\n        a \"short\" representation of the color is possible and whether there's an alpha channel Returns..."}, {"qid": "", "rank": 7, "path": "pydantic/color.py", "score": 0.3731689453125, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.3529408872127533, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/color.py", "score": 0.34851670265197754, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = 'r', 'g', 'b', 'alpha', '_tuple'\n\n    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):\n        self.r = r\n        self.g = g\n        self.b = b\n        se..."}, {"qid": "", "rank": 10, "path": "pydantic/color.py", "score": 0.34697791934013367, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 11, "path": "pydantic/color.py", "score": 0.3467264175415039, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.3289920687675476, "span_start": null, "span_end": null, "passage": "st.register_type_strategy(\n    pydantic.PyObject,  # type: ignore[arg-type]\n    st.sampled_from(\n        [cast(pydantic.PyObject, f'math.{name}') for name in sorted(vars(math)) if not name.startswith(..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/color.py", "score": 0.32684189081192017, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 14, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.3240731656551361, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 15, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.3240731656551361, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 16, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.3240731656551361, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 17, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.3240731656551361, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 18, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.3240731656551361, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 19, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.3240731656551361, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 20, "path": "pydantic/main.py", "score": 0.3240731656551361, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}], "latency_ms": 4.611015319824219, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_f452cfc7", "query": "find function as_rgb", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/color.py", "score": 0.5916414260864258, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.5824976563453674, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.547693133354187, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 4, "path": "pydantic/color.py", "score": 0.5427269339561462, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 5, "path": "pydantic/color.py", "score": 0.5401415824890137, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/color.py", "score": 0.5382587909698486, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 7, "path": "pydantic/color.py", "score": 0.5326740741729736, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.5273546576499939, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.524185299873352, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/color.py", "score": 0.5231767892837524, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/color.py", "score": 0.5060189962387085, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.4960373044013977, "span_start": null, "span_end": null, "passage": "Args:\n        h: The hue value h_units: The unit for hue value sat: The saturation value light: The lightness value alpha: Alpha value Returns:\n        An instance of `RGBA`"}, {"qid": "", "rank": 13, "path": "pydantic/v1/color.py", "score": 0.49415868520736694, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/color.py", "score": 0.47523215413093567, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 15, "path": "pydantic/color.py", "score": 0.4599113464355469, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 16, "path": "pydantic/color.py", "score": 0.44992950558662415, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 17, "path": "pydantic/color.py", "score": 0.4389607906341553, "span_start": null, "span_end": null, "passage": "Args:\n        value: A tuple or list Returns:\n        An `RGBA` tuple parsed from the input tuple Raises:\n        PydanticCustomError: If tuple is not valid"}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.4377852976322174, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.4358639419078827, "span_start": null, "span_end": null, "passage": "Args:\n        r: An integer or string representing the red color value g: An integer or string representing the green color value b: An integer or string representing the blue color value alpha: A flo..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/color.py", "score": 0.4245491623878479, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}], "latency_ms": 3.9229393005371094, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_863cff20", "query": "find function as_rgb_tuple", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/color.py", "score": 0.6534925699234009, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.6138719320297241, "span_start": null, "span_end": null, "passage": "Args:\n        value: A tuple or list Returns:\n        An `RGBA` tuple parsed from the input tuple Raises:\n        PydanticCustomError: If tuple is not valid"}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.5972245335578918, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/color.py", "score": 0.5949524641036987, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 5, "path": "pydantic/color.py", "score": 0.5876967906951904, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.5812079906463623, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/color.py", "score": 0.5619520545005798, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.5545104146003723, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.5492616891860962, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/color.py", "score": 0.5411390066146851, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 11, "path": "pydantic/color.py", "score": 0.5408018827438354, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.5376647710800171, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/color.py", "score": 0.5312814712524414, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 14, "path": "pydantic/color.py", "score": 0.5254719853401184, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/color.py", "score": 0.5110028982162476, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/color.py", "score": 0.5053501129150391, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union, cast\n\nfrom pydantic.v1.errors import ColorError\nfrom pydantic..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/color.py", "score": 0.4990396499633789, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.4856772720813751, "span_start": null, "span_end": null, "passage": "Args:\n        h: The hue value h_units: The unit for hue value sat: The saturation value light: The lightness value alpha: Alpha value Returns:\n        An instance of `RGBA`"}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.480350136756897, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 20, "path": "pydantic/color.py", "score": 0.4713832139968872, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import Any, Callable, Optional, Tuple, Type, Union, cast\n\nfrom pydantic_core import CoreSchema, PydanticCustomError, ..."}], "latency_ms": 4.08172607421875, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_c37d903c", "query": "find function as_hsl", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.45715081691741943, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.44602149724960327, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/color.py", "score": 0.4074872136116028, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/color.py", "score": 0.36811554431915283, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 5, "path": "pydantic/color.py", "score": 0.35844507813453674, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/color.py", "score": 0.32319116592407227, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.3116151988506317, "span_start": null, "span_end": null, "passage": "st.register_type_strategy(\n    pydantic.PyObject,  # type: ignore[arg-type]\n    st.sampled_from(\n        [cast(pydantic.PyObject, f'math.{name}') for name in sorted(vars(math)) if not name.startswith(..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.3072476387023926, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import Any, Callable, Optional, Tuple, Type, Union, cast\n\nfrom pydantic_core import CoreSchema, PydanticCustomError, ..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/color.py", "score": 0.30482885241508484, "span_start": null, "span_end": null, "passage": "`<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg"}, {"qid": "", "rank": 10, "path": "pydantic/color.py", "score": 0.3030496835708618, "span_start": null, "span_end": null, "passage": "Args:\n            alpha: Whether to include the alpha channel - `None` (default): Include the alpha channel only if it's set (e.g not `None`) - `True`: Always include alpha - `False`: Always omit alph..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/color.py", "score": 0.3011864423751831, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union, cast\n\nfrom pydantic.v1.errors import ColorError\nfrom pydantic..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.2955448031425476, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 13, "path": "pydantic/color.py", "score": 0.29438114166259766, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_typing_extra.py", "score": 0.28381627798080444, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/color.py", "score": 0.28154781460762024, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)\n        if alpha is None:\n     ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.2798578441143036, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 17, "path": "tests/test_types.py", "score": 0.2792486250400543, "span_start": null, "span_end": null, "passage": "str_min_length: constr(min_length=5) = .. str_email: EmailStr = .. name_email: NameEmail = .."}, {"qid": "", "rank": 18, "path": "tests/test_types.py", "score": 0.2792486250400543, "span_start": null, "span_end": null, "passage": "str_min_length: constr(min_length=5) = .. str_email: EmailStr = .. name_email: NameEmail = .."}, {"qid": "", "rank": 19, "path": "tests/test_validate_call.py", "score": 0.2789824306964874, "span_start": null, "span_end": null, "passage": "This test is just to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n    globs = {}\n    exec(\n        \"\"\"\nfrom typing import Iterable\nfrom pydantic import validate_call\n\n@validate..."}, {"qid": "", "rank": 20, "path": "pydantic/color.py", "score": 0.27868056297302246, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}], "latency_ms": 4.58979606628418, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_bd94f629", "query": "find function as_hsl_tuple", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/color.py", "score": 0.47469016909599304, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.4613722860813141, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.420829176902771, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators.py", "score": 0.4082399308681488, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # Define the types we want to check against as a single tuple"}, {"qid": "", "rank": 5, "path": "pydantic/v1/color.py", "score": 0.40607166290283203, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = 'r', 'g', 'b', 'alpha', '_tuple'\n\n    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):\n        self.r = r\n        self.g = g\n        self.b = b\n        se..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_generics.py", "score": 0.39675500988960266, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3941255211830139, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if is_typeddict(tp):\n        return tp.__orig_bases__  # type: ignore\n    try:\n        return tp.__bases__\n    except AttributeError:\n        return ()\n\n\ndef mro(tp: type[Any]) -> tuple[type[A..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/color.py", "score": 0.39266180992126465, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 9, "path": "pydantic/warnings.py", "score": 0.38954758644104004, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    message: str\n    since: tuple[int, int]\n    expected_removal: tuple[int, int]\n\n    def __init__(\n        self, message: str, *args: object, since: tuple[int, int], expected_removal: tuple[int..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generate_schema.py", "score": 0.38746318221092224, "span_start": null, "span_end": null, "passage": "`tuple[int, str]` or `tuple[int, ...]`.\"\"\"\n        # TODO: do we really need to resolve type vars here"}, {"qid": "", "rank": 11, "path": "pydantic/v1/errors.py", "score": 0.38457489013671875, "span_start": null, "span_end": null, "passage": "Note: the callable can't be a lambda as pickle looks in the namespace to find it\n    \"\"\"\n    return cls(**ctx)\n\n\nclass PydanticErrorMixin:\n    code: str\n    msg_template: str\n\n    def __init__(self, *..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/utils.py", "score": 0.38073235750198364, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return list(self)\n\n    def values(self) -> List[Any]:\n        return [self[k] for k in self]\n\n    def items(self) -> Iterator[Tuple[str, Any]]:\n        for k in self:\n            yield k, ..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/color.py", "score": 0.37679654359817505, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union, cast\n\nfrom pydantic.v1.errors import ColorError\nfrom pydantic..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/fields.py", "score": 0.37516945600509644, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        try:\n            iterable = iter(v)\n        except TypeError:\n            return v, ErrorWrapper(errors_.IterableError(), loc)\n        return iterable, None\n\n    def _validate_tuple(\n    ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/color.py", "score": 0.3691568076610565, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 16, "path": "pydantic/color.py", "score": 0.36618173122406006, "span_start": null, "span_end": null, "passage": "Args:\n        value: A tuple or list Returns:\n        An `RGBA` tuple parsed from the input tuple Raises:\n        PydanticCustomError: If tuple is not valid"}, {"qid": "", "rank": 17, "path": "pydantic/v1/color.py", "score": 0.3640286922454834, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 18, "path": "tests/test_validate_call.py", "score": 0.36093413829803467, "span_start": null, "span_end": null, "passage": "This test is just to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n    globs = {}\n    exec(\n        \"\"\"\nfrom typing import Iterable\nfrom pydantic import validate_call\n\n@validate..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.3594280481338501, "span_start": null, "span_end": null, "passage": "Use `tuple_schema` instead.',\n            PydanticDeprecatedSince26,\n            stacklevel=2,\n        )\n        return self.tuple_schema(schema)\n\n    def tuple_schema(self, schema: core_schema.TupleS..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_typing_extra.py", "score": 0.35885342955589294, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}], "latency_ms": 4.021167755126953, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_0270b388", "query": "find function _alpha_float", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.40689462423324585, "span_start": null, "span_end": null, "passage": "Args:\n        c: The float value to be converted Must be between 0 and 1 (inclusive) Returns:\n        The integer equivalent of the given float value rounded to the nearest whole number Raises:\n      ..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.36727994680404663, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        color = float(value)\n    except ValueError:\n        raise PydanticCustomError('color_error', 'value is not a valid color: color values must be a valid number')\n    if 0 <= color <..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/color.py", "score": 0.3639081120491028, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 4, "path": "pydantic/color.py", "score": 0.36309126019477844, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 5, "path": "pydantic/color.py", "score": 0.3489581346511841, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 6, "path": "docs/plugins/conversion_table.py", "score": 0.3448653817176819, "span_start": null, "span_end": null, "passage": "`val % 1 == 0`, raises error for `nan`, `inf`.',\n        valid_examples=[2.0],\n        invalid_examples=[2.1, 2.2250738585072011e308, float('nan'), float('inf')],\n        core_schemas=[core_schema.Int..."}, {"qid": "", "rank": 7, "path": "pydantic/color.py", "score": 0.34485360980033875, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/color.py", "score": 0.34452271461486816, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.3438107371330261, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 10, "path": "pydantic/types.py", "score": 0.3434041738510132, "span_start": null, "span_end": null, "passage": "Args:\n        strict: Whether to validate the float in strict mode gt: The value must be greater than this ge: The value must be greater than or equal to this lt: The value must be less than this le: ..."}, {"qid": "", "rank": 11, "path": "pydantic/color.py", "score": 0.3379950523376465, "span_start": null, "span_end": null, "passage": "Args:\n            alpha: Whether to include the alpha channel There are three options for this input:\n\n                - `None` (default): Include alpha only if it's set (e.g not `None`)\n             ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/color.py", "score": 0.3228757083415985, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 13, "path": "pydantic/color.py", "score": 0.32140016555786133, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/color.py", "score": 0.3185473680496216, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 15, "path": "pydantic/color.py", "score": 0.310260534286499, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/color.py", "score": 0.30727919936180115, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = 'r', 'g', 'b', 'alpha', '_tuple'\n\n    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):\n        self.r = r\n        self.g = g\n        self.b = b\n        se..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.2993869185447693, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, StrictFloat, ValidationError\n\nclass StrictFloatModel(BaseModel):\n    strict_float: StrictFloat\n\ntry:\n    StrictFloatModel(strict_float='1.0')\nexcept ValidationErr..."}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.2965932786464691, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if decimal:\n            divisor = 1000\n            units = 'B', 'KB', 'MB', 'GB', 'TB', 'PB'\n            final_unit = 'EB'\n        else:\n            divisor = 1024\n            units = 'B',..."}, {"qid": "", "rank": 19, "path": "pydantic/types.py", "score": 0.2911939024925232, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 20, "path": "pydantic/color.py", "score": 0.2898075580596924, "span_start": null, "span_end": null, "passage": "Args:\n        value: The input value to parse Returns:\n        The parsed value as a float, or `None` if the value was None or equal 1 Raises:\n        PydanticCustomError: If the input value cannot be..."}], "latency_ms": 4.359006881713867, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_f7b718c5", "query": "find function __get_pydantic_core_schema__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generate_schema.py", "score": 0.7468894124031067, "span_start": null, "span_end": null, "passage": "Note: `__get_pydantic_core_schema__` takes priority so it can\n        decide whether to use a `__pydantic_core_schema__` attribute, or generate a fresh schema"}, {"qid": "", "rank": 2, "path": "pydantic/functional_serializers.py", "score": 0.6876437067985535, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    func: core_schema.WrapSerializerFunction\n    return_type: Any = PydanticUndefined\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always'\n\n    def __get_pydanti..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6727609038352966, "span_start": null, "span_end": null, "passage": "Args:\n            obj: The object to generate core schema for from_dunder_get_core_schema: Whether to generate schema from either the\n                `__get_pydantic_core_schema__` function or `__pyda..."}, {"qid": "", "rank": 4, "path": "pydantic/functional_serializers.py", "score": 0.6658551692962646, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    func: core_schema.SerializerFunction\n    return_type: Any = PydanticUndefined\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always'\n\n    def __get_pydantic_co..."}, {"qid": "", "rank": 5, "path": "pydantic/main.py", "score": 0.6509600281715393, "span_start": null, "span_end": null, "passage": "if not cls.__pydantic_generic_metadata__['origin']:\n                return cls.__pydantic_core_schema__\n\n        return handler(source)\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        ..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_generate_schema.py", "score": 0.644589364528656, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # avoid calling `__get_pydantic_core_schema__` if we've already visited this object\n        if is_self_type(obj):\n            obj = self.model_type_stack.get()\n        with self.defs.get_s..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_core_utils.py", "score": 0.6296848654747009, "span_start": null, "span_end": null, "passage": "#   Issue: https://github.com/pydantic/pydantic-core/issues/615\n\n\nclass _WalkCoreSchema:\n    def __init__(self):\n        self._schema_type_to_method = self._build_schema_type_to_method()\n\n    def _bui..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.6280010938644409, "span_start": null, "span_end": null, "passage": "Returns:\n            A dictionary containing the mapping of `CoreSchemaOrFieldType` to a handler method Raises:\n            TypeError: If no method has been defined for generating a JSON schema for a ..."}, {"qid": "", "rank": 9, "path": "pydantic/annotated_handlers.py", "score": 0.6266933083534241, "span_start": null, "span_end": null, "passage": "Returns:\n            CoreSchema: The `pydantic-core` CoreSchema generated \"\"\"\n        raise NotImplementedError\n\n    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema, /) -> core_s..."}, {"qid": "", "rank": 10, "path": "tests/test_main.py", "score": 0.6228336691856384, "span_start": null, "span_end": null, "passage": "InnerModel.__get_pydantic_core_schema__ gets called:\n    # 1 When InnerModel is defined\n    # 2 When OuterModel is defined\n    # 3"}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6177240610122681, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def get_ref(s: CoreSchema) -> str:\n            return s['ref']  # type: ignore\n\n        if schema['type'] == 'definitions':\n            self.defs.definitions.update({get_ref(s): s for s i..."}, {"qid": "", "rank": 12, "path": "tests/test_internal.py", "score": 0.6119368672370911, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nfrom dataclasses import dataclass\n\nimport pytest\nfrom pydantic_core import CoreSchema, SchemaValidator\nfrom pydantic_core import core_schema as cs\n\nfrom pydantic._internal._core_utils import (\n  ..."}, {"qid": "", "rank": 13, "path": "pydantic/functional_validators.py", "score": 0.6090750694274902, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item, SkipValidation()]\n\n        @classmethod\n        def __get_pydantic_core_schema__(cls, source: Any, handler..."}, {"qid": "", "rank": 14, "path": "pydantic/annotated_handlers.py", "score": 0.6089309453964233, "span_start": null, "span_end": null, "passage": "This will call the next CoreSchema modifying function up until it calls\n        into Pydantic's internal schema generation machinery, which will raise a\n        `pydantic.errors.PydanticSchemaGenerati..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.6076639890670776, "span_start": null, "span_end": null, "passage": "import ConfigDict\n    from ._internal._core_utils import CoreSchemaField, CoreSchemaOrField\n    from ._internal._dataclasses import PydanticDataclass\n    from ._internal._schema_generation_shared impo..."}, {"qid": "", "rank": 16, "path": "tests/test_edge_cases.py", "score": 0.5996978282928467, "span_start": null, "span_end": null, "passage": "import functools\nimport importlib.util\nimport re\nimport sys\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Hashable\nfrom decimal import Decimal\nfrom enum import Enum, auto\nfrom typing..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5989409685134888, "span_start": null, "span_end": null, "passage": "\"\"\"\n        schema: CoreSchema | None = None\n\n        if from_dunder_get_core_schema:\n            from_property = self._generate_schema_from_property(obj, obj)\n            if from_property is not None..."}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.596278727054596, "span_start": null, "span_end": null, "passage": "```py\n        from pydantic import BaseModel, ImportString\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # Create an instance\n        m = ImportThings(obj='math.cos'..."}, {"qid": "", "rank": 19, "path": "tests/test_deprecated.py", "score": 0.5955310463905334, "span_start": null, "span_end": null, "passage": "import platform\nimport re\nfrom datetime import date, timedelta\nfrom pathlib import Path\nfrom types import SimpleNamespace\nfrom typing import Any, Dict, Iterable, List, Type\n\nimport pytest\nfrom pydanti..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_core_utils.py", "score": 0.593239963054657, "span_start": null, "span_end": null, "passage": "\"\"\"\nHAS_INVALID_SCHEMAS_METADATA_KEY = 'pydantic.internal.invalid'\n\"\"\"Used to mark a schema that is invalid because it refers to a definition that was not yet defined when the\nschema was first encount..."}], "latency_ms": 4.669189453125, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_761c8d81", "query": "find function _validate", "results": [{"qid": "", "rank": 1, "path": "tests/test_validate_call.py", "score": 0.5185614228248596, "span_start": null, "span_end": null, "passage": "This test is just to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n    globs = {}\n    exec(\n        \"\"\"\nfrom typing import Iterable\nfrom pydantic import validate_call\n\n@validate..."}, {"qid": "", "rank": 2, "path": "pydantic/v1/decorator.py", "score": 0.5132704973220825, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def validate(_func: 'AnyCallable') -> 'AnyCallable':\n        vd = ValidatedFunction(_func, config)\n\n        @wraps(_func)\n        def wrapper_function(*args: Any, **kwargs: Any) -> Any:\n     ..."}, {"qid": "", "rank": 3, "path": "pydantic/functional_validators.py", "score": 0.49876001477241516, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 4, "path": "pydantic/functional_validators.py", "score": 0.4987599849700928, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 5, "path": "pydantic/functional_validators.py", "score": 0.4987599849700928, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 6, "path": "pydantic/functional_validators.py", "score": 0.4987599849700928, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 7, "path": "pydantic/v1/mypy.py", "score": 0.4886016845703125, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 8, "path": "pydantic/mypy.py", "score": 0.4886016845703125, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 9, "path": "tests/mypy/modules/fail4.py", "score": 0.4828459620475769, "span_start": null, "span_end": null, "passage": "from typing import Any\n\nfrom pydantic import BaseModel, root_validator, validate_call\n\n\n@validate_call\ndef foo(a: int, *, c: str = 'x') -> str:\n    return c * a\n\n\n# ok\nx: str = foo(1, c='hello')\n# fai..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/class_validators.py", "score": 0.48110485076904297, "span_start": null, "span_end": null, "passage": "def root_validator(\n    _func: Optional[AnyCallable] = None, *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False\n) -> Union['AnyClassMethod', Callable[[AnyCallable], 'AnyCla..."}, {"qid": "", "rank": 11, "path": "pydantic/deprecated/decorator.py", "score": 0.4803110659122467, "span_start": null, "span_end": null, "passage": "@deprecated(\n    'The `validate_arguments` method is deprecated; use `validate_call` instead.',\n    category=None,\n)\ndef validate_arguments(func: Optional['AnyCallableT'] = None, *, config: 'ConfigTyp..."}, {"qid": "", "rank": 12, "path": "pydantic/deprecated/class_validators.py", "score": 0.47480830550193787, "span_start": null, "span_end": null, "passage": "Returns:\n        Any: A decorator that can be used to decorate a function to be used as a root_validator"}, {"qid": "", "rank": 13, "path": "pydantic/v1/class_validators.py", "score": 0.4746989607810974, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if _func:\n        f_cls = _prepare_validator(_func, allow_reuse)\n        setattr(\n            f_cls, ROOT_VALIDATOR_CONFIG_KEY, Validator(func=f_cls.__func__, pre=pre, skip_on_failure=skip_on_..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4735155701637268, "span_start": null, "span_end": null, "passage": "An error is raised if the function has an invalid signature Args:\n        validator: The validator function to inspect mode: The proposed validator mode Returns:\n        Whether the validator takes an..."}, {"qid": "", "rank": 15, "path": "pydantic/validate_call_decorator.py", "score": 0.4701528251171112, "span_start": null, "span_end": null, "passage": "Usage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)` Args:\n        func: The function to be decorated config: The configuration dictionary validate_return:..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4665191173553467, "span_start": null, "span_end": null, "passage": "\"\"\"\n    ref: str | None = schema.pop('ref', None)  # type: ignore\n    for validator in validators:\n        if mode == 'inner' and validator.info.mode != 'before':\n            continue\n        if mode ..."}, {"qid": "", "rank": 17, "path": "pydantic/mypy.py", "score": 0.46267837285995483, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n            ..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/fields.py", "score": 0.46238216757774353, "span_start": null, "span_end": null, "passage": "\"\"\"\n        self.validate_always = getattr(self.type_, 'validate_always', False) or any(\n            v.always for v in self.class_validators.values()\n        )\n\n        class_validators_ = self.class_..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/class_validators.py", "score": 0.45610541105270386, "span_start": null, "span_end": null, "passage": "\"\"\"\n    from inspect import signature\n\n    if not isinstance(validator, (partial, partialmethod)):\n        # This should be the default case, so overhead is reduced\n        sig = signature(validator)\n..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_decorators.py", "score": 0.4546080231666565, "span_start": null, "span_end": null, "passage": "This function should only be used to inspect signatures of validation and serialization functions The first argument (the value being serialized or validated) is counted as a required argument\n    eve..."}], "latency_ms": 4.301548004150391, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_b2fc2027", "query": "find function __str__", "results": [{"qid": "", "rank": 1, "path": "pydantic/types.py", "score": 0.4036177396774292, "span_start": null, "span_end": null, "passage": "It displays `b'**********'` instead of the string value on `repr()` and `str()` calls When the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\n    calls..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.39280638098716736, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/error_wrappers.py", "score": 0.39030081033706665, "span_start": null, "span_end": null, "passage": "code = getattr(cls, 'code', None) or cls.__name__.replace('Error', '').lower()\n    return base_name + '.' + code"}, {"qid": "", "rank": 4, "path": "tests/test_types.py", "score": 0.3863140046596527, "span_start": null, "span_end": null, "passage": "str_min_length: constr(min_length=5) = .. str_email: EmailStr = .. name_email: NameEmail = .."}, {"qid": "", "rank": 5, "path": "tests/test_types.py", "score": 0.3863140046596527, "span_start": null, "span_end": null, "passage": "str_min_length: constr(min_length=5) = .. str_email: EmailStr = .. name_email: NameEmail = .."}, {"qid": "", "rank": 6, "path": "tests/test_types.py", "score": 0.38542890548706055, "span_start": null, "span_end": null, "passage": "str_gt: Annotated[str, annotated_types.Gt('a')]\n\n    m = MoreStringsModel(\n        str_strip_enabled='   xxx123   ',\n        str_strip_disabled='   xxx123   ',\n        str_regex='xxx123',\n        str_..."}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.379711389541626, "span_start": null, "span_end": null, "passage": "When the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in\n    calls to `repr()` and `str()` If the value _is_ empty, it is displayed as `''`"}, {"qid": "", "rank": 8, "path": "pydantic/warnings.py", "score": 0.35752975940704346, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    message: str\n    since: tuple[int, int]\n    expected_removal: tuple[int, int]\n\n    def __init__(\n        self, message: str, *args: object, since: tuple[int, int], expected_removal: tuple[int..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_decorators.py", "score": 0.35107260942459106, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 10, "path": "pydantic/types.py", "score": 0.34925663471221924, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._secret_value\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()\n\n    def __has..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/mypy.py", "score": 0.3402215838432312, "span_start": null, "span_end": null, "passage": "\"\"\"\n    fn = x.fullname\n    if callable(fn):  # pragma: no cover\n        return fn()\n    return fn\n\n\ndef get_name(x: Union[FuncBase, SymbolNode]) -> str:\n    \"\"\"\n    Used for compatibility with mypy 0..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.33198845386505127, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_typing_extra.py", "score": 0.33168458938598633, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    @typing.no_type_check\n    def get_type_hints(  # noqa: C901\n        obj: Any,\n        globalns: dict[str, Any] | None = None,\n        localns: dict[str, Any] | None = None,\n        include_ex..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generics.py", "score": 0.3286448121070862, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 15, "path": "pydantic/experimental/pipeline.py", "score": 0.32776832580566406, "span_start": null, "span_end": null, "passage": "import inspect\n\n            try:\n                # remove ')' suffix, can use removesuffix once we drop 3.8\n                source = inspect.getsource(func).strip()\n                if source.endswith(..."}, {"qid": "", "rank": 16, "path": "tests/test_validate_call.py", "score": 0.32522332668304443, "span_start": null, "span_end": null, "passage": "This test is just to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n    globs = {}\n    exec(\n        \"\"\"\nfrom typing import Iterable\nfrom pydantic import validate_call\n\n@validate..."}, {"qid": "", "rank": 17, "path": "tests/test_typing.py", "score": 0.32489705085754395, "span_start": null, "span_end": null, "passage": "import sys\nimport typing\nfrom collections import namedtuple\nfrom typing import Callable, ClassVar, ForwardRef, NamedTuple\n\nimport pytest\nfrom typing_extensions import Literal, get_origin\n\nfrom pydanti..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generics.py", "score": 0.3243345618247986, "span_start": null, "span_end": null, "passage": "# `typing.Callable[[int, str], int]` is an example for this if isinstance(type_, (List, list)):\n        resolved_list = list(replace_types(element, type_map) for element in type_)\n        if all_ident..."}, {"qid": "", "rank": 19, "path": "tests/test_types.py", "score": 0.32357510924339294, "span_start": null, "span_end": null, "passage": "assert f.password.__class__.__name__ == 'SecretStr'\n    assert f.empty_password.__class__.__name__ == 'SecretStr'\n\n    # Assert str and repr are correct"}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_repr.py", "score": 0.3235663175582886, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n\nclass Representation:\n    # Mixin to provide `__str__`, `__repr__`, and `__pretty__` and `__rich_repr__` methods # `__pretty__` is used b..."}], "latency_ms": 3.5905838012695312, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_9d0ba9d6", "query": "find function __repr_args__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_utils.py", "score": 0.5103055238723755, "span_start": null, "span_end": null, "passage": "def __repr_args__(self) -> _repr.ReprArgs:\n        return [(None, self._items)]\n\n\nif typing.TYPE_CHECKING:\n\n    def ClassAttribute(name: str, value: T) -> T: .."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_repr.py", "score": 0.47687292098999023, "span_start": null, "span_end": null, "passage": "Takes some logic from `typing._type_repr`"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generate_schema.py", "score": 0.46232378482818604, "span_start": null, "span_end": null, "passage": "def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n        args = get_args(obj)\n        if args:\n            args = tuple([self._resolve_forward_re..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/utils.py", "score": 0.45966848731040955, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__: Tuple[str, ...] = tuple()\n\n    def __repr_args__(self) -> 'ReprArgs':\n        \"\"\"\n        Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally over..."}, {"qid": "", "rank": 5, "path": "pydantic/mypy.py", "score": 0.42882466316223145, "span_start": null, "span_end": null, "passage": "first = [Argument(Var('__pydantic_self__'), self_type, None, ARG_POS)]\n    args = first + args\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_repr.py", "score": 0.4204232692718506, "span_start": null, "span_end": null, "passage": "# (this is not a docstring to avoid adding a docstring to classes which inherit from Representation)\n\n    # we don't want to use a type annotation here as it can break get_type_hints\n    __slots__ = t..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generics.py", "score": 0.41529276967048645, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.414639949798584, "span_start": null, "span_end": null, "passage": "Args:\n            core_ref: The core reference to get the definitions reference for Returns:\n            A tuple of the definitions reference and the JSON schema that will refer to it"}, {"qid": "", "rank": 9, "path": "pydantic/v1/typing.py", "score": 0.4069089889526367, "span_start": null, "span_end": null, "passage": "Examples::\n            get_args(Dict[str, int]) == (str, int)\n            get_args(int) == ()\n            get_args(Union[int, Union[T, int], str][int]) == (int, str)\n            get_args(Union[int, Tu..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/typing.py", "score": 0.3965703547000885, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if type(t).__name__ in AnnotatedTypeNames:\n            return t.__args__ + t.__metadata__\n        if isinstance(t, _GenericAlias):\n            res = t.__args__\n            if t.__origin__ ..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/mypy.py", "score": 0.3912193775177002, "span_start": null, "span_end": null, "passage": "Returns a list of mypy Argument instances for use in the generated signatures"}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.3912193775177002, "span_start": null, "span_end": null, "passage": "Returns a list of mypy Argument instances for use in the generated signatures"}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.3884933590888977, "span_start": null, "span_end": null, "passage": "When the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in\n    calls to `repr()` and `str()` If the value _is_ empty, it is displayed as `''`"}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.3860081732273102, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3813021779060364, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return typing.ForwardRef(arg, is_argument)\n\nelse:\n    _make_forward_ref = typing.ForwardRef\n\n\nif sys.version_info >= (3, 10):\n    get_type_hints = typing.get_type_hints\n\nelse:\n    \"\"\"\n    ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generate_schema.py", "score": 0.38022470474243164, "span_start": null, "span_end": null, "passage": "@overload\n    def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None: .."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.38019803166389465, "span_start": null, "span_end": null, "passage": "It displays `b'**********'` instead of the string value on `repr()` and `str()` calls When the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\n    calls..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3791312277317047, "span_start": null, "span_end": null, "passage": "type_hints.setdefault('return', function)\n        return type_hints\n\n    globalns = add_module_globals(function)\n    type_hints = {}\n    type_params: tuple[Any] = getattr(function, '__type_params__', ..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/utils.py", "score": 0.37885820865631104, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.__class__.__name__\n\n    def __repr_str__(self, join_str: str) -> str:\n        return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())\n\n   ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.3774033784866333, "span_start": null, "span_end": null, "passage": "Args:\n            maybe_ref_schema: The input core schema that may contains reference Returns:\n            Resolved core schema Raises:\n            LookupError: If it can't find the definition for ref..."}], "latency_ms": 3.5140514373779297, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_6a876ef3", "query": "find function __eq__", "results": [{"qid": "", "rank": 1, "path": "pydantic/experimental/pipeline.py", "score": 0.34168463945388794, "span_start": null, "span_end": null, "passage": "import inspect\n\n            try:\n                # remove ')' suffix, can use removesuffix once we drop 3.8\n                source = inspect.getsource(func).strip()\n                if source.endswith(..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_decorators.py", "score": 0.31624677777290344, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generics.py", "score": 0.31315070390701294, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 4, "path": "pydantic/v1/mypy.py", "score": 0.3079681098461151, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 5, "path": "pydantic/mypy.py", "score": 0.3079681098461151, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_generics.py", "score": 0.3041796088218689, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except Attribu..."}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.3037727475166321, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._secret_value\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()\n\n    def __has..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2997288703918457, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 9, "path": "pydantic/types.py", "score": 0.2991846203804016, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 10, "path": "pydantic/v1/types.py", "score": 0.29743945598602295, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()\n\n    def __str__(self) -> str:\n        return '*..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.29451480507850647, "span_start": null, "span_end": null, "passage": "unwrap_types = (\n        (property, cached_property)\n        + ((partial, partialmethod) if unwrap_partial else ())\n        + ((staticmethod, classmethod) if unwrap_class_static_method else ())\n    )\n..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_typing_extra.py", "score": 0.2919243276119232, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 13, "path": "tests/test_validate_call.py", "score": 0.2903811037540436, "span_start": null, "span_end": null, "passage": "This test is just to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n    globs = {}\n    exec(\n        \"\"\"\nfrom typing import Iterable\nfrom pydantic import validate_call\n\n@validate..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.2892305254936218, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_decorators.py", "score": 0.27999740839004517, "span_start": null, "span_end": null, "passage": "If we do replace any functions we put the replacement into the position\n        the replaced function was in; that is, we maintain the order"}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_decorators.py", "score": 0.2778871953487396, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_utils.py", "score": 0.2718796133995056, "span_start": null, "span_end": null, "passage": "\"\"\"Bucket of reusable internal utilities This should be reduced as much as possible with functions only used in one place, moved to that place"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generate_schema.py", "score": 0.2689563035964966, "span_start": null, "span_end": null, "passage": "def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n        args = get_args(obj)\n        if args:\n            args = tuple([self._resolve_forward_re..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.2678096294403076, "span_start": null, "span_end": null, "passage": "st.register_type_strategy(pydantic.StrictBool, st.booleans())\nst.register_type_strategy(pydantic.StrictStr, st.text())\n\n\n# FutureDate, PastDate\nst.register_type_strategy(pydantic.FutureDate, st.dates(..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.2646520435810089, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}], "latency_ms": 3.679513931274414, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_1522beba", "query": "find function __hash__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_model_construction.py", "score": 0.46214890480041504, "span_start": null, "span_end": null, "passage": "cls.__hash__ = new_hash_func\n\n\ndef make_hash_func(cls: type[BaseModel]) -> Any:\n    getter = operator.itemgetter(*cls.model_fields.keys()) if cls.model_fields else lambda _: 0\n\n    def hash_func(self:..."}, {"qid": "", "rank": 2, "path": "tests/test_main.py", "score": 0.4599406123161316, "span_start": null, "span_end": null, "passage": "# This could change the hash, and more importantly hashing shouldn't raise a KeyError\n    # We don't assert here, because a hash collision is possible: the hash is not guaranteed to change\n    # Howev..."}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.45216989517211914, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._secret_value\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()\n\n    def __has..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/types.py", "score": 0.4407469630241394, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()\n\n    def __str__(self) -> str:\n        return '*..."}, {"qid": "", "rank": 5, "path": "pydantic/networks.py", "score": 0.4361976981163025, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    max_length: int | None = None\n    allowed_schemes: list[str] | None = None\n    host_required: bool | None = None\n    default_host: str | None = None\n    default_port: int | None = None\n    de..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_model_construction.py", "score": 0.425584077835083, "span_start": null, "span_end": null, "passage": "# It will be `None` if not overridden from BaseModel # It may be `object.__hash__` if there is another\n        # parent class earlier in the bases which doesn't override `__hash__` (e.g `typing.Generi..."}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.40847957134246826, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return super(EncodedStr, self).encode(value=value.encode()).decode()  # noqa: UP008\n\n    def __hash__(self) -> int:\n        return hash(self.encoder)\n\n\nBase64Bytes = Annotated[bytes, Encod..."}, {"qid": "", "rank": 8, "path": "tests/test_main.py", "score": 0.37904930114746094, "span_start": null, "span_end": null, "passage": "m.__dict__['c'] = 1\n    assert hash(m) == h\n\n    # Order of keys can be changed, e.g with the deprecated copy method, which shouldn't matter m.__dict__ = {'b': 2, 'a': 1}\n    assert hash(m) == h\n\n    ..."}, {"qid": "", "rank": 9, "path": "pydantic/types.py", "score": 0.3409290313720703, "span_start": null, "span_end": null, "passage": "Example:\n        ```python\n        from typing_extensions import Annotated\n\n        from pydantic.types import Strict\n\n        StrictBool = Annotated[bool, Strict()]\n        ```\n    \"\"\"\n\n    strict: b..."}, {"qid": "", "rank": 10, "path": "pydantic/types.py", "score": 0.3405526578426361, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.encoder.encode(value)\n\n    def __hash__(self) -> int:\n        return hash(self.encoder)\n\n\n@_dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass EncodedStr(EncodedByte..."}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.3366564214229584, "span_start": null, "span_end": null, "passage": "first = [Argument(Var('__pydantic_self__'), self_type, None, ARG_POS)]\n    args = first + args\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_model_construction.py", "score": 0.334476500749588, "span_start": null, "span_end": null, "passage": "# getter(self.__dict__) is much faster than any 'safe' method that accounts for missing keys,\n            # and wrapping it in a `try` doesn't slow things down much in the common case return hash(gett..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/validators.py", "score": 0.33116614818573, "span_start": null, "span_end": null, "passage": "import math\nimport re\nfrom collections import OrderedDict, deque\nfrom collections.abc import Hashable as CollectionsHashable\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import De..."}, {"qid": "", "rank": 14, "path": "tests/test_types.py", "score": 0.329692006111145, "span_start": null, "span_end": null, "passage": "assert str(f.password) == '**********'\n    assert str(f.empty_password) == ''\n    assert repr(f.password) == \"DecryptableStr('**********')\"\n    assert repr(f.empty_password) == \"SecretStr('')\"\n    ass..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.3262147307395935, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_decorators.py", "score": 0.31700795888900757, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys=..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3101535141468048, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generics.py", "score": 0.3088541030883789, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3019072413444519, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_fields.py", "score": 0.29966187477111816, "span_start": null, "span_end": null, "passage": "Args:\n        **metadata: The metadata to add Returns:\n        The new `_PydanticGeneralMetadata` class"}], "latency_ms": 3.7698745727539062, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_7e5d265c", "query": "find function parse_tuple", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/typing.py", "score": 0.5165244340896606, "span_start": null, "span_end": null, "passage": "do have an empty `__args__` by default (instead of the generic ~T for example) In order to still support `Dict` for example and consider it as `Dict[Any, Any]`,\n        we retrieve the `_nparams` valu..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_decorators.py", "score": 0.49963727593421936, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # Define the types we want to check against as a single tuple"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4985462725162506, "span_start": null, "span_end": null, "passage": "`tuple[int, str]` or `tuple[int, ...]`.\"\"\"\n        # TODO: do we really need to resolve type vars here"}, {"qid": "", "rank": 4, "path": "pydantic/warnings.py", "score": 0.4820842146873474, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    message: str\n    since: tuple[int, int]\n    expected_removal: tuple[int, int]\n\n    def __init__(\n        self, message: str, *args: object, since: tuple[int, int], expected_removal: tuple[int..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4761804938316345, "span_start": null, "span_end": null, "passage": "typevars_map = get_standard_typevars_map(tuple_type)\n        params = self._get_args_resolving_forward_refs(tuple_type)\n\n        if typevars_map and params:\n            params = tuple(replace_types(pa..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/color.py", "score": 0.4652824401855469, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/utils.py", "score": 0.46336525678634644, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__: Tuple[str, ...] = tuple()\n\n    def __repr_args__(self) -> 'ReprArgs':\n        \"\"\"\n        Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally over..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/utils.py", "score": 0.46172478795051575, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return list(self)\n\n    def values(self) -> List[Any]:\n        return [self[k] for k in self]\n\n    def items(self) -> Iterator[Tuple[str, Any]]:\n        for k in self:\n            yield k, ..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generics.py", "score": 0.44637271761894226, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 10, "path": "pydantic/v1/typing.py", "score": 0.44586339592933655, "span_start": null, "span_end": null, "passage": "`Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`\n    \"\"\"\n    if not is_literal_type(type_):\n        return (type_,)\n\n    values = literal_values(type_)\n    return tuple(x for value in values for x..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/color.py", "score": 0.44567450881004333, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = 'r', 'g', 'b', 'alpha', '_tuple'\n\n    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):\n        self.r = r\n        self.g = g\n        self.b = b\n        se..."}, {"qid": "", "rank": 12, "path": "pydantic/main.py", "score": 0.44408464431762695, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __iter__(self) -> TupleGenerator:\n        \"\"\"So `dict(model)` works.\"\"\"\n        yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n        extra = self.__pyd..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/typing.py", "score": 0.4435153901576996, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if type(t).__name__ in AnnotatedTypeNames:\n            return t.__args__ + t.__metadata__\n        if isinstance(t, _GenericAlias):\n            res = t.__args__\n            if t.__origin__ ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_typing_extra.py", "score": 0.4313107132911682, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not is_literal_type(type_):\n        return [type_]\n\n    values = literal_values(type_)\n    return list(x for value in values for x in all_literal_values(value))\n\n\ndef is_annotated(ann_type:..."}, {"qid": "", "rank": 15, "path": "pydantic/color.py", "score": 0.43000003695487976, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/fields.py", "score": 0.42775267362594604, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        try:\n            iterable = iter(v)\n        except TypeError:\n            return v, ErrorWrapper(errors_.IterableError(), loc)\n        return iterable, None\n\n    def _validate_tuple(\n    ..."}, {"qid": "", "rank": 17, "path": "tests/test_tools.py", "score": 0.4238250255584717, "span_start": null, "span_end": null, "passage": "from typing import Dict, List, Mapping, Union\n\nimport pytest\n\nfrom pydantic import BaseModel, PydanticDeprecatedSince20, ValidationError\nfrom pydantic.dataclasses import dataclass\nfrom pydantic.deprec..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.42171627283096313, "span_start": null, "span_end": null, "passage": "Args:\n        value: A tuple or list Returns:\n        An `RGBA` tuple parsed from the input tuple Raises:\n        PydanticCustomError: If tuple is not valid"}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_generate_schema.py", "score": 0.41987624764442444, "span_start": null, "span_end": null, "passage": "If a definition exists, a tuple of `(ref_string, CoreSchema)` is returned If no definition exists yet, a tuple of `(ref_string, None)` is returned Note that the returned `CoreSchema` will always be a ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_decorators.py", "score": 0.4198148846626282, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if isinstance(tp, tuple):\n        for base in mro_for_bases(tp):\n            attribute = base.__dict__.get(name, _sentinel)\n            if attribute is not _sentinel:\n                attribute..."}], "latency_ms": 3.826141357421875, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_f39af192", "query": "find function parse_str", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/color.py", "score": 0.4370143413543701, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 2, "path": "tests/test_types.py", "score": 0.4133736193180084, "span_start": null, "span_end": null, "passage": "str_gt: Annotated[str, annotated_types.Gt('a')]\n\n    m = MoreStringsModel(\n        str_strip_enabled='   xxx123   ',\n        str_strip_disabled='   xxx123   ',\n        str_regex='xxx123',\n        str_..."}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.41233107447624207, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.4050925374031067, "span_start": null, "span_end": null, "passage": "pass\n            else:\n                block_lines = inspect.getblock(lines[lnum - 1 :])\n                dedent_source = _dedent_source_lines(block_lines)\n                try:\n                    bloc..."}, {"qid": "", "rank": 5, "path": "pydantic/types.py", "score": 0.39870119094848633, "span_start": null, "span_end": null, "passage": "It displays `b'**********'` instead of the string value on `repr()` and `str()` calls When the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\n    calls..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/error_wrappers.py", "score": 0.394206166267395, "span_start": null, "span_end": null, "passage": "code = getattr(cls, 'code', None) or cls.__name__.replace('Error', '').lower()\n    return base_name + '.' + code"}, {"qid": "", "rank": 7, "path": "tests/test_tools.py", "score": 0.3939223289489746, "span_start": null, "span_end": null, "passage": "from typing import Dict, List, Mapping, Union\n\nimport pytest\n\nfrom pydantic import BaseModel, PydanticDeprecatedSince20, ValidationError\nfrom pydantic.dataclasses import dataclass\nfrom pydantic.deprec..."}, {"qid": "", "rank": 8, "path": "pydantic/types.py", "score": 0.39050203561782837, "span_start": null, "span_end": null, "passage": "When the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in\n    calls to `repr()` and `str()` If the value _is_ empty, it is displayed as `''`"}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.3901863098144531, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 10, "path": "tests/test_types.py", "score": 0.384380042552948, "span_start": null, "span_end": null, "passage": "str_min_length: constr(min_length=5) = .. str_email: EmailStr = .. name_email: NameEmail = .."}, {"qid": "", "rank": 11, "path": "tests/test_types.py", "score": 0.384380042552948, "span_start": null, "span_end": null, "passage": "str_min_length: constr(min_length=5) = .. str_email: EmailStr = .. name_email: NameEmail = .."}, {"qid": "", "rank": 12, "path": "pydantic/v1/datetime_parse.py", "score": 0.3824525475502014, "span_start": null, "span_end": null, "passage": "\"\"\"\nFunctions to parse datetime objects We're using regular expressions rather than time.strptime because:\n- They provide both validation and parsing - They're more flexible for datetimes - The date/d..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3697606325149536, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 14, "path": "pydantic/warnings.py", "score": 0.36880362033843994, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    message: str\n    since: tuple[int, int]\n    expected_removal: tuple[int, int]\n\n    def __init__(\n        self, message: str, *args: object, since: tuple[int, int], expected_removal: tuple[int..."}, {"qid": "", "rank": 15, "path": "pydantic/parse.py", "score": 0.36675161123275757, "span_start": null, "span_end": null, "passage": "\"\"\"The `parse` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.36195939779281616, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        return data.decode()\n\n    def encode_str(self, value: str) -> str:\n        \"\"\"Encode the data using the spe..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.3573991358280182, "span_start": null, "span_end": null, "passage": "`foobar=(str, ...)` or `foobar=123`, or, for complex use-cases, in the format\n        `<name>=<Field>` or `<name>=(<type>, <FieldInfo>)`, e.g"}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.356212854385376, "span_start": null, "span_end": null, "passage": "=== \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, constr\n\n            class Foo(BaseModel):\n                bar: constr(strip_whitespace=True, to_upper=True, patter..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.35194090008735657, "span_start": null, "span_end": null, "passage": "Args:\n        value: The input value to parse Returns:\n        The parsed value as a float, or `None` if the value was None or equal 1 Raises:\n        PydanticCustomError: If the input value cannot be..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/tools.py", "score": 0.34629422426223755, "span_start": null, "span_end": null, "passage": "import json\nfrom functools import lru_cache\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Optional, Type, TypeVar, Union\n\nfrom pydantic.v1.parse import Protocol, load_file,..."}], "latency_ms": 3.9136409759521484, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_7bbb7673", "query": "find function ints_to_rgba", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/color.py", "score": 0.6261301636695862, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.6213984489440918, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.5831162929534912, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 4, "path": "pydantic/color.py", "score": 0.5524201989173889, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 5, "path": "pydantic/color.py", "score": 0.5293656587600708, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.5285863876342773, "span_start": null, "span_end": null, "passage": "Args:\n        h: The hue value h_units: The unit for hue value sat: The saturation value light: The lightness value alpha: Alpha value Returns:\n        An instance of `RGBA`"}, {"qid": "", "rank": 7, "path": "pydantic/v1/color.py", "score": 0.5211927890777588, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.5142258405685425, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.5085604786872864, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 10, "path": "pydantic/color.py", "score": 0.5032835006713867, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/color.py", "score": 0.49690374732017517, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.47729256749153137, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/color.py", "score": 0.47500157356262207, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 14, "path": "pydantic/color.py", "score": 0.4582534432411194, "span_start": null, "span_end": null, "passage": "Args:\n        r: An integer or string representing the red color value g: An integer or string representing the green color value b: An integer or string representing the blue color value alpha: A flo..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/color.py", "score": 0.4514220356941223, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 16, "path": "pydantic/color.py", "score": 0.44192051887512207, "span_start": null, "span_end": null, "passage": "Args:\n        value: A tuple or list Returns:\n        An `RGBA` tuple parsed from the input tuple Raises:\n        PydanticCustomError: If tuple is not valid"}, {"qid": "", "rank": 17, "path": "pydantic/v1/color.py", "score": 0.4397082030773163, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union, cast\n\nfrom pydantic.v1.errors import ColorError\nfrom pydantic..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/color.py", "score": 0.4367617964744568, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.43611428141593933, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import Any, Callable, Optional, Tuple, Type, Union, cast\n\nfrom pydantic_core import CoreSchema, PydanticCustomError, ..."}, {"qid": "", "rank": 20, "path": "pydantic/color.py", "score": 0.4263771176338196, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}], "latency_ms": 3.9298534393310547, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_71addb78", "query": "find function parse_color_value", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.6191750764846802, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.5798977613449097, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/color.py", "score": 0.5787103772163391, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 4, "path": "pydantic/color.py", "score": 0.5693700313568115, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 5, "path": "pydantic/color.py", "score": 0.5652133226394653, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.564250648021698, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/color.py", "score": 0.5639423131942749, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/color.py", "score": 0.5368790626525879, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.5230229496955872, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 10, "path": "pydantic/color.py", "score": 0.5115431547164917, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e..."}, {"qid": "", "rank": 11, "path": "pydantic/color.py", "score": 0.5033344030380249, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.501564621925354, "span_start": null, "span_end": null, "passage": "Args:\n            fallback: If True, falls back to returning the hexadecimal representation of\n                the color instead of raising a ValueError when no named color is found Returns:\n         ..."}, {"qid": "", "rank": 13, "path": "pydantic/color.py", "score": 0.5008558034896851, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 14, "path": "pydantic/color.py", "score": 0.48852598667144775, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        color = float(value)\n    except ValueError:\n        raise PydanticCustomError('color_error', 'value is not a valid color: color values must be a valid number')\n    if 0 <= color <..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/color.py", "score": 0.48707064986228943, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 16, "path": "pydantic/color.py", "score": 0.47931188344955444, "span_start": null, "span_end": null, "passage": "Args:\n        h: The hue value h_units: The unit for hue value sat: The saturation value light: The lightness value alpha: Alpha value Returns:\n        An instance of `RGBA`"}, {"qid": "", "rank": 17, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.47924190759658813, "span_start": null, "span_end": null, "passage": "st.register_type_strategy(\n    pydantic.PyObject,  # type: ignore[arg-type]\n    st.sampled_from(\n        [cast(pydantic.PyObject, f'math.{name}') for name in sorted(vars(math)) if not name.startswith(..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/color.py", "score": 0.4719853699207306, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.46615397930145264, "span_start": null, "span_end": null, "passage": "'\n    'See https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/.',\n    category=PydanticDeprecatedSince20,\n)\nclass Color(_repr.Representation):\n    \"\"\"Represents a color.\"\"\"\n\n    __slots__..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/color.py", "score": 0.4625306725502014, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}], "latency_ms": 3.5886764526367188, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_ce3e00c1", "query": "find function parse_float_alpha", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.4525216817855835, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.4453662633895874, "span_start": null, "span_end": null, "passage": "Args:\n        value: The input value to parse Returns:\n        The parsed value as a float, or `None` if the value was None or equal 1 Raises:\n        PydanticCustomError: If the input value cannot be..."}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.43811124563217163, "span_start": null, "span_end": null, "passage": "Args:\n        c: The float value to be converted Must be between 0 and 1 (inclusive) Returns:\n        The integer equivalent of the given float value rounded to the nearest whole number Raises:\n      ..."}, {"qid": "", "rank": 4, "path": "pydantic/color.py", "score": 0.4180685579776764, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        color = float(value)\n    except ValueError:\n        raise PydanticCustomError('color_error', 'value is not a valid color: color values must be a valid number')\n    if 0 <= color <..."}, {"qid": "", "rank": 5, "path": "pydantic/color.py", "score": 0.4108870029449463, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.3969319760799408, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.3892383575439453, "span_start": null, "span_end": null, "passage": "Args:\n        strict: Whether to validate the float in strict mode gt: The value must be greater than this ge: The value must be greater than or equal to this lt: The value must be less than this le: ..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.38377076387405396, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 9, "path": "docs/plugins/conversion_table.py", "score": 0.37230902910232544, "span_start": null, "span_end": null, "passage": "`val % 1 == 0`, raises error for `nan`, `inf`.',\n        valid_examples=[2.0],\n        invalid_examples=[2.1, 2.2250738585072011e308, float('nan'), float('inf')],\n        core_schemas=[core_schema.Int..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/color.py", "score": 0.3684591054916382, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/color.py", "score": 0.3661646544933319, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.3641335368156433, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/color.py", "score": 0.3637778162956238, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 14, "path": "pydantic/color.py", "score": 0.35728299617767334, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/color.py", "score": 0.3546374440193176, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = 'r', 'g', 'b', 'alpha', '_tuple'\n\n    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):\n        self.r = r\n        self.g = g\n        self.b = b\n        se..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/color.py", "score": 0.35144054889678955, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 17, "path": "pydantic/color.py", "score": 0.34295764565467834, "span_start": null, "span_end": null, "passage": "Args:\n            alpha: Whether to include the alpha channel There are three options for this input:\n\n                - `None` (default): Include alpha only if it's set (e.g not `None`)\n             ..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.34143611788749695, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 19, "path": "pydantic/types.py", "score": 0.33969929814338684, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if decimal:\n            divisor = 1000\n            units = 'B', 'KB', 'MB', 'GB', 'TB', 'PB'\n            final_unit = 'EB'\n        else:\n            divisor = 1024\n            units = 'B',..."}, {"qid": "", "rank": 20, "path": "pydantic/types.py", "score": 0.33692654967308044, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, StrictFloat, ValidationError\n\nclass StrictFloatModel(BaseModel):\n    strict_float: StrictFloat\n\ntry:\n    StrictFloatModel(strict_float='1.0')\nexcept ValidationErr..."}], "latency_ms": 3.729581832885742, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_d329acd9", "query": "find function parse_hsl", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.522529125213623, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.42599380016326904, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.3796226978302002, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/color.py", "score": 0.36482343077659607, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/color.py", "score": 0.36092376708984375, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/color.py", "score": 0.35901206731796265, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 7, "path": "pydantic/color.py", "score": 0.357557475566864, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.35754209756851196, "span_start": null, "span_end": null, "passage": "pass\n            else:\n                block_lines = inspect.getblock(lines[lnum - 1 :])\n                dedent_source = _dedent_source_lines(block_lines)\n                try:\n                    bloc..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.34527239203453064, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 10, "path": "tests/test_tools.py", "score": 0.34442219138145447, "span_start": null, "span_end": null, "passage": "from typing import Dict, List, Mapping, Union\n\nimport pytest\n\nfrom pydantic import BaseModel, PydanticDeprecatedSince20, ValidationError\nfrom pydantic.dataclasses import dataclass\nfrom pydantic.deprec..."}, {"qid": "", "rank": 11, "path": "pydantic/color.py", "score": 0.3321986198425293, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import Any, Callable, Optional, Tuple, Type, Union, cast\n\nfrom pydantic_core import CoreSchema, PydanticCustomError, ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/tools.py", "score": 0.32725954055786133, "span_start": null, "span_end": null, "passage": "import json\nfrom functools import lru_cache\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Optional, Type, TypeVar, Union\n\nfrom pydantic.v1.parse import Protocol, load_file,..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/color.py", "score": 0.32487010955810547, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 14, "path": "pydantic/color.py", "score": 0.3210884928703308, "span_start": null, "span_end": null, "passage": "Args:\n        value: The input value to parse Returns:\n        The parsed value as a float, or `None` if the value was None or equal 1 Raises:\n        PydanticCustomError: If the input value cannot be..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/color.py", "score": 0.3193882405757904, "span_start": null, "span_end": null, "passage": "`<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg"}, {"qid": "", "rank": 16, "path": "pydantic/color.py", "score": 0.31692183017730713, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 17, "path": "pydantic/parse.py", "score": 0.31513187289237976, "span_start": null, "span_end": null, "passage": "\"\"\"The `parse` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 18, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.31349503993988037, "span_start": null, "span_end": null, "passage": "st.register_type_strategy(\n    pydantic.PyObject,  # type: ignore[arg-type]\n    st.sampled_from(\n        [cast(pydantic.PyObject, f'math.{name}') for name in sorted(vars(math)) if not name.startswith(..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.3133717179298401, "span_start": null, "span_end": null, "passage": "Args:\n            alpha: Whether to include the alpha channel - `None` (default): Include the alpha channel only if it's set (e.g not `None`) - `True`: Always include alpha - `False`: Always omit alph..."}, {"qid": "", "rank": 20, "path": "docs/plugins/conversion_table.py", "score": 0.31066009402275085, "span_start": null, "span_end": null, "passage": "`[0-9]+`.',\n        valid_examples=[b'123'],\n        invalid_examples=[b'test', b'123x'],\n        core_schemas=[core_schema.IntSchema],\n    ),\n    Row(\n        float,\n        float,\n        strict=Tru..."}], "latency_ms": 3.8318634033203125, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_86e3a258", "query": "find function float_to_255", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.5327332019805908, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.5027282238006592, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.4746120274066925, "span_start": null, "span_end": null, "passage": "Args:\n        c: The float value to be converted Must be between 0 and 1 (inclusive) Returns:\n        The integer equivalent of the given float value rounded to the nearest whole number Raises:\n      ..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/color.py", "score": 0.4707721471786499, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/color.py", "score": 0.4645850658416748, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.45916175842285156, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/color.py", "score": 0.4469614028930664, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 8, "path": "pydantic/types.py", "score": 0.4382737874984741, "span_start": null, "span_end": null, "passage": "Args:\n        strict: Whether to validate the float in strict mode gt: The value must be greater than this ge: The value must be greater than or equal to this lt: The value must be less than this le: ..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.42373552918434143, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 10, "path": "pydantic/color.py", "score": 0.41802239418029785, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/color.py", "score": 0.41560059785842896, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.4089098572731018, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 13, "path": "pydantic/color.py", "score": 0.4076056480407715, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.4067666828632355, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if decimal:\n            divisor = 1000\n            units = 'B', 'KB', 'MB', 'GB', 'TB', 'PB'\n            final_unit = 'EB'\n        else:\n            divisor = 1024\n            units = 'B',..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.39798200130462646, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, StrictFloat, ValidationError\n\nclass StrictFloatModel(BaseModel):\n    strict_float: StrictFloat\n\ntry:\n    StrictFloatModel(strict_float='1.0')\nexcept ValidationErr..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/json.py", "score": 0.37894997000694275, "span_start": null, "span_end": null, "passage": ">>> decimal_encoder(Decimal(\"1.0\"))\n    1.0\n\n    >>> decimal_encoder(Decimal(\"1\"))\n    1\n    \"\"\"\n    if dec_value.as_tuple().exponent >= 0:\n        return int(dec_value)\n    else:\n        return float..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/color.py", "score": 0.377328485250473, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.36960867047309875, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        color = float(value)\n    except ValueError:\n        raise PydanticCustomError('color_error', 'value is not a valid color: color values must be a valid number')\n    if 0 <= color <..."}, {"qid": "", "rank": 19, "path": "pydantic/deprecated/json.py", "score": 0.366615355014801, "span_start": null, "span_end": null, "passage": ">>> decimal_encoder(Decimal(\"1.0\"))\n    1.0\n\n    >>> decimal_encoder(Decimal(\"1\"))\n    1\n    \"\"\"\n    exponent = dec_value.as_tuple().exponent\n    if isinstance(exponent, int) and exponent >= 0:\n      ..."}, {"qid": "", "rank": 20, "path": "docs/plugins/conversion_table.py", "score": 0.36572858691215515, "span_start": null, "span_end": null, "passage": "`val % 1 == 0`, raises error for `nan`, `inf`.',\n        valid_examples=[2.0],\n        invalid_examples=[2.1, 2.2250738585072011e308, float('nan'), float('inf')],\n        core_schemas=[core_schema.Int..."}], "latency_ms": 4.075765609741211, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_abed80dc", "query": "find class RGBA", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.5322492122650146, "span_start": null, "span_end": null, "passage": "Args:\n        h: The hue value h_units: The unit for hue value sat: The saturation value light: The lightness value alpha: Alpha value Returns:\n        An instance of `RGBA`"}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.5262214541435242, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.5181202292442322, "span_start": null, "span_end": null, "passage": "Args:\n        r: An integer or string representing the red color value g: An integer or string representing the green color value b: An integer or string representing the blue color value alpha: A flo..."}, {"qid": "", "rank": 4, "path": "pydantic/color.py", "score": 0.5159070491790771, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/color.py", "score": 0.49131637811660767, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.4874522089958191, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/color.py", "score": 0.48474928736686707, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.4840191900730133, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.48067280650138855, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/color.py", "score": 0.47664350271224976, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 11, "path": "pydantic/color.py", "score": 0.4681001901626587, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.4656933546066284, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/color.py", "score": 0.46411311626434326, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union, cast\n\nfrom pydantic.v1.errors import ColorError\nfrom pydantic..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/color.py", "score": 0.45719483494758606, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 15, "path": "pydantic/color.py", "score": 0.4527668356895447, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import Any, Callable, Optional, Tuple, Type, Union, cast\n\nfrom pydantic_core import CoreSchema, PydanticCustomError, ..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/color.py", "score": 0.443565309047699, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/color.py", "score": 0.43414896726608276, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)\n        if alpha is None:\n     ..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.4239060878753662, "span_start": null, "span_end": null, "passage": "'\n    'See https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/.',\n    category=PydanticDeprecatedSince20,\n)\nclass Color(_repr.Representation):\n    \"\"\"Represents a color.\"\"\"\n\n    __slots__..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.41825035214424133, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 20, "path": "pydantic/color.py", "score": 0.41482973098754883, "span_start": null, "span_end": null, "passage": "Args:\n        value: A tuple or list Returns:\n        An `RGBA` tuple parsed from the input tuple Raises:\n        PydanticCustomError: If tuple is not valid"}], "latency_ms": 3.664255142211914, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_9d755e63", "query": "find class Color", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.4562382102012634, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return int(round(c * 255))\n\n\nCOLORS_BY_NAME = {\n    'aliceblue': (240, 248, 255),\n    'antiquewhite': (250, 235, 215),\n    'aqua': (0, 255, 255),\n    'aquamarine': (127, 255, 212),\n    'azure'..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.43976396322250366, "span_start": null, "span_end": null, "passage": "See [`pydantic-extra-types.Color`](../usage/types/extra_types/color_types.md)\n    for more information"}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.42907679080963135, "span_start": null, "span_end": null, "passage": "Args:\n        r: An integer or string representing the red color value g: An integer or string representing the green color value b: An integer or string representing the blue color value alpha: A flo..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/color.py", "score": 0.4273030757904053, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/color.py", "score": 0.427071213722229, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.4233672618865967, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import Any, Callable, Optional, Tuple, Type, Union, cast\n\nfrom pydantic_core import CoreSchema, PydanticCustomError, ..."}, {"qid": "", "rank": 7, "path": "pydantic/color.py", "score": 0.41749730706214905, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.41747891902923584, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.41644522547721863, "span_start": null, "span_end": null, "passage": "\"\"\"Color definitions are used as per the CSS3\n[CSS Color Module Level 3](http://www.w3.org/TR/css3-color/#svg-color) specification A few colors have multiple names referring to the sames colors, eg `g..."}, {"qid": "", "rank": 10, "path": "pydantic/color.py", "score": 0.41011083126068115, "span_start": null, "span_end": null, "passage": "Args:\n        h: The hue value h_units: The unit for hue value sat: The saturation value light: The lightness value alpha: Alpha value Returns:\n        An instance of `RGBA`"}, {"qid": "", "rank": 11, "path": "pydantic/color.py", "score": 0.40993866324424744, "span_start": null, "span_end": null, "passage": "'\n    'See https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/.',\n    category=PydanticDeprecatedSince20,\n)\nclass Color(_repr.Representation):\n    \"\"\"Represents a color.\"\"\"\n\n    __slots__..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.4067668616771698, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.39988356828689575, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 14, "path": "pydantic/v1/color.py", "score": 0.39949560165405273, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.3973971903324127, "span_start": null, "span_end": null, "passage": "st.register_type_strategy(\n    pydantic.PyObject,  # type: ignore[arg-type]\n    st.sampled_from(\n        [cast(pydantic.PyObject, f'math.{name}') for name in sorted(vars(math)) if not name.startswith(..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/color.py", "score": 0.3941713571548462, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union, cast\n\nfrom pydantic.v1.errors import ColorError\nfrom pydantic..."}, {"qid": "", "rank": 17, "path": "pydantic/color.py", "score": 0.39142656326293945, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.3906368315219879, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.38441014289855957, "span_start": null, "span_end": null, "passage": "Args:\n            fallback: If True, falls back to returning the hexadecimal representation of\n                the color instead of raising a ValueError when no named color is found Returns:\n         ..."}, {"qid": "", "rank": 20, "path": "tests/test_color.py", "score": 0.38439980149269104, "span_start": null, "span_end": null, "passage": "from datetime import datetime\n\nimport pytest\nfrom pydantic_core import PydanticCustomError\n\nfrom pydantic import BaseModel, ValidationError\nfrom pydantic.color import Color\n\npytestmark = pytest.mark.f..."}], "latency_ms": 3.642559051513672, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_1b0d6dd9", "query": "find constant _255", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.45211711525917053, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.4441464841365814, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/color.py", "score": 0.4332351088523865, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 4, "path": "pydantic/color.py", "score": 0.4300650358200073, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/color.py", "score": 0.3952995836734772, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.3869134485721588, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/color.py", "score": 0.38453221321105957, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/color.py", "score": 0.37686687707901, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 9, "path": "docs/plugins/conversion_table.py", "score": 0.3690739870071411, "span_start": null, "span_end": null, "passage": "`[0-9]+`.',\n        valid_examples=['123'],\n        invalid_examples=['test', '123x'],\n        core_schemas=[core_schema.IntSchema],\n    ),\n    Row(\n        int,\n        bytes,\n        python_input=Tr..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/color.py", "score": 0.3622850775718689, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/types.py", "score": 0.35102713108062744, "span_start": null, "span_end": null, "passage": "digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's th..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.3485211730003357, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.346535325050354, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 14, "path": "pydantic/v1/json.py", "score": 0.34375542402267456, "span_start": null, "span_end": null, "passage": ">>> decimal_encoder(Decimal(\"1.0\"))\n    1.0\n\n    >>> decimal_encoder(Decimal(\"1\"))\n    1\n    \"\"\"\n    if dec_value.as_tuple().exponent >= 0:\n        return int(dec_value)\n    else:\n        return float..."}, {"qid": "", "rank": 15, "path": "pydantic/deprecated/json.py", "score": 0.34041327238082886, "span_start": null, "span_end": null, "passage": ">>> decimal_encoder(Decimal(\"1.0\"))\n    1.0\n\n    >>> decimal_encoder(Decimal(\"1\"))\n    1\n    \"\"\"\n    exponent = dec_value.as_tuple().exponent\n    if isinstance(exponent, int) and exponent >= 0:\n      ..."}, {"qid": "", "rank": 16, "path": "pydantic/color.py", "score": 0.33935704827308655, "span_start": null, "span_end": null, "passage": "\"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            e..."}, {"qid": "", "rank": 17, "path": "pydantic/color.py", "score": 0.3379082679748535, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.3346908688545227, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, FiniteFloat\n\nclass Model(BaseModel):\n    finite: FiniteFloat\n\nm = Model(finite=1.0)\nprint(m)\n#> finite=1.0\n```\n\"\"\"\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BYTES TYPES..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.32960250973701477, "span_start": null, "span_end": null, "passage": "Args:\n            alpha: Whether to include the alpha channel There are three options for this input:\n\n                - `None` (default): Include alpha only if it's set (e.g not `None`)\n             ..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/types.py", "score": 0.3190404176712036, "span_start": null, "span_end": null, "passage": "if abs(exponent) > len(digit_tuple):\n                digits = decimals = abs(exponent)\n            else:\n                digits = len(digit_tuple)\n                decimals = abs(exponent)\n        whol..."}], "latency_ms": 3.4646987915039062, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_d6ec0551", "query": "find constant COLORS_BY_NAME", "results": [{"qid": "", "rank": 1, "path": "pydantic/color.py", "score": 0.5512091517448425, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 2, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.5475565195083618, "span_start": null, "span_end": null, "passage": "st.register_type_strategy(\n    pydantic.PyObject,  # type: ignore[arg-type]\n    st.sampled_from(\n        [cast(pydantic.PyObject, f'math.{name}') for name in sorted(vars(math)) if not name.startswith(..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/color.py", "score": 0.5464895963668823, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 4, "path": "pydantic/color.py", "score": 0.5316307544708252, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 5, "path": "pydantic/color.py", "score": 0.5243337154388428, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/color.py", "score": 0.5183265805244446, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 7, "path": "pydantic/color.py", "score": 0.5131403207778931, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.509676992893219, "span_start": null, "span_end": null, "passage": "\"\"\"Color definitions are used as per the CSS3\n[CSS Color Module Level 3](http://www.w3.org/TR/css3-color/#svg-color) specification A few colors have multiple names referring to the sames colors, eg `g..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.5095483660697937, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return int(round(c * 255))\n\n\nCOLORS_BY_NAME = {\n    'aliceblue': (240, 248, 255),\n    'antiquewhite': (250, 235, 215),\n    'aqua': (0, 255, 255),\n    'aquamarine': (127, 255, 212),\n    'azure'..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/color.py", "score": 0.48804324865341187, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/color.py", "score": 0.4803731441497803, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.4775731563568115, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 13, "path": "pydantic/color.py", "score": 0.4761476516723633, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 14, "path": "pydantic/color.py", "score": 0.476033091545105, "span_start": null, "span_end": null, "passage": "'\n    'See https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/.',\n    category=PydanticDeprecatedSince20,\n)\nclass Color(_repr.Representation):\n    \"\"\"Represents a color.\"\"\"\n\n    __slots__..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/color.py", "score": 0.4723806381225586, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/color.py", "score": 0.4716314673423767, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/color.py", "score": 0.4674999713897705, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.46196240186691284, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.4607095718383789, "span_start": null, "span_end": null, "passage": "Args:\n            fallback: If True, falls back to returning the hexadecimal representation of\n                the color instead of raising a ValueError when no named color is found Returns:\n         ..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/color.py", "score": 0.4538469910621643, "span_start": null, "span_end": null, "passage": "\"\"\"\nColor definitions are  used as per CSS3 specification:\nhttp://www.w3.org/TR/css3-color/#svg-color\n\nA few colors have multiple names referring to the sames colors, eg `grey` and `gray` or `aqua` an..."}], "latency_ms": 3.940105438232422, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_57928ed4", "query": "find constant COLORS_BY_VALUE", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/color.py", "score": 0.6065468192100525, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 2, "path": "pydantic/color.py", "score": 0.5870909690856934, "span_start": null, "span_end": null, "passage": "\"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(..."}, {"qid": "", "rank": 3, "path": "pydantic/color.py", "score": 0.5790141224861145, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Par..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/color.py", "score": 0.5757027268409729, "span_start": null, "span_end": null, "passage": "`<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[val..."}, {"qid": "", "rank": 5, "path": "pydantic/color.py", "score": 0.5700883269309998, "span_start": null, "span_end": null, "passage": "\"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units ==..."}, {"qid": "", "rank": 6, "path": "pydantic/color.py", "score": 0.5459804534912109, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/color.py", "score": 0.5433381795883179, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 8, "path": "pydantic/color.py", "score": 0.542518138885498, "span_start": null, "span_end": null, "passage": "\"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                retu..."}, {"qid": "", "rank": 9, "path": "pydantic/color.py", "score": 0.5367574691772461, "span_start": null, "span_end": null, "passage": "\"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' f..."}, {"qid": "", "rank": 10, "path": "pydantic/color.py", "score": 0.5339610576629639, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/color.py", "score": 0.5252276659011841, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n        ..."}, {"qid": "", "rank": 12, "path": "pydantic/color.py", "score": 0.5183032155036926, "span_start": null, "span_end": null, "passage": "Args:\n        h: The hue value h_units: The unit for hue value sat: The saturation value light: The lightness value alpha: Alpha value Returns:\n        An instance of `RGBA`"}, {"qid": "", "rank": 13, "path": "pydantic/color.py", "score": 0.5177624225616455, "span_start": null, "span_end": null, "passage": "'\n    'See https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/.',\n    category=PydanticDeprecatedSince20,\n)\nclass Color(_repr.Representation):\n    \"\"\"Represents a color.\"\"\"\n\n    __slots__..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/color.py", "score": 0.5145936012268066, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.5116346478462219, "span_start": null, "span_end": null, "passage": "st.register_type_strategy(\n    pydantic.PyObject,  # type: ignore[arg-type]\n    st.sampled_from(\n        [cast(pydantic.PyObject, f'math.{name}') for name in sorted(vars(math)) if not name.startswith(..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/color.py", "score": 0.5074473023414612, "span_start": null, "span_end": null, "passage": "not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if s..."}, {"qid": "", "rank": 17, "path": "pydantic/color.py", "score": 0.5023741722106934, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}, {"qid": "", "rank": 18, "path": "pydantic/color.py", "score": 0.4896094799041748, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return int(round(c * 255))\n\n\nCOLORS_BY_NAME = {\n    'aliceblue': (240, 248, 255),\n    'antiquewhite': (250, 235, 215),\n    'aqua': (0, 255, 255),\n    'aquamarine': (127, 255, 212),\n    'azure'..."}, {"qid": "", "rank": 19, "path": "pydantic/color.py", "score": 0.48868370056152344, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(va..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/color.py", "score": 0.4747011959552765, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[..."}], "latency_ms": 4.240989685058594, "gold_paths": ["pydantic/color.py"]}
{"qid": "lens_main_symbol_f44ccad9", "query": "find function __init__", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generics.py", "score": 0.4171063303947449, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.40831226110458374, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_dataclasses.py", "score": 0.3932117521762848, "span_start": null, "span_end": null, "passage": "def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -> None:\n        __tracebackhide__ = True\n        s = __dataclass_self__\n        s.__pydantic_validator__.validate_python..."}, {"qid": "", "rank": 4, "path": "pydantic/dataclasses.py", "score": 0.3917386531829834, "span_start": null, "span_end": null, "passage": "def _call_initvar(*args: Any, **kwargs: Any) -> NoReturn:\n        \"\"\"This function does nothing but raise an error that is as similar as possible to what you'd get\n        if you were to try calling `..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_validate_call.py", "score": 0.36800476908683777, "span_start": null, "span_end": null, "passage": "import _generate_schema, _typing_extra\nfrom ._config import ConfigWrapper\n\n\nclass ValidateCallWrapper:\n    \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optiona..."}, {"qid": "", "rank": 6, "path": "pydantic/errors.py", "score": 0.36481308937072754, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, message: str, *, code: PydanticErrorCodes | None) -> None:\n        self.message = message\n        self.code = code\n\n    def __str__(self) -> str:\n        if self.code is No..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3647959232330322, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 8, "path": "pydantic/dataclasses.py", "score": 0.3563225269317627, "span_start": null, "span_end": null, "passage": "Raises:\n        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.355609267950058, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        atte..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.35129937529563904, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstan..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3511527180671692, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.3493849039077759, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 14, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 15, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.34860238432884216, "span_start": null, "span_end": null, "passage": "self.instance_method()\n        return name\n\n    def instance_method(self) -> None:\n        .."}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.3478943109512329, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = s..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.3451085388660431, "span_start": null, "span_end": null, "passage": "The added `__init__` will be annotated with types vs all `Any` depending on the plugin settings"}, {"qid": "", "rank": 19, "path": "pydantic/root_model.py", "score": 0.3416903018951416, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __pydantic_root_model__ = True\n    __pydantic_private__ = None\n    __pydantic_extra__ = None\n\n    root: RootModelRootType\n\n    def __init_subclass__(cls, **kwargs):\n        extra = cls.model_..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.3403377830982208, "span_start": null, "span_end": null, "passage": "\"\"\"This module includes classes and functions designed specifically for use with the mypy plugin.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom configparser import ConfigParser\nfrom typing i..."}], "latency_ms": 3.4754276275634766, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_733f6a23", "query": "find function with_config", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/config.py", "score": 0.5492632389068604, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\ndef get_config(config: Union[ConfigDict, Type[object], None]) -> Type[BaseConfig]:\n    if config is None:\n        return BaseConfig\n\n    else:\n        config_dict = (\n            co..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_config.py", "score": 0.5438978672027588, "span_start": null, "span_end": null, "passage": "old class-based config) or None Args:\n        config: The input config Returns:\n        A ConfigDict object created from config"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_config.py", "score": 0.5371108055114746, "span_start": null, "span_end": null, "passage": "Args:\n        config_dict: The input config"}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.48585236072540283, "span_start": null, "span_end": null, "passage": "It includes the config if config value is not `None`"}, {"qid": "", "rank": 5, "path": "pydantic/mypy.py", "score": 0.4290958344936371, "span_start": null, "span_end": null, "passage": "Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)\n        \"\"\"\n        if name not in self.tracked_config_fields:\n            return None\n   ..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.42415180802345276, "span_start": null, "span_end": null, "passage": "Attributes:\n        tracked_config_fields: A set of field configs that the plugin has to track their value"}, {"qid": "", "rank": 7, "path": "pydantic/mypy.py", "score": 0.41958004236221313, "span_start": null, "span_end": null, "passage": "Note that you can still get proper type checking via: `model_config = ConfigDict(...)`, just\n                    # if you don't use an explicit string, the plugin won't be able to infer whether extra ..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_config.py", "score": 0.41173070669174194, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if config is None:\n        return ConfigDict()\n\n    if not isinstance(config, dict):\n        warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)\n        config = {k: getattr(config, k) for ..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/env_settings.py", "score": 0.4106692373752594, "span_start": null, "span_end": null, "passage": "\"\"\"\n        secrets: Dict[str, Optional[str]] = {}\n\n        if self.secrets_dir is None:\n            return secrets\n\n        secrets_path = Path(self.secrets_dir).expanduser()\n\n        if not secrets_..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_dataclasses.py", "score": 0.40926843881607056, "span_start": null, "span_end": null, "passage": "Args:\n        cls: The class types_namespace: The types namespace, defaults to `None` config_wrapper: The config wrapper instance, defaults to `None`"}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_config.py", "score": 0.40924519300460815, "span_start": null, "span_end": null, "passage": "Use `model_config` for model configuration.',\n                code='model-config-invalid-field-name',\n            )\n\n        if config_class_from_namespace and config_dict_from_namespace:\n            ..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_typing_extra.py", "score": 0.39127445220947266, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.38625800609588623, "span_start": null, "span_end": null, "passage": "error_invalid_config_value(name, self._api, arg)\n                return None\n            return ModelConfigData(forbid_extra=forbid_extra)\n        if name == 'alias_generator':\n            has_alias_g..."}, {"qid": "", "rank": 14, "path": "pydantic/mypy.py", "score": 0.38584017753601074, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = (\n        'init_forbid_extra',\n        'init_typed',\n        'warn_required_dynamic_aliases',\n        'debug_dataclass_transform',\n    )\n    init_forbid_extra: bool\n    init_typed..."}, {"qid": "", "rank": 15, "path": "pydantic/main.py", "score": 0.3827632665634155, "span_start": null, "span_end": null, "passage": "def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n            \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n            provides a way ..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.38205164670944214, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_validate_call.py", "score": 0.3809083104133606, "span_start": null, "span_end": null, "passage": "import _generate_schema, _typing_extra\nfrom ._config import ConfigWrapper\n\n\nclass ValidateCallWrapper:\n    \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optiona..."}, {"qid": "", "rank": 18, "path": "pydantic/main.py", "score": 0.3797646164894104, "span_start": null, "span_end": null, "passage": "```\n\n            However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n            of the config arguments, and will only receive any keyword arguments p..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_fields.py", "score": 0.3770030736923218, "span_start": null, "span_end": null, "passage": "\"\"\"\n    from ..fields import FieldInfo\n\n    type_hints = get_cls_type_hints_lenient(cls, types_namespace)\n\n    # https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-o..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/mypy.py", "score": 0.3759390711784363, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}], "latency_ms": 3.549814224243164, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9722b6fe", "query": "find function inner", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.25849562883377075, "span_start": null, "span_end": null, "passage": "If we do replace any functions we put the replacement into the position\n        the replaced function was in; that is, we maintain the order"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.25508707761764526, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeErro..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.24231235682964325, "span_start": null, "span_end": null, "passage": "\"\"\"\n        inner_discriminator = choice['discriminator']\n        return inner_discriminator == self.discriminator or (\n            isinstance(inner_discriminator, list)\n            and (self.discrimi..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators.py", "score": 0.22164446115493774, "span_start": null, "span_end": null, "passage": "It will consider a function as instance method if the first parameter of\n    function is `self` Args:\n        function: The function to check Returns:\n        `True` if the function is an instance met..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/mypy.py", "score": 0.21903462707996368, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.21903462707996368, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.21364250779151917, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 8, "path": "pydantic/v1/typing.py", "score": 0.21031436324119568, "span_start": null, "span_end": null, "passage": "Returns True if Type is used\n    without brackets Otherwise returns None"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_decorators.py", "score": 0.2081577181816101, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if ismethoddescriptor(f) or isdatadescriptor(f):\n        return f\n    else:\n        return property(f)"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generics.py", "score": 0.20508623123168945, "span_start": null, "span_end": null, "passage": "# `typing.Callable[[int, str], int]` is an example for this if isinstance(type_, (List, list)):\n        resolved_list = list(replace_types(element, type_map) for element in type_)\n        if all_ident..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.20272469520568848, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if choice['type'] == 'definitions':\n            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=source_name)\n        elif choice['type'] == 'function-plain..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/json.py", "score": 0.20118111371994019, "span_start": null, "span_end": null, "passage": "\"\"\"\n    minutes, seconds = divmod(td.seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    return f'{\"-\" if td.days < 0 else \"\"}P{abs(td.days)}DT{hours:d}H{minutes:d}M{seconds:d}.{td.microseconds:..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_typing_extra.py", "score": 0.1977027952671051, "span_start": null, "span_end": null, "passage": "TypeError is raised if the argument is not of a type that can contain\n        annotations, and an empty dictionary is returned if no annotations are\n        present BEWARE -- the behavior of globalns ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generics.py", "score": 0.19600525498390198, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except Attribu..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generics.py", "score": 0.1958627551794052, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_decorators.py", "score": 0.1915954351425171, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  ..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_typing_extra.py", "score": 0.18984240293502808, "span_start": null, "span_end": null, "passage": "Using `f_back` would work sometimes but would be very wrong and confusing in many\n    other cases See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.18976612389087677, "span_start": null, "span_end": null, "passage": "pass\n            else:\n                block_lines = inspect.getblock(lines[lnum - 1 :])\n                dedent_source = _dedent_source_lines(block_lines)\n                try:\n                    bloc..."}, {"qid": "", "rank": 19, "path": "tests/benchmarks/generate_north_star_data.py", "score": 0.18864810466766357, "span_start": null, "span_end": null, "passage": "from datetime import datetime\nfrom typing import Any, Callable, List, TypeVar, Union\n\nfrom faker import Faker\n\nf = Faker()\nFaker.seed(0)\n\n\nT = TypeVar('T')\n\n## Helper functions\n\n# by default faker use..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_typing_extra.py", "score": 0.18634986877441406, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}], "latency_ms": 3.348827362060547, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_56c1ee84", "query": "find class ConfigDict", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_config.py", "score": 0.7425764203071594, "span_start": null, "span_end": null, "passage": "old class-based config) or None Args:\n        config: The input config Returns:\n        A ConfigDict object created from config"}, {"qid": "", "rank": 2, "path": "pydantic/v1/config.py", "score": 0.701473593711853, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\ndef get_config(config: Union[ConfigDict, Type[object], None]) -> Type[BaseConfig]:\n    if config is None:\n        return BaseConfig\n\n    else:\n        config_dict = (\n            co..."}, {"qid": "", "rank": 3, "path": "pydantic/main.py", "score": 0.6499894261360168, "span_start": null, "span_end": null, "passage": "```\n\n            However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n            of the config arguments, and will only receive any keyword arguments p..."}, {"qid": "", "rank": 4, "path": "pydantic/deprecated/config.py", "score": 0.6140621304512024, "span_start": null, "span_end": null, "passage": "Use the `pydantic.ConfigDict` instead.', category=PydanticDeprecatedSince20)\nclass BaseConfig(metaclass=_ConfigMetaclass):\n    \"\"\"This class is only retained for backwards compatibility !! Warning \"De..."}, {"qid": "", "rank": 5, "path": "tests/test_config.py", "score": 0.6131923794746399, "span_start": null, "span_end": null, "passage": "Use the `pydantic.ConfigDict` instead',\n            'Support for class-based `config` is deprecated, use ConfigDict instead',\n            'BaseConfig is deprecated"}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_config.py", "score": 0.5919985175132751, "span_start": null, "span_end": null, "passage": "Args:\n        config_dict: The input config"}, {"qid": "", "rank": 7, "path": "pydantic/mypy.py", "score": 0.5847612619400024, "span_start": null, "span_end": null, "passage": "If a ConfigDict is used, then we don't want to emit an error\n                    # because you'll get type checking from the ConfigDict itself #\n                    # It would be nice if we could intr..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/config.py", "score": 0.5663620233535767, "span_start": null, "span_end": null, "passage": "for k, v in config_dict.items():\n            setattr(Config, k, v)\n        return Config\n\n\ndef inherit_config(self_config: 'ConfigType', parent_config: 'ConfigType', **namespace: Any) -> 'ConfigType':..."}, {"qid": "", "rank": 9, "path": "pydantic/main.py", "score": 0.5528088808059692, "span_start": null, "span_end": null, "passage": "def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n            \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n            provides a way ..."}, {"qid": "", "rank": 10, "path": "pydantic/main.py", "score": 0.5487632751464844, "span_start": null, "span_end": null, "passage": "# However, for the sake of easy review, we have included type annotations of all class and instance attributes\n        # of `BaseModel` here:\n\n        # Class attributes\n        model_config: ClassVar..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_fields.py", "score": 0.5419938564300537, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 12, "path": "pydantic/config.py", "score": 0.5334107875823975, "span_start": null, "span_end": null, "passage": "example \"Usage\"\n\n        ```py\n        from typing_extensions import TypedDict\n\n        from pydantic import ConfigDict, TypeAdapter, with_config\n\n        @with_config(ConfigDict(str_to_lower=True))\n ..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_config.py", "score": 0.5310870409011841, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if config is None:\n        return ConfigDict()\n\n    if not isinstance(config, dict):\n        warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)\n        config = {k: getattr(config, k) for ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_fields.py", "score": 0.5252746343612671, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 15, "path": "tests/mypy/modules/with_config_decorator.py", "score": 0.5236907005310059, "span_start": null, "span_end": null, "passage": "from typing import TypedDict\n\nfrom pydantic import ConfigDict, with_config\n\n\n@with_config(ConfigDict(str_to_lower=True))\nclass Model(TypedDict):\n    a: str\n\n\nmodel = Model(a='ABC')"}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_dataclasses.py", "score": 0.5091224908828735, "span_start": null, "span_end": null, "passage": "Args:\n        cls: The class types_namespace: The types namespace, defaults to `None` config_wrapper: The config wrapper instance, defaults to `None`"}, {"qid": "", "rank": 17, "path": "pydantic/v1/mypy.py", "score": 0.5089437961578369, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.49718210101127625, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 19, "path": "pydantic/dataclasses.py", "score": 0.4967893958091736, "span_start": null, "span_end": null, "passage": "\"\"\"\n        from ._internal._utils import is_model_class\n\n        if is_model_class(cls):\n            raise PydanticUserError(\n                f'Cannot create a Pydantic dataclass from {cls.__name__} ..."}, {"qid": "", "rank": 20, "path": "tests/test_config.py", "score": 0.4966800808906555, "span_start": null, "span_end": null, "passage": "Use the `pydantic.ConfigDict` instead',\n            'Support for class-based `config` is deprecated, use ConfigDict instead',\n            'Support for class-based `config` is deprecated, use ConfigDic..."}], "latency_ms": 3.684520721435547, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9f9002a1", "query": "find class User", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.38138189911842346, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.36753541231155396, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "tests/test_config.py", "score": 0.33797505497932434, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.32820451259613037, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.3263298273086548, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.32135099172592163, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3183818757534027, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.3178037703037262, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3150871992111206, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3139326870441437, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.3115141689777374, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.3098616302013397, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.3096007704734802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.30839061737060547, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3036339282989502, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.2994091212749481, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.29744887351989746, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2972865700721741, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 19, "path": "pydantic/class_validators.py", "score": 0.29438328742980957, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/v1/generics.py", "score": 0.2940026521682739, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}], "latency_ms": 3.5867691040039062, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9f9002a1", "query": "find class User", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.38138189911842346, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.36753541231155396, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "tests/test_config.py", "score": 0.33797505497932434, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.32820451259613037, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.3263298273086548, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.32135099172592163, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3183818757534027, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.3178037703037262, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3150871992111206, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3139326870441437, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.3115141689777374, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.3098616302013397, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.3096007704734802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.30839061737060547, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3036339282989502, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.2994091212749481, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.29744887351989746, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2972865700721741, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 19, "path": "pydantic/class_validators.py", "score": 0.29438328742980957, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/v1/generics.py", "score": 0.2940026521682739, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}], "latency_ms": 3.4804344177246094, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9f9002a1", "query": "find class User", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.38138189911842346, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.36753541231155396, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "tests/test_config.py", "score": 0.33797505497932434, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.32820451259613037, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.3263298273086548, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.32135099172592163, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3183818757534027, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.3178037703037262, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3150871992111206, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3139326870441437, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.3115141689777374, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.3098616302013397, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.3096007704734802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.30839061737060547, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3036339282989502, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.2994091212749481, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.29744887351989746, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2972865700721741, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 19, "path": "pydantic/class_validators.py", "score": 0.29438328742980957, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/v1/generics.py", "score": 0.2940026521682739, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}], "latency_ms": 3.7975311279296875, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9f9002a1", "query": "find class User", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.38138189911842346, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.36753541231155396, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "tests/test_config.py", "score": 0.33797505497932434, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.32820451259613037, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.3263298273086548, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.32135099172592163, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3183818757534027, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.3178037703037262, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3150871992111206, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3139326870441437, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.3115141689777374, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.3098616302013397, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.3096007704734802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.30839061737060547, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3036339282989502, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.2994091212749481, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.29744887351989746, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2972865700721741, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 19, "path": "pydantic/class_validators.py", "score": 0.29438328742980957, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/v1/generics.py", "score": 0.2940026521682739, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}], "latency_ms": 3.4313201904296875, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_daab3d3a", "query": "find class SomeEnum", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.4034995138645172, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.39268431067466736, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 3, "path": "pydantic/v1/generics.py", "score": 0.3898565173149109, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 4, "path": "pydantic/v1/dataclasses.py", "score": 0.38124483823776245, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_decorators.py", "score": 0.36512306332588196, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/utils.py", "score": 0.3625815510749817, "span_start": null, "span_end": null, "passage": "\"\"\"\n    for base in bases:\n        if getattr(base, field_name, None):\n            raise NameError(\n                f'Field name \"{field_name}\" shadows a BaseModel attribute; '\n                f'use a..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generate_schema.py", "score": 0.35991519689559937, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 8, "path": "pydantic/dataclasses.py", "score": 0.3574247360229492, "span_start": null, "span_end": null, "passage": "types_namespace = frame_parent_ns\n            else:\n                types_namespace = {}\n\n            types_namespace = _typing_extra.get_cls_types_namespace(cls, types_namespace)\n        return _pyda..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_model_construction.py", "score": 0.349467396736145, "span_start": null, "span_end": null, "passage": "- If a field on base class was overridden by a non-annotated attribute"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_dataclasses.py", "score": 0.34599411487579346, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return (\n        dataclasses.is_dataclass(_cls)\n        and not hasattr(_cls, '__pydantic_validator__')\n        and set(_cls.__dataclass_fields__).issuperset(set(getattr(_cls, '__annotations__..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_utils.py", "score": 0.3424862027168274, "span_start": null, "span_end": null, "passage": "def __repr_args__(self) -> _repr.ReprArgs:\n        return [(None, self._items)]\n\n\nif typing.TYPE_CHECKING:\n\n    def ClassAttribute(name: str, value: T) -> T: .."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.3422684669494629, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/main.py", "score": 0.3350123465061188, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 14, "path": "tests/test_abc.py", "score": 0.33379173278808594, "span_start": null, "span_end": null, "passage": "import abc\nimport sys\n\nimport pytest\n\nfrom pydantic import BaseModel\n\n\ndef test_model_subclassing_abstract_base_classes():\n    class Model(BaseModel, abc.ABC):\n        some_field: str\n\n\n@pytest.mark.s..."}, {"qid": "", "rank": 15, "path": "pydantic/mypy.py", "score": 0.33338233828544617, "span_start": null, "span_end": null, "passage": "return None\n\n        if not isinstance(node, Var):  # pragma: no cover\n            # Don't know if this edge case still happens with the `is_valid_field` check above\n            # but better safe than..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_decorators.py", "score": 0.3329724669456482, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/dataclasses.py", "score": 0.33286404609680176, "span_start": null, "span_end": null, "passage": "@dataclass_transform(field_specifiers=(dataclasses.field, Field))\n    @overload\n    def dataclass(\n        _cls: Type[_T],\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: ..."}, {"qid": "", "rank": 18, "path": "pydantic/functional_validators.py", "score": 0.33245307207107544, "span_start": null, "span_end": null, "passage": "class Bar(BaseModel):\n                foo: InstanceOf[Foo]\n\n            Bar(foo=Foo())\n            try:\n                Bar(foo=42)\n            except ValidationError as e:\n                print(e)\n  ..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/dataclasses.py", "score": 0.3279847800731659, "span_start": null, "span_end": null, "passage": "else:\n\n    @dataclass_transform(field_specifiers=(dataclasses.field, Field))\n    @overload\n    def dataclass(\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.32516491413116455, "span_start": null, "span_end": null, "passage": "# The most important use case for this is creating TypeVar bounds for generics that should\n        # be restricted to enums This is more consistent than it might seem at first, since you can only\n    ..."}], "latency_ms": 3.751993179321289, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_42d04cc5", "query": "find class SomeModel", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.7260332107543945, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.5492153763771057, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48618102073669434, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_model_construction.py", "score": 0.4752991199493408, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.47356754541397095, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 6, "path": "tests/test_json_schema.py", "score": 0.4708547592163086, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 7, "path": "pydantic/mypy.py", "score": 0.4697737395763397, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 8, "path": "tests/test_type_hints.py", "score": 0.4652833640575409, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    \"\"\"\n    inspect_type_hints(obj_typ..."}, {"qid": "", "rank": 9, "path": "pydantic/functional_validators.py", "score": 0.46143120527267456, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.44023388624191284, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.44014811515808105, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        # Get a nice unique name instead r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    # Add decorator for is_classm..."}, {"qid": "", "rank": 12, "path": "tests/test_generics.py", "score": 0.4324072599411011, "span_start": null, "span_end": null, "passage": "ReferenceModel[MyInt]\n\n\ndef test_generic_with_referenced_generic_union_type_bound():\n    T = TypeVar('T', bound=Union[str, int])\n\n    class ModelWithType(BaseModel, Generic[T]):\n        some_type: Typ..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/main.py", "score": 0.42902183532714844, "span_start": null, "span_end": null, "passage": "# This allows users to write custom JSON encoders for given `BaseModel` classes"}, {"qid": "", "rank": 14, "path": "pydantic/v1/schema.py", "score": 0.4269648492336273, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 15, "path": "tests/test_forward_ref.py", "score": 0.4253184199333191, "span_start": null, "span_end": null, "passage": "bar2: int | str | Bar[float]\n\nclass Bar(BaseModel, Generic[T]):\n    foo: Foo\n\"\"\"\n    )\n\n    assert module.Foo.model_fields['bar'].annotation == typing.Optional[module.Bar[str]]\n    assert module.Foo.m..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/main.py", "score": 0.4252735376358032, "span_start": null, "span_end": null, "passage": "added to the model\nUNTOUCHED_TYPES: Tuple[Any, ...] = (FunctionType,) + ANNOTATED_FIELD_UNTOUCHED_TYPES\n# Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we n..."}, {"qid": "", "rank": 17, "path": "tests/test_docs_extraction.py", "score": 0.4249626100063324, "span_start": null, "span_end": null, "passage": "class MyModel(BaseModel):\n        a: int\n        \"\"\"A docs\"\"\"\n\n        model_config = ConfigDict(\n            use_attribute_docstrings=True,\n        )\n\n    MyModel.__name__ = 'OtherModel'\n    print(My..."}, {"qid": "", "rank": 18, "path": "pydantic/functional_validators.py", "score": 0.4244619607925415, "span_start": null, "span_end": null, "passage": "class Bar(BaseModel):\n                foo: InstanceOf[Foo]\n\n            Bar(foo=Foo())\n            try:\n                Bar(foo=42)\n            except ValidationError as e:\n                print(e)\n  ..."}, {"qid": "", "rank": 19, "path": "pydantic/main.py", "score": 0.42430251836776733, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/schema.py", "score": 0.42418259382247925, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}], "latency_ms": 3.673076629638672, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9f9002a1", "query": "find class User", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.38138189911842346, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.36753541231155396, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "tests/test_config.py", "score": 0.33797505497932434, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.32820451259613037, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.3263298273086548, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.32135099172592163, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3183818757534027, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.3178037703037262, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3150871992111206, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3139326870441437, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.3115141689777374, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.3098616302013397, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.3096007704734802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.30839061737060547, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3036339282989502, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.2994091212749481, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.29744887351989746, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2972865700721741, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 19, "path": "pydantic/class_validators.py", "score": 0.29438328742980957, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/v1/generics.py", "score": 0.2940026521682739, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}], "latency_ms": 4.022359848022461, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9f9002a1", "query": "find class User", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.38138189911842346, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.36753541231155396, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "tests/test_config.py", "score": 0.33797505497932434, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.32820451259613037, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.3263298273086548, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.32135099172592163, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3183818757534027, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.3178037703037262, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3150871992111206, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3139326870441437, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.3115141689777374, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.3098616302013397, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.3096007704734802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.30839061737060547, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3036339282989502, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.2994091212749481, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.29744887351989746, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2972865700721741, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 19, "path": "pydantic/class_validators.py", "score": 0.29438328742980957, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/v1/generics.py", "score": 0.2940026521682739, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}], "latency_ms": 3.958463668823242, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_dbe31af7", "query": "find class Pet", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.4629216194152832, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, ConfigDict, ValidationError\n\n    # This is not a pydantic model, it's an arbitrary class\n    class Pet:\n        def __init__(self, name: str):\n            sel..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_decorators.py", "score": 0.43919840455055237, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 3, "path": "tests/mypy/modules/root_models.py", "score": 0.4074832499027252, "span_start": null, "span_end": null, "passage": "from typing import List\n\nfrom pydantic import RootModel\n\n\nclass Pets1(RootModel[List[str]]):\n    pass\n\n\npets_construct = Pets1.model_construct(['dog'])\n\nPets2 = RootModel[List[str]]\n\n\nclass Pets3(Root..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.40495532751083374, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_decorators.py", "score": 0.3852519094944, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 6, "path": "tests/mypy/outputs/1.1.1/pyproject-default_toml/root_models.py", "score": 0.37578994035720825, "span_start": null, "span_end": null, "passage": "from typing import List\n\nfrom pydantic import RootModel\n\n\nclass Pets1(RootModel[List[str]]):\n    pass\n\n\npets_construct = Pets1.model_construct(['dog'])\n\nPets2 = RootModel[List[str]]\n\n\nclass Pets3(Root..."}, {"qid": "", "rank": 7, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/root_models.py", "score": 0.37578994035720825, "span_start": null, "span_end": null, "passage": "from typing import List\n\nfrom pydantic import RootModel\n\n\nclass Pets1(RootModel[List[str]]):\n    pass\n\n\npets_construct = Pets1.model_construct(['dog'])\n\nPets2 = RootModel[List[str]]\n\n\nclass Pets3(Root..."}, {"qid": "", "rank": 8, "path": "tests/test_config.py", "score": 0.3686378002166748, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 9, "path": "tests/mypy/outputs/1.0.1/mypy-plugin_ini/root_models.py", "score": 0.3677791655063629, "span_start": null, "span_end": null, "passage": "from typing import List\n\nfrom pydantic import RootModel\n\n\nclass Pets1(RootModel[List[str]]):\n    pass\n\n\npets_construct = Pets1.model_construct(['dog'])\n\nPets2 = RootModel[List[str]]\n\n\nclass Pets3(Root..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_decorators.py", "score": 0.3650320768356323, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.36390042304992676, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 12, "path": "tests/benchmarks/test_schema_build.py", "score": 0.36090949177742004, "span_start": null, "span_end": null, "passage": "from typing import Literal, Union\n\nimport pytest\nfrom typing_extensions import Annotated\n\nfrom pydantic import BaseModel, Discriminator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(frozen=T..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/dataclasses.py", "score": 0.3596777617931366, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 14, "path": "tests/mypy/modules/dataclass_no_any.py", "score": 0.357671320438385, "span_start": null, "span_end": null, "passage": "from pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    foo: int\n\n\n@dataclass(config={'title': 'Bar Title'})\nclass Bar:\n    bar: str"}, {"qid": "", "rank": 15, "path": "pydantic/dataclasses.py", "score": 0.35572800040245056, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_fields.py", "score": 0.35145267844200134, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/generics.py", "score": 0.3506929278373718, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 18, "path": "pydantic/v1/mypy.py", "score": 0.3504311144351959, "span_start": null, "span_end": null, "passage": "Teach mypy this by marking any function whose outermost decorator is a\n        `validator()` call as a classmethod"}, {"qid": "", "rank": 19, "path": "pydantic/mypy.py", "score": 0.34837234020233154, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        # Get a nice unique name instead r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    # Add decorator for is_classm..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_utils.py", "score": 0.3479537069797516, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}], "latency_ms": 3.712892532348633, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 4.247426986694336, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_5e8b26af", "query": "find class Voice", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.3447086811065674, "span_start": null, "span_end": null, "passage": "Here's an example with\n    a basic callable:\n\n    ```py\n    from pydantic import BaseModel, ConfigDict\n    from pydantic.alias_generators import to_pascal\n\n    class Voice(BaseModel):\n        model_co..."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.33602678775787354, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_decorators.py", "score": 0.32139623165130615, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators.py", "score": 0.31628701090812683, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/mypy.py", "score": 0.2912367582321167, "span_start": null, "span_end": null, "passage": "This is the same approach used by the attrs and dataclasses plugins"}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.2912367582321167, "span_start": null, "span_end": null, "passage": "This is the same approach used by the attrs and dataclasses plugins"}, {"qid": "", "rank": 7, "path": "pydantic/mypy.py", "score": 0.2911432385444641, "span_start": null, "span_end": null, "passage": "There may be a better way to do this, if this causes\n            # us problems in the future, we should look into why the dataclasses plugin doesn't have this issue"}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.27498912811279297, "span_start": null, "span_end": null, "passage": "in a function block\n    dedent_source = textwrap.dedent(''.join(source))\n    if dedent_source.startswith((' ', '\\t')):\n        # We are in the case where there's a dedented (usually multiline) string\n..."}, {"qid": "", "rank": 9, "path": "tests/test_config.py", "score": 0.2737591862678528, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.2715511918067932, "span_start": null, "span_end": null, "passage": "# Define your own class if you want to specify network address check strictness"}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.2692962884902954, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_typing_extra.py", "score": 0.26205533742904663, "span_start": null, "span_end": null, "passage": "* prefixing `typing.` where appropriate\n        * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument https://github.com/python/cpython/blob/aaaf5174241496afca7ce4..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/class_validators.py", "score": 0.2590431571006775, "span_start": null, "span_end": null, "passage": "@overload\ndef root_validator(\n    *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False\n) -> Callable[[AnyCallable], 'AnyClassMethod']:\n    .."}, {"qid": "", "rank": 14, "path": "pydantic/v1/mypy.py", "score": 0.2586022913455963, "span_start": null, "span_end": null, "passage": "Teach mypy this by marking any function whose outermost decorator is a\n        `validator()` call as a classmethod"}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_model_construction.py", "score": 0.2556743025779724, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_model_construction.py", "score": 0.2528568506240845, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_generate_schema.py", "score": 0.2522350549697876, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_utils.py", "score": 0.25142884254455566, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 19, "path": "pydantic/experimental/pipeline.py", "score": 0.24939626455307007, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if isinstance(tp, EllipsisType):\n            return _Pipeline[_InT, Any](self._steps + (_ValidateAs(_FieldTypeMarker, strict=strict),))\n        return _Pipeline[_InT, _NewOutT](self._steps..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.24854199588298798, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}], "latency_ms": 3.7856101989746094, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_433c0c31", "query": "find class Athlete", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.3550597131252289, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import AliasGenerator, BaseModel, ConfigDict\n    from pydantic.alias_generators import to_camel, to_pascal\n\n    class Athlete(BaseModel):\n        first_name: str\n        last_n..."}, {"qid": "", "rank": 2, "path": "pydantic/v1/dataclasses.py", "score": 0.30901384353637695, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 3, "path": "pydantic/mypy.py", "score": 0.2983291447162628, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators.py", "score": 0.2945402264595032, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/dataclasses.py", "score": 0.29212430119514465, "span_start": null, "span_end": null, "passage": "else:\n\n    @dataclass_transform(field_specifiers=(dataclasses.field, Field))\n    @overload\n    def dataclass(\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.2910839319229126, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/v1/dataclasses.py", "score": 0.2880951166152954, "span_start": null, "span_end": null, "passage": "@dataclass_transform(field_specifiers=(dataclasses.field, Field))\n    @overload\n    def dataclass(\n        _cls: Type[_T],\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: ..."}, {"qid": "", "rank": 8, "path": "pydantic/functional_serializers.py", "score": 0.28499409556388855, "span_start": null, "span_end": null, "passage": "```python\n    from typing import Set\n\n    from pydantic import BaseModel, field_serializer\n\n    class StudentModel(BaseModel):\n        name: str = 'Jane'\n        courses: Set[str]\n\n        @field_seri..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.28320783376693726, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_model_construction.py", "score": 0.2778295576572418, "span_start": null, "span_end": null, "passage": "- If a field on base class was overridden by a non-annotated attribute"}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_dataclasses.py", "score": 0.2775001525878906, "span_start": null, "span_end": null, "passage": "```py\n    import dataclasses\n\n    import pydantic.dataclasses\n\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In..."}, {"qid": "", "rank": 12, "path": "pydantic/dataclasses.py", "score": 0.2726014256477356, "span_start": null, "span_end": null, "passage": "@dataclass_transform(field_specifiers=(dataclasses.field, Field, PrivateAttr))\n    @overload\n    def dataclass(\n        _cls: type[_T],  # type: ignore\n        *,\n        init: Literal[False] = False,..."}, {"qid": "", "rank": 13, "path": "pydantic/networks.py", "score": 0.2718508839607239, "span_start": null, "span_end": null, "passage": "# Define your own class if you want to specify network address check strictness"}, {"qid": "", "rank": 14, "path": "pydantic/dataclasses.py", "score": 0.269681453704834, "span_start": null, "span_end": null, "passage": "else:\n\n    @dataclass_transform(field_specifiers=(dataclasses.field, Field, PrivateAttr))\n    @overload\n    def dataclass(\n        *,\n        init: Literal[False] = False,\n        repr: bool = True,\n ..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/dataclasses.py", "score": 0.26924917101860046, "span_start": null, "span_end": null, "passage": "@dataclass_transform(field_specifiers=(dataclasses.field, Field))\n    @overload\n    def dataclass(\n        _cls: Type[_T],\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: ..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.2666291296482086, "span_start": null, "span_end": null, "passage": "This function looks through `field_class_to_schema` for a class that matches the given `field_type`,\n    and then modifies the given `schema` with the information from that type"}, {"qid": "", "rank": 17, "path": "pydantic/v1/generics.py", "score": 0.263476699590683, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.2628752291202545, "span_start": null, "span_end": null, "passage": "found_fields: dict[str, PydanticModelField] = {}\n        found_class_vars: dict[str, PydanticModelClassVar] = {}\n        for info in reversed(cls.info.mro[1:-1]):  # 0 is the current class, -2 is Base..."}, {"qid": "", "rank": 19, "path": "pydantic/mypy.py", "score": 0.26140296459198, "span_start": null, "span_end": null, "passage": "return None\n\n        # x: ClassVar[int] is not a field\n        if node.is_classvar:\n            return PydanticModelClassVar(lhs.name)\n\n        # x: InitVar[int] is not supported in BaseModel\n        ..."}, {"qid": "", "rank": 20, "path": "tests/mypy/modules/dataclass_no_any.py", "score": 0.2590576410293579, "span_start": null, "span_end": null, "passage": "from pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    foo: int\n\n\n@dataclass(config={'title': 'Bar Title'})\nclass Bar:\n    bar: str"}], "latency_ms": 3.6690235137939453, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.5936832427978516, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9f9002a1", "query": "find class User", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.38138189911842346, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.36753541231155396, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "tests/test_config.py", "score": 0.33797505497932434, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.32820451259613037, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.3263298273086548, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.32135099172592163, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3183818757534027, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.3178037703037262, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3150871992111206, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3139326870441437, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.3115141689777374, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.3098616302013397, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.3096007704734802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.30839061737060547, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3036339282989502, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.2994091212749481, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.29744887351989746, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2972865700721741, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 19, "path": "pydantic/class_validators.py", "score": 0.29438328742980957, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/v1/generics.py", "score": 0.2940026521682739, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}], "latency_ms": 3.6830902099609375, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_a574e818", "query": "find class SubUser", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.3779786229133606, "span_start": null, "span_end": null, "passage": "The model is revalidated, since `revalidate_instances` is set to `'always'` 3 Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])` It's also possible to set `r..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.37317192554473877, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "pydantic/config.py", "score": 0.3634098768234253, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 4, "path": "tests/test_type_hints.py", "score": 0.3459138572216034, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 5, "path": "pydantic/config.py", "score": 0.33878836035728455, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 6, "path": "tests/test_config.py", "score": 0.3382691740989685, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 7, "path": "tests/test_main.py", "score": 0.315069317817688, "span_start": null, "span_end": null, "passage": "if 'sub_fields' in kinds else None)\n        c: str = 'foobar'\n\n        Config = ChildConfig\n\n    class Model(BaseModel):\n        a: int = 0\n        b: int = Field(2, exclude=.."}, {"qid": "", "rank": 8, "path": "pydantic/v1/main.py", "score": 0.3119008541107178, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 9, "path": "tests/test_type_hints.py", "score": 0.3095814287662506, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    \"\"\"\n    inspect_type_hints(obj_typ..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.30871766805648804, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.3008189797401428, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.2898208796977997, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 13, "path": "tests/test_generics.py", "score": 0.28752565383911133, "span_start": null, "span_end": null, "passage": "class B(A[T], Generic[T]): .. class C(B[T], Generic[T]): .. assert B[int].__name__ == 'B[int]'\n    assert issubclass(B[int], B)\n    assert issubclass(B[int], A)\n    assert not issubclass(B[int], C)\n\n\n..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.28525596857070923, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 15, "path": "pydantic/mypy.py", "score": 0.280500590801239, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 16, "path": "pydantic/config.py", "score": 0.2780643701553345, "span_start": null, "span_end": null, "passage": "#> user=User(hobbies=['scuba diving'])\n    ```\n\n    1 `revalidate_instances` is set to `'subclass-instances'` 2 This is not revalidated, since `my_user` is not a subclass of `User` 3 Using `'never'` w..."}, {"qid": "", "rank": 17, "path": "pydantic/config.py", "score": 0.27789899706840515, "span_start": null, "span_end": null, "passage": "```py\n    from typing import List\n\n    from pydantic import BaseModel\n\n    class User(BaseModel, revalidate_instances='never'):  # (1) hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[s..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.2765234112739563, "span_start": null, "span_end": null, "passage": "Unless overridden in a subclass, this raises an error Args:\n            schema: The core schema Returns:\n            The generated JSON schema \"\"\"\n        return self.handle_invalid_for_json_schema(sc..."}, {"qid": "", "rank": 19, "path": "pydantic/functional_validators.py", "score": 0.2761012017726898, "span_start": null, "span_end": null, "passage": "class Bar(BaseModel):\n                foo: InstanceOf[Foo]\n\n            Bar(foo=Foo())\n            try:\n                Bar(foo=42)\n            except ValidationError as e:\n                print(e)\n  ..."}, {"qid": "", "rank": 20, "path": "tests/test_generics.py", "score": 0.27456802129745483, "span_start": null, "span_end": null, "passage": "PartiallyAppliedB = B[str, T]\n    assert issubclass(PartiallyAppliedB[int], A)\n\n\ndef test_multilevel_generic_binding():\n    T = TypeVar('T')\n    S = TypeVar('S')\n\n    class A(BaseModel, Generic[T, S])..."}], "latency_ms": 3.389596939086914, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_ce9f1008", "query": "find class Transaction", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.4140545725822449, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.38317006826400757, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 3, "path": "pydantic/functional_serializers.py", "score": 0.3762306272983551, "span_start": null, "span_end": null, "passage": "\"\"\"\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class SerializeAsAny:  # noqa: D101\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item,..."}, {"qid": "", "rank": 4, "path": "pydantic/config.py", "score": 0.3376801013946533, "span_start": null, "span_end": null, "passage": "```py\n    from typing import List\n\n    from pydantic import BaseModel\n\n    class User(BaseModel, revalidate_instances='never'):  # (1) hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[s..."}, {"qid": "", "rank": 5, "path": "tests/test_main.py", "score": 0.32717928290367126, "span_start": null, "span_end": null, "passage": "When we use the TypeAdapter\n    received_schemas: dict[str, list[str]] = defaultdict(list)\n\n    @dataclass\n    class Marker:\n        name: str\n\n        def __get_pydantic_core_schema__(self, source_ty..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_fields.py", "score": 0.3250701427459717, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.32435399293899536, "span_start": null, "span_end": null, "passage": "```py\n        from pydantic import BaseModel, ImportString\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # Create an instance\n        m = ImportThings(obj='math.cos'..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_decorators.py", "score": 0.317598819732666, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 9, "path": "pydantic/functional_serializers.py", "score": 0.31731903553009033, "span_start": null, "span_end": null, "passage": "\"\"\"This module contains related classes and functions for serialization.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom functools import partialmethod\nfrom typing import TYPE_CHECKING..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3170575499534607, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/mypy.py", "score": 0.31135818362236023, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = s..."}, {"qid": "", "rank": 12, "path": "tests/test_config.py", "score": 0.3111411929130554, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 13, "path": "pydantic/functional_serializers.py", "score": 0.31010621786117554, "span_start": null, "span_end": null, "passage": "\"\"\"\n        schema = handler(source_type)\n        try:\n            return_type = _decorators.get_function_return_type(\n                self.func, self.return_type, handler._get_types_namespace()\n     ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.30561405420303345, "span_start": null, "span_end": null, "passage": "This class' __get__ returns the wrapped item's __get__ result,\n    which makes it transparent for classmethods and staticmethods Attributes:\n        wrapped: The decorator that has to be wrapped decor..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.3041277527809143, "span_start": null, "span_end": null, "passage": "return core_schema.is_instance_schema(\n            enum_type,\n            metadata={'pydantic_js_functions': [get_json_schema_no_cases]},\n        )\n\n\n@dataclasses.dataclass(**slots_true)\nclass InnerSc..."}, {"qid": "", "rank": 16, "path": "pydantic/main.py", "score": 0.30397889018058777, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n\n        __class_vars..."}, {"qid": "", "rank": 17, "path": "pydantic/functional_serializers.py", "score": 0.30394989252090454, "span_start": null, "span_end": null, "passage": "\"\"\"\n        schema = handler(source_type)\n        try:\n            return_type = _decorators.get_function_return_type(\n                self.func, self.return_type, handler._get_types_namespace()\n     ..."}, {"qid": "", "rank": 18, "path": "pydantic/dataclasses.py", "score": 0.2974531352519989, "span_start": null, "span_end": null, "passage": "This function should be used similarly to `dataclasses.dataclass` Args:\n        _cls: The target `dataclass` init: Included for signature compatibility with `dataclasses.dataclass`, and is passed thro..."}, {"qid": "", "rank": 19, "path": "pydantic/mypy.py", "score": 0.296223521232605, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.2960439622402191, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}], "latency_ms": 3.998994827270508, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9f9002a1", "query": "find class User", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.38138189911842346, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.36753541231155396, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "tests/test_config.py", "score": 0.33797505497932434, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.32820451259613037, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.3263298273086548, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.32135099172592163, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3183818757534027, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.3178037703037262, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3150871992111206, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3139326870441437, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.3115141689777374, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.3098616302013397, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.3096007704734802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.30839061737060547, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3036339282989502, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.2994091212749481, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.29744887351989746, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2972865700721741, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 19, "path": "pydantic/class_validators.py", "score": 0.29438328742980957, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/v1/generics.py", "score": 0.2940026521682739, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}], "latency_ms": 3.3621788024902344, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_a574e818", "query": "find class SubUser", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.3779786229133606, "span_start": null, "span_end": null, "passage": "The model is revalidated, since `revalidate_instances` is set to `'always'` 3 Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])` It's also possible to set `r..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.37317192554473877, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "pydantic/config.py", "score": 0.3634098768234253, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 4, "path": "tests/test_type_hints.py", "score": 0.3459138572216034, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 5, "path": "pydantic/config.py", "score": 0.33878836035728455, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 6, "path": "tests/test_config.py", "score": 0.3382691740989685, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 7, "path": "tests/test_main.py", "score": 0.315069317817688, "span_start": null, "span_end": null, "passage": "if 'sub_fields' in kinds else None)\n        c: str = 'foobar'\n\n        Config = ChildConfig\n\n    class Model(BaseModel):\n        a: int = 0\n        b: int = Field(2, exclude=.."}, {"qid": "", "rank": 8, "path": "pydantic/v1/main.py", "score": 0.3119008541107178, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 9, "path": "tests/test_type_hints.py", "score": 0.3095814287662506, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    \"\"\"\n    inspect_type_hints(obj_typ..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.30871766805648804, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.3008189797401428, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.2898208796977997, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 13, "path": "tests/test_generics.py", "score": 0.28752565383911133, "span_start": null, "span_end": null, "passage": "class B(A[T], Generic[T]): .. class C(B[T], Generic[T]): .. assert B[int].__name__ == 'B[int]'\n    assert issubclass(B[int], B)\n    assert issubclass(B[int], A)\n    assert not issubclass(B[int], C)\n\n\n..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.28525596857070923, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 15, "path": "pydantic/mypy.py", "score": 0.280500590801239, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 16, "path": "pydantic/config.py", "score": 0.2780643701553345, "span_start": null, "span_end": null, "passage": "#> user=User(hobbies=['scuba diving'])\n    ```\n\n    1 `revalidate_instances` is set to `'subclass-instances'` 2 This is not revalidated, since `my_user` is not a subclass of `User` 3 Using `'never'` w..."}, {"qid": "", "rank": 17, "path": "pydantic/config.py", "score": 0.27789899706840515, "span_start": null, "span_end": null, "passage": "```py\n    from typing import List\n\n    from pydantic import BaseModel\n\n    class User(BaseModel, revalidate_instances='never'):  # (1) hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[s..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.2765234112739563, "span_start": null, "span_end": null, "passage": "Unless overridden in a subclass, this raises an error Args:\n            schema: The core schema Returns:\n            The generated JSON schema \"\"\"\n        return self.handle_invalid_for_json_schema(sc..."}, {"qid": "", "rank": 19, "path": "pydantic/functional_validators.py", "score": 0.2761012017726898, "span_start": null, "span_end": null, "passage": "class Bar(BaseModel):\n                foo: InstanceOf[Foo]\n\n            Bar(foo=Foo())\n            try:\n                Bar(foo=42)\n            except ValidationError as e:\n                print(e)\n  ..."}, {"qid": "", "rank": 20, "path": "tests/test_generics.py", "score": 0.27456802129745483, "span_start": null, "span_end": null, "passage": "PartiallyAppliedB = B[str, T]\n    assert issubclass(PartiallyAppliedB[int], A)\n\n\ndef test_multilevel_generic_binding():\n    T = TypeVar('T')\n    S = TypeVar('S')\n\n    class A(BaseModel, Generic[T, S])..."}], "latency_ms": 3.6916732788085938, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_ce9f1008", "query": "find class Transaction", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.4140545725822449, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.38317006826400757, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 3, "path": "pydantic/functional_serializers.py", "score": 0.3762306272983551, "span_start": null, "span_end": null, "passage": "\"\"\"\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class SerializeAsAny:  # noqa: D101\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item,..."}, {"qid": "", "rank": 4, "path": "pydantic/config.py", "score": 0.3376801013946533, "span_start": null, "span_end": null, "passage": "```py\n    from typing import List\n\n    from pydantic import BaseModel\n\n    class User(BaseModel, revalidate_instances='never'):  # (1) hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[s..."}, {"qid": "", "rank": 5, "path": "tests/test_main.py", "score": 0.32717928290367126, "span_start": null, "span_end": null, "passage": "When we use the TypeAdapter\n    received_schemas: dict[str, list[str]] = defaultdict(list)\n\n    @dataclass\n    class Marker:\n        name: str\n\n        def __get_pydantic_core_schema__(self, source_ty..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_fields.py", "score": 0.3250701427459717, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.32435399293899536, "span_start": null, "span_end": null, "passage": "```py\n        from pydantic import BaseModel, ImportString\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # Create an instance\n        m = ImportThings(obj='math.cos'..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_decorators.py", "score": 0.317598819732666, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 9, "path": "pydantic/functional_serializers.py", "score": 0.31731903553009033, "span_start": null, "span_end": null, "passage": "\"\"\"This module contains related classes and functions for serialization.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom functools import partialmethod\nfrom typing import TYPE_CHECKING..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3170575499534607, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/mypy.py", "score": 0.31135818362236023, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = s..."}, {"qid": "", "rank": 12, "path": "tests/test_config.py", "score": 0.3111411929130554, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 13, "path": "pydantic/functional_serializers.py", "score": 0.31010621786117554, "span_start": null, "span_end": null, "passage": "\"\"\"\n        schema = handler(source_type)\n        try:\n            return_type = _decorators.get_function_return_type(\n                self.func, self.return_type, handler._get_types_namespace()\n     ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.30561405420303345, "span_start": null, "span_end": null, "passage": "This class' __get__ returns the wrapped item's __get__ result,\n    which makes it transparent for classmethods and staticmethods Attributes:\n        wrapped: The decorator that has to be wrapped decor..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.3041277527809143, "span_start": null, "span_end": null, "passage": "return core_schema.is_instance_schema(\n            enum_type,\n            metadata={'pydantic_js_functions': [get_json_schema_no_cases]},\n        )\n\n\n@dataclasses.dataclass(**slots_true)\nclass InnerSc..."}, {"qid": "", "rank": 16, "path": "pydantic/main.py", "score": 0.30397889018058777, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n\n        __class_vars..."}, {"qid": "", "rank": 17, "path": "pydantic/functional_serializers.py", "score": 0.30394989252090454, "span_start": null, "span_end": null, "passage": "\"\"\"\n        schema = handler(source_type)\n        try:\n            return_type = _decorators.get_function_return_type(\n                self.func, self.return_type, handler._get_types_namespace()\n     ..."}, {"qid": "", "rank": 18, "path": "pydantic/dataclasses.py", "score": 0.2974531352519989, "span_start": null, "span_end": null, "passage": "This function should be used similarly to `dataclasses.dataclass` Args:\n        _cls: The target `dataclass` init: Included for signature compatibility with `dataclasses.dataclass`, and is passed thro..."}, {"qid": "", "rank": 19, "path": "pydantic/mypy.py", "score": 0.296223521232605, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.2960439622402191, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}], "latency_ms": 3.4685134887695312, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_9f9002a1", "query": "find class User", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.38138189911842346, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.36753541231155396, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "tests/test_config.py", "score": 0.33797505497932434, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.32820451259613037, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 5, "path": "pydantic/dataclasses.py", "score": 0.3263298273086548, "span_start": null, "span_end": null, "passage": "Args:\n        class_: The class Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise \"\"\"\n    try:\n        return '__pydantic_validator__' in class_.__dict__ and dataclasses...."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.32135099172592163, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.3183818757534027, "span_start": null, "span_end": null, "passage": "This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties Args:\n        tp: The type or class to search for the attribute name: T..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_fields.py", "score": 0.3178037703037262, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3150871992111206, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3139326870441437, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/dataclasses.py", "score": 0.3115141689777374, "span_start": null, "span_end": null, "passage": "```\n    @dataclasses.dataclass\n    class A:\n        x: int\n\n    @pydantic.dataclasses.dataclass\n    class B(A):\n        y: int\n    ```\n    In this case, when we first check `B`, we make an extra check..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.3098616302013397, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/mypy.py", "score": 0.3096007704734802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n        ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_utils.py", "score": 0.30839061737060547, "span_start": null, "span_end": null, "passage": "else:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            sel..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.3036339282989502, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.2994091212749481, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.29744887351989746, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.2972865700721741, "span_start": null, "span_end": null, "passage": "Args:\n        cls: dataclass types_namespace: Optional extra namespace to look for types in typevars_map: A dictionary mapping type variables to their concrete types config_wrapper: The config wrapper..."}, {"qid": "", "rank": 19, "path": "pydantic/class_validators.py", "score": 0.29438328742980957, "span_start": null, "span_end": null, "passage": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/v1/generics.py", "score": 0.2940026521682739, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}], "latency_ms": 3.6988258361816406, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_a574e818", "query": "find class SubUser", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.3779786229133606, "span_start": null, "span_end": null, "passage": "The model is revalidated, since `revalidate_instances` is set to `'always'` 3 Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])` It's also possible to set `r..."}, {"qid": "", "rank": 2, "path": "tests/mypy/modules/strict_equality.py", "score": 0.37317192554473877, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 3, "path": "pydantic/config.py", "score": 0.3634098768234253, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 4, "path": "tests/test_type_hints.py", "score": 0.3459138572216034, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 5, "path": "pydantic/config.py", "score": 0.33878836035728455, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 6, "path": "tests/test_config.py", "score": 0.3382691740989685, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 7, "path": "tests/test_main.py", "score": 0.315069317817688, "span_start": null, "span_end": null, "passage": "if 'sub_fields' in kinds else None)\n        c: str = 'foobar'\n\n        Config = ChildConfig\n\n    class Model(BaseModel):\n        a: int = 0\n        b: int = Field(2, exclude=.."}, {"qid": "", "rank": 8, "path": "pydantic/v1/main.py", "score": 0.3119008541107178, "span_start": null, "span_end": null, "passage": "private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_..."}, {"qid": "", "rank": 9, "path": "tests/test_type_hints.py", "score": 0.3095814287662506, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    \"\"\"\n    inspect_type_hints(obj_typ..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.30871766805648804, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fr..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.3008189797401428, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.2898208796977997, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 13, "path": "tests/test_generics.py", "score": 0.28752565383911133, "span_start": null, "span_end": null, "passage": "class B(A[T], Generic[T]): .. class C(B[T], Generic[T]): .. assert B[int].__name__ == 'B[int]'\n    assert issubclass(B[int], B)\n    assert issubclass(B[int], A)\n    assert not issubclass(B[int], C)\n\n\n..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.28525596857070923, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 15, "path": "pydantic/mypy.py", "score": 0.280500590801239, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}, {"qid": "", "rank": 16, "path": "pydantic/config.py", "score": 0.2780643701553345, "span_start": null, "span_end": null, "passage": "#> user=User(hobbies=['scuba diving'])\n    ```\n\n    1 `revalidate_instances` is set to `'subclass-instances'` 2 This is not revalidated, since `my_user` is not a subclass of `User` 3 Using `'never'` w..."}, {"qid": "", "rank": 17, "path": "pydantic/config.py", "score": 0.27789899706840515, "span_start": null, "span_end": null, "passage": "```py\n    from typing import List\n\n    from pydantic import BaseModel\n\n    class User(BaseModel, revalidate_instances='never'):  # (1) hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[s..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.2765234112739563, "span_start": null, "span_end": null, "passage": "Unless overridden in a subclass, this raises an error Args:\n            schema: The core schema Returns:\n            The generated JSON schema \"\"\"\n        return self.handle_invalid_for_json_schema(sc..."}, {"qid": "", "rank": 19, "path": "pydantic/functional_validators.py", "score": 0.2761012017726898, "span_start": null, "span_end": null, "passage": "class Bar(BaseModel):\n                foo: InstanceOf[Foo]\n\n            Bar(foo=Foo())\n            try:\n                Bar(foo=42)\n            except ValidationError as e:\n                print(e)\n  ..."}, {"qid": "", "rank": 20, "path": "tests/test_generics.py", "score": 0.27456802129745483, "span_start": null, "span_end": null, "passage": "PartiallyAppliedB = B[str, T]\n    assert issubclass(PartiallyAppliedB[int], A)\n\n\ndef test_multilevel_generic_binding():\n    T = TypeVar('T')\n    S = TypeVar('S')\n\n    class A(BaseModel, Generic[T, S])..."}], "latency_ms": 3.4332275390625, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_ce9f1008", "query": "find class Transaction", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.4140545725822449, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.38317006826400757, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}, {"qid": "", "rank": 3, "path": "pydantic/functional_serializers.py", "score": 0.3762306272983551, "span_start": null, "span_end": null, "passage": "\"\"\"\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class SerializeAsAny:  # noqa: D101\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item,..."}, {"qid": "", "rank": 4, "path": "pydantic/config.py", "score": 0.3376801013946533, "span_start": null, "span_end": null, "passage": "```py\n    from typing import List\n\n    from pydantic import BaseModel\n\n    class User(BaseModel, revalidate_instances='never'):  # (1) hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[s..."}, {"qid": "", "rank": 5, "path": "tests/test_main.py", "score": 0.32717928290367126, "span_start": null, "span_end": null, "passage": "When we use the TypeAdapter\n    received_schemas: dict[str, list[str]] = defaultdict(list)\n\n    @dataclass\n    class Marker:\n        name: str\n\n        def __get_pydantic_core_schema__(self, source_ty..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_fields.py", "score": 0.3250701427459717, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.32435399293899536, "span_start": null, "span_end": null, "passage": "```py\n        from pydantic import BaseModel, ImportString\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # Create an instance\n        m = ImportThings(obj='math.cos'..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_decorators.py", "score": 0.317598819732666, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 9, "path": "pydantic/functional_serializers.py", "score": 0.31731903553009033, "span_start": null, "span_end": null, "passage": "\"\"\"This module contains related classes and functions for serialization.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom functools import partialmethod\nfrom typing import TYPE_CHECKING..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.3170575499534607, "span_start": null, "span_end": null, "passage": "if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/mypy.py", "score": 0.31135818362236023, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = s..."}, {"qid": "", "rank": 12, "path": "tests/test_config.py", "score": 0.3111411929130554, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 13, "path": "pydantic/functional_serializers.py", "score": 0.31010621786117554, "span_start": null, "span_end": null, "passage": "\"\"\"\n        schema = handler(source_type)\n        try:\n            return_type = _decorators.get_function_return_type(\n                self.func, self.return_type, handler._get_types_namespace()\n     ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.30561405420303345, "span_start": null, "span_end": null, "passage": "This class' __get__ returns the wrapped item's __get__ result,\n    which makes it transparent for classmethods and staticmethods Attributes:\n        wrapped: The decorator that has to be wrapped decor..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.3041277527809143, "span_start": null, "span_end": null, "passage": "return core_schema.is_instance_schema(\n            enum_type,\n            metadata={'pydantic_js_functions': [get_json_schema_no_cases]},\n        )\n\n\n@dataclasses.dataclass(**slots_true)\nclass InnerSc..."}, {"qid": "", "rank": 16, "path": "pydantic/main.py", "score": 0.30397889018058777, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n\n        __class_vars..."}, {"qid": "", "rank": 17, "path": "pydantic/functional_serializers.py", "score": 0.30394989252090454, "span_start": null, "span_end": null, "passage": "\"\"\"\n        schema = handler(source_type)\n        try:\n            return_type = _decorators.get_function_return_type(\n                self.func, self.return_type, handler._get_types_namespace()\n     ..."}, {"qid": "", "rank": 18, "path": "pydantic/dataclasses.py", "score": 0.2974531352519989, "span_start": null, "span_end": null, "passage": "This function should be used similarly to `dataclasses.dataclass` Args:\n        _cls: The target `dataclass` init: Included for signature compatibility with `dataclasses.dataclass`, and is passed thro..."}, {"qid": "", "rank": 19, "path": "pydantic/mypy.py", "score": 0.296223521232605, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.2960439622402191, "span_start": null, "span_end": null, "passage": "#     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors"}], "latency_ms": 3.6439895629882812, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.431558609008789, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 4.160165786743164, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.4203529357910156, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.8022994995117188, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.340005874633789, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.5233497619628906, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.5173892974853516, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_fd215ba4", "query": "find class ForceInputModel", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.5100710988044739, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "tests/test_json_schema.py", "score": 0.4399450719356537, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 3, "path": "pydantic/root_model.py", "score": 0.42496392130851746, "span_start": null, "span_end": null, "passage": "We trick type checkers into thinking we apply dataclass_transform\n    # on a new metaclass @dataclass_transform(kw_only_default=False, field_specifiers=(PydanticModelField, PydanticModelPrivateAttr))\n..."}, {"qid": "", "rank": 4, "path": "pydantic/config.py", "score": 0.4188372790813446, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, ConfigDict, Json\n\n    class Model(BaseModel):\n        a: Json[int]  # requires a string to validate, but will dump an int\n\n    print(Model.model_json_schema(m..."}, {"qid": "", "rank": 5, "path": "pydantic/main.py", "score": 0.412619411945343, "span_start": null, "span_end": null, "passage": "# However, for the sake of easy review, we have included type annotations of all class and instance attributes\n        # of `BaseModel` here:\n\n        # Class attributes\n        model_config: ClassVar..."}, {"qid": "", "rank": 6, "path": "pydantic/dataclasses.py", "score": 0.41045069694519043, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 7, "path": "pydantic/v1/generics.py", "score": 0.4076351225376129, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 8, "path": "tests/test_edge_cases.py", "score": 0.4068898558616638, "span_start": null, "span_end": null, "passage": "\"\n            'All field definitions, including overrides, require a type annotation.'\n        ),\n    ):\n\n        class D(A):\n            integer = 'G'\n\n\ndef test_string_none():\n    class Model(BaseMo..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_model_construction.py", "score": 0.40406596660614014, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/main.py", "score": 0.3927573263645172, "span_start": null, "span_end": null, "passage": "ANNOTATED_FIELD_UNTOUCHED_TYPES: Tuple[Any, ...] = (property, type, classmethod, staticmethod)\n# When creating a `BaseModel` instance, we bypass all the methods, properties.."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_fields.py", "score": 0.3924921452999115, "span_start": null, "span_end": null, "passage": "\"\"\"\n    from ..fields import FieldInfo\n\n    type_hints = get_cls_type_hints_lenient(cls, types_namespace)\n\n    # https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-o..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_model_construction.py", "score": 0.38816124200820923, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 13, "path": "pydantic/root_model.py", "score": 0.38565972447395325, "span_start": null, "span_end": null, "passage": "Args:\n            root: The root object of the model _fields_set: The set of fields to be updated Returns:\n            The new model Raises:\n            NotImplemented: If the model is not a subclass ..."}, {"qid": "", "rank": 14, "path": "pydantic/root_model.py", "score": 0.3849526047706604, "span_start": null, "span_end": null, "passage": "import PydanticUserError\nfrom ._internal import _model_construction, _repr\nfrom .main import BaseModel, _object_setattr\n\nif typing.TYPE_CHECKING:\n    from typing import Any\n\n    from typing_extensions..."}, {"qid": "", "rank": 15, "path": "pydantic/mypy.py", "score": 0.3840526342391968, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    tracked_config_fields: set[str] = {\n        'extra',\n        'frozen',\n        'from_attributes',\n        'populate_by_name',\n        'alias_generator',\n    }\n\n    def __init__(\n        self,..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/main.py", "score": 0.38116613030433655, "span_start": null, "span_end": null, "passage": "added to the model\nUNTOUCHED_TYPES: Tuple[Any, ...] = (FunctionType,) + ANNOTATED_FIELD_UNTOUCHED_TYPES\n# Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we n..."}, {"qid": "", "rank": 17, "path": "tests/test_forward_ref.py", "score": 0.38078629970550537, "span_start": null, "span_end": null, "passage": "bar2: int | str | Bar[float]\n\nclass Bar(BaseModel, Generic[T]):\n    foo: Foo\n\"\"\"\n    )\n\n    assert module.Foo.model_fields['bar'].annotation == typing.Optional[module.Bar[str]]\n    assert module.Foo.m..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_model_construction.py", "score": 0.38011807203292847, "span_start": null, "span_end": null, "passage": "See #3829 and python/cpython#92810\n        \"\"\"\n        return hasattr(instance, '__pydantic_validator__') and super().__instancecheck__(instance)\n\n    @staticmethod\n    def _collect_bases_data(bases: ..."}, {"qid": "", "rank": 19, "path": "pydantic/functional_validators.py", "score": 0.37957555055618286, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}, {"qid": "", "rank": 20, "path": "pydantic/v1/schema.py", "score": 0.3790627121925354, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}], "latency_ms": 3.9615631103515625, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 4.066228866577148, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.5521984100341797, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.5314559936523438, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 3.549814224243164, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_4948cbaa", "query": "find class Model", "results": [{"qid": "", "rank": 1, "path": "tests/test_config.py", "score": 0.6021097302436829, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.576816201210022, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.48249751329421997, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of ..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4719182252883911, "span_start": null, "span_end": null, "passage": "field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4716002941131592, "span_start": null, "span_end": null, "passage": ":param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-mod..."}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.467088520526886, "span_start": null, "span_end": null, "passage": "current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collec..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_model_construction.py", "score": 0.46699458360671997, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/schema.py", "score": 0.46314650774002075, "span_start": null, "span_end": null, "passage": ":param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = k..."}, {"qid": "", "rank": 9, "path": "pydantic/dataclasses.py", "score": 0.46212315559387207, "span_start": null, "span_end": null, "passage": "See BaseModel.model_rebuild for reference"}, {"qid": "", "rank": 10, "path": "pydantic/v1/generics.py", "score": 0.45363831520080566, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.4488960802555084, "span_start": null, "span_end": null, "passage": "if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribut..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_fields.py", "score": 0.44638416171073914, "span_start": null, "span_end": null, "passage": "Also collect the names of any ClassVars present in the type hints The returned value is a tuple of two items: the fields dict, and the set of ClassVar names Args:\n        cls: BaseModel or dataclass b..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_model_construction.py", "score": 0.4447363615036011, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.4435155987739563, "span_start": null, "span_end": null, "passage": "Args:\n            cls: the class Returns:\n            The new decorator instance \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,..."}, {"qid": "", "rank": 15, "path": "tests/test_json_schema.py", "score": 0.4433159828186035, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Ref(BaseModel, Generic[T]):\n        uuid: str\n\n        def resolve(self) -> T: .. class Model(BaseModel):\n        uuid: str\n        model: Union[Ref['Model'], 'Model']\n\n        def reso..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.44169121980667114, "span_start": null, "span_end": null, "passage": ":param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        m..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4385329782962799, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.4379361867904663, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.4376203715801239, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.43732506036758423, "span_start": null, "span_end": null, "passage": "Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                .."}], "latency_ms": 4.498481750488281, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_symbol_0e21b304", "query": "find constant FOO", "results": [{"qid": "", "rank": 1, "path": "pydantic/types.py", "score": 0.3323928415775299, "span_start": null, "span_end": null, "passage": "=== \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, constr\n\n            class Foo(BaseModel):\n                bar: constr(strip_whitespace=True, to_upper=True, patter..."}, {"qid": "", "rank": 2, "path": "pydantic/experimental/pipeline.py", "score": 0.3271251320838928, "span_start": null, "span_end": null, "passage": "import inspect\n\n            try:\n                # remove ')' suffix, can use removesuffix once we drop 3.8\n                source = inspect.getsource(func).strip()\n                if source.endswith(..."}, {"qid": "", "rank": 3, "path": "tests/test_types.py", "score": 0.3192576766014099, "span_start": null, "span_end": null, "passage": "assert str(f.password) == '**********'\n    assert str(f.empty_password) == ''\n    assert repr(f.password) == \"DecryptableStr('**********')\"\n    assert repr(f.empty_password) == \"SecretStr('')\"\n    ass..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators.py", "score": 0.3153221011161804, "span_start": null, "span_end": null, "passage": "unwrap_types = (\n        (property, cached_property)\n        + ((partial, partialmethod) if unwrap_partial else ())\n        + ((staticmethod, classmethod) if unwrap_class_static_method else ())\n    )\n..."}, {"qid": "", "rank": 5, "path": "tests/test_types.py", "score": 0.312679260969162, "span_start": null, "span_end": null, "passage": "assert str(f.password) == \"b'**********'\"\n    assert str(f.empty_password) == \"b''\"\n    assert repr(f.password) == \"SecretBytes(b'**********')\"\n    assert repr(f.empty_password) == \"SecretBytes(b'')\"\n..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/types.py", "score": 0.31060922145843506, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()\n\n    def __str__(self) -> str:\n        return '*..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3099634349346161, "span_start": null, "span_end": null, "passage": "`Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`"}, {"qid": "", "rank": 8, "path": "pydantic/types.py", "score": 0.3086055815219879, "span_start": null, "span_end": null, "passage": "=== \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, conint\n\n            class Foo(BaseModel):\n                bar: conint(strict=True, gt=0)\n            ```\n\n        ..."}, {"qid": "", "rank": 9, "path": "pydantic/types.py", "score": 0.30238354206085205, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_typing_extra.py", "score": 0.299335241317749, "span_start": null, "span_end": null, "passage": "base_globals, base_locals = base_locals, base_globals\n                for name, value in ann.items():\n                    if value is None:\n                        value = type(None)\n                 ..."}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.2920910716056824, "span_start": null, "span_end": null, "passage": "if name is None or name == 'default':\n                    return arg.__class__ is not EllipsisExpr\n                if name == 'default_factory':\n                    return not (isinstance(arg, NameExp..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/mypy.py", "score": 0.2864331901073456, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    self_ty..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.2847757935523987, "span_start": null, "span_end": null, "passage": "Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)\n        \"\"\"\n        if name not in self.tracked_config_fields:\n            return None\n   ..."}, {"qid": "", "rank": 14, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.28383901715278625, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 15, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.28383901715278625, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 16, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.28383901715278625, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 17, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.28383901715278625, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 18, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.28383901715278625, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 19, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.28383901715278625, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}, {"qid": "", "rank": 20, "path": "pydantic/main.py", "score": 0.28383901715278625, "span_start": null, "span_end": null, "passage": "# This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1)"}], "latency_ms": 3.5839080810546875, "gold_paths": ["pydantic/config.py"]}
