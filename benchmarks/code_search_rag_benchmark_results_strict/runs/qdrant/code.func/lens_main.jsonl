{"qid": "lens_main_func_a002e697", "query": "Fix Python version check for `_eval_type` (#9781)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_typing_extra.py", "score": 0.7058625221252441, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if sys.version_info >= (3, 13):\n            return typing._eval_type(  # type: ignore\n                value, globalns, localns, type_params=type_params\n            )\n        else:..."}, {"qid": "", "rank": 2, "path": "tests/test_typing.py", "score": 0.6781543493270874, "span_start": null, "span_end": null, "passage": "To handle this error, '\n            'you should either remove the use of new syntax or install the '\n            '`eval_type_backport` package.'\n        )\n\n    finally:\n        del sys.modules['eval_t..."}, {"qid": "", "rank": 3, "path": "pydantic/deprecated/decorator.py", "score": 0.5923663377761841, "span_start": null, "span_end": null, "passage": "import warnings\nfrom functools import wraps\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Mapping, Optional, Tuple, Type, TypeVar, Union, overload\n\nfrom typing_extensions import depreca..."}, {"qid": "", "rank": 4, "path": "pydantic/types.py", "score": 0.5902155637741089, "span_start": null, "span_end": null, "passage": "warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.f..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_typing_extra.py", "score": 0.5898180603981018, "span_start": null, "span_end": null, "passage": "Before Python 3.10,\n                    # get_type_hints only evaluated the globalns of\n                    # a class To maintain backwards compatibility, we reverse\n                    # the globalns..."}, {"qid": "", "rank": 6, "path": "pydantic/deprecated/tools.py", "score": 0.5850069522857666, "span_start": null, "span_end": null, "passage": "Use `pydantic.TypeAdapter.validate_python` instead.',\n    category=None,\n)\ndef parse_obj_as(type_: type[T], obj: Any, type_name: NameFactory | None = None) -> T:\n    warnings.warn(\n        '`parse_obj..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/typing.py", "score": 0.5809340476989746, "span_start": null, "span_end": null, "passage": "\"\"\"\n    base_globals: Optional[Dict[str, Any]] = None\n    if module_name:\n        try:\n            module = sys.modules[module_name]\n        except KeyError:\n            # happens occasionally, see ht..."}, {"qid": "", "rank": 8, "path": "pydantic/fields.py", "score": 0.5676770210266113, "span_start": null, "span_end": null, "passage": "import types\nfrom ._internal import _decorators, _fields, _generics, _internal_dataclass, _repr, _typing_extra, _utils\nfrom .aliases import AliasChoices, AliasPath\nfrom .config import JsonDict\nfrom .e..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_typing_extra.py", "score": 0.5670832991600037, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_typing_extra.py", "score": 0.5625642538070679, "span_start": null, "span_end": null, "passage": "\"\"\"\n    hints = {}\n    for base in reversed(obj.__mro__):\n        ann = base.__dict__.get('__annotations__')\n        localns = dict(vars(base))\n        if ann is not None and ann is not GetSetDescript..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/utils.py", "score": 0.5591305494308472, "span_start": null, "span_end": null, "passage": "import keyword\nimport warnings\nimport weakref\nfrom collections import OrderedDict, defaultdict, deque\nfrom copy import deepcopy\nfrom itertools import islice, zip_longest\nfrom types import BuiltinFunct..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/version.py", "score": 0.5518742799758911, "span_start": null, "span_end": null, "passage": "__all__ = 'compiled', 'VERSION', 'version_info'\n\nVERSION = '1.10.17'\n\ntry:\n    import cython  # type: ignore\nexcept ImportError:\n    compiled: bool = False\nelse:  # pragma: no cover\n    try:\n        c..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/utils.py", "score": 0.5514570474624634, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        eval('__IPYTHON__')\n    except NameError:\n        return False\n    else:  # pragma: no cover\n        return True\n\n\ndef is_valid_identifier(identifier: str) -> bool:\n    \"\"\"\n    Ch..."}, {"qid": "", "rank": 14, "path": "tests/mypy/outputs/1.1.1/pyproject-default_toml/fail2.py", "score": 0.5448776483535767, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types"}, {"qid": "", "rank": 15, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/fail2.py", "score": 0.5448776483535767, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types"}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.5422654747962952, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    self_ty..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.5409924983978271, "span_start": null, "span_end": null, "passage": "warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.f..."}, {"qid": "", "rank": 18, "path": "tests/mypy/modules/fail3.py", "score": 0.5403999090194702, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types \"\"\"\nfrom typing import Generic, List, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass Model(BaseModel):\n    list_of_ints: List[int]\n\n\nclass W..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_typing_extra.py", "score": 0.532180666923523, "span_start": null, "span_end": null, "passage": "* prefixing `typing.` where appropriate\n        * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument https://github.com/python/cpython/blob/aaaf5174241496afca7ce4..."}, {"qid": "", "rank": 20, "path": "pydantic/types.py", "score": 0.5319375991821289, "span_start": null, "span_end": null, "passage": "warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`StringConstraints`..."}], "latency_ms": 4.349708557128906, "gold_paths": ["pydantic/_internal/_typing_extra.py"]}
{"qid": "lens_main_func_f024d03b", "query": "Add \"DECIMAL_CONSTRAINTS\" to allow field constraints on \"Optional[Decimal]\" (#9754)", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/fields.py", "score": 0.6487014293670654, "span_start": null, "span_end": null, "passage": ":param decimal_places: only applies to Decimals, requires the field to have at most a number of decimal places\n      allowed It does not include trailing decimal zeroes :param min_items: only applies ..."}, {"qid": "", "rank": 2, "path": "pydantic/types.py", "score": 0.5702013969421387, "span_start": null, "span_end": null, "passage": "=== \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, condecimal\n\n            class Foo(BaseModel):\n                bar: condecimal(strict=True, allow_inf_nan=True)\n   ..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/fields.py", "score": 0.5607624650001526, "span_start": null, "span_end": null, "passage": "The\n      schema will have a ``multipleOf`` validation keyword\n    :param allow_inf_nan: only applies to numbers, allows the field to be NaN or infinity (+inf or -inf),\n        which is a valid Python..."}, {"qid": "", "rank": 4, "path": "pydantic/types.py", "score": 0.5603653192520142, "span_start": null, "span_end": null, "passage": "Args:\n        strict: Whether to validate the value in strict mode Defaults to `None` gt: The value must be greater than this Defaults to `None` ge: The value must be greater than or equal to this Def..."}, {"qid": "", "rank": 5, "path": "pydantic/types.py", "score": 0.5600639581680298, "span_start": null, "span_end": null, "passage": "```py\n    from decimal import Decimal\n\n    from pydantic import BaseModel, ValidationError, condecimal\n\n    class ConstrainedExample(BaseModel):\n        constrained_decimal: condecimal(gt=Decimal('1.0..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/fields.py", "score": 0.5550458431243896, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = (\n        'default',\n        'default_factory',\n        'alias',\n        'alias_priority',\n        'title',\n        'description',\n        'exclude',\n        'include',\n        'c..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/schema.py", "score": 0.5377364754676819, "span_start": null, "span_end": null, "passage": ":param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/types.py", "score": 0.5318827629089355, "span_start": null, "span_end": null, "passage": "\"\"\"\n            if isinstance(value, bool):\n                return value\n\n            raise errors.StrictBoolError()\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ INTEGER TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n..."}, {"qid": "", "rank": 9, "path": "pydantic/fields.py", "score": 0.5040079355239868, "span_start": null, "span_end": null, "passage": "(Only applies to dataclasses.)\n        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode) strict: If `True`, strict validation is applied..."}, {"qid": "", "rank": 10, "path": "tests/test_main.py", "score": 0.5018396377563477, "span_start": null, "span_end": null, "passage": "required_str_none_value: Optional[str] = .. existing_bytes_value: bytes = b'foo'\n        required_bytes_value: bytes = .. required_bytes_none_value: Optional[bytes] = .."}, {"qid": "", "rank": 11, "path": "docs/plugins/conversion_table.py", "score": 0.501374363899231, "span_start": null, "span_end": null, "passage": "`val % 1 == 0`.',\n        valid_examples=[Decimal(2.0)],\n        invalid_examples=[Decimal(2.1)],\n        core_schemas=[core_schema.IntSchema],\n    ),\n    Row(\n        int,\n        bool,\n        pytho..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/fields.py", "score": 0.5005892515182495, "span_start": null, "span_end": null, "passage": ":param const: this field is required and *must* take it's default value\n    :param gt: only applies to numbers, requires the field to be \"greater than\" The schema\n      will have an ``exclusiveMinimum..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/fields.py", "score": 0.493990957736969, "span_start": null, "span_end": null, "passage": "Some arguments\n    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str`` :param default: since this is replacing the field\u2019s default, its first argument is used\n..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.48938894271850586, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema: dict[str, Any] = {'type': 'number'}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)\n        json_schema = {k: v for k, v in json_sch..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.48340681195259094, "span_start": null, "span_end": null, "passage": "=== \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, confloat\n\n            class Foo(BaseModel):\n                bar: confloat(strict=True, gt=0)\n            ```\n\n    ..."}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.4823293387889862, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, StrictInt, ValidationError\n\nclass StrictIntModel(BaseModel):\n    strict_int: StrictInt\n\ntry:\n    StrictIntModel(strict_int=3.14159)\nexcept ValidationError as e:\n ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/types.py", "score": 0.47940054535865784, "span_start": null, "span_end": null, "passage": "if abs(exponent) > len(digit_tuple):\n                digits = decimals = abs(exponent)\n            else:\n                digits = len(digit_tuple)\n                decimals = abs(exponent)\n        whol..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/fields.py", "score": 0.47723421454429626, "span_start": null, "span_end": null, "passage": "\"\"\"\n        for attr_name, value in from_config.items():\n            try:\n                current_value = getattr(self, attr_name)\n            except AttributeError:\n                # attr_name is not..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/mypy.py", "score": 0.4757035970687866, "span_start": null, "span_end": null, "passage": "\"\"\"\n        expr = stmt.rvalue\n        if isinstance(expr, TempNode):\n            # TempNode means annotation-only, so only non-required if Optional\n            value_type = get_proper_type(cls.info[l..."}, {"qid": "", "rank": 20, "path": "pydantic/fields.py", "score": 0.47030109167099, "span_start": null, "span_end": null, "passage": "Used to provide extra information about a field, either for the model schema or complex validation Some arguments\n    apply only to number fields (`int`, `float`, `Decimal`) and some apply only to `st..."}], "latency_ms": 4.272699356079102, "gold_paths": ["pydantic/_internal/_known_annotated_metadata.py", "tests/test_types.py"]}
{"qid": "lens_main_func_941c021d", "query": "Package update to prep for v2.8 (#9741)", "results": [{"qid": "", "rank": 1, "path": "pydantic/warnings.py", "score": 0.36126795411109924, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific warnings.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom .version import version_short\n\n__all__ = (\n    'PydanticDeprecatedSince20',\n    'PydanticDeprecationWarning'..."}, {"qid": "", "rank": 2, "path": "pydantic/warnings.py", "score": 0.3493827283382416, "span_start": null, "span_end": null, "passage": "This warning is raised when using experimental functionality in Pydantic It is raised to warn users that the functionality may change or be removed in future versions of Pydantic \"\"\""}, {"qid": "", "rank": 3, "path": "pydantic/warnings.py", "score": 0.338133841753006, "span_start": null, "span_end": null, "passage": "It provides information on when the\n    deprecation was introduced and the expected version in which the corresponding functionality will be removed Attributes:\n        message: Description of the war..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/mypy.py", "score": 0.32640790939331055, "span_start": null, "span_end": null, "passage": "var_str = repr(var)\n                    detail = f'sym_node.node: {var_str} (of type {var.__class__})'\n                    error_unexpected_behavior(detail, ctx.api, ctx.cls)\n            else:\n       ..."}, {"qid": "", "rank": 5, "path": "pydantic/version.py", "score": 0.31761592626571655, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return '.'.join(VERSION.split('.')[:2])\n\n\ndef version_info() -> str:\n    \"\"\"Return complete version information for Pydantic and its dependencies.\"\"\"\n    import importlib.metadata as importlib..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_dataclasses.py", "score": 0.31572839617729187, "span_start": null, "span_end": null, "passage": "Raises:\n        PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations"}, {"qid": "", "rank": 7, "path": "pydantic/deprecated/config.py", "score": 0.3156599998474121, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nimport warnings\nfrom typing import TYPE_CHECKING, Any\n\nfrom typing_extensions import Literal, deprecated\n\nfrom .._internal import _config\nfrom ..war..."}, {"qid": "", "rank": 8, "path": "tests/test_warnings.py", "score": 0.31550028920173645, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V2.1 to be removed in V3.0.'\n\n\ndef test_pydantic_deprecation_warning_2_0_migration_guide_link():\n    warning = PydanticDeprecationWarning('Warning message', since=(2, 0))\n\n    a..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_config.py", "score": 0.3104546070098877, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nimport warnings\nfrom contextlib import contextmanager\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    cast,\n)\n\nfrom pydantic_core..."}, {"qid": "", "rank": 10, "path": "pydantic/version.py", "score": 0.31021249294281006, "span_start": null, "span_end": null, "passage": "\"\"\"The `version` module holds the version information for Pydantic.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\n__all__ = 'VERSION', 'version_info'\n\nVERSION = '2.8.0'\n\"\"\"The version of Pyd..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.30962127447128296, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nfrom typing import TYPE_CHECKING, Any, Hashable, Sequence\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom ..errors import PydanticUserError..."}, {"qid": "", "rank": 12, "path": "tests/test_forward_ref.py", "score": 0.3064478635787964, "span_start": null, "span_end": null, "passage": "#   The initial attempt to refactor them into a single parameterized test was not straightforward due to the use of the\n#   `create_module` fixture and the requirement that `from __future__ import ann..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/version.py", "score": 0.3031747341156006, "span_start": null, "span_end": null, "passage": "__all__ = 'compiled', 'VERSION', 'version_info'\n\nVERSION = '1.10.17'\n\ntry:\n    import cython  # type: ignore\nexcept ImportError:\n    compiled: bool = False\nelse:  # pragma: no cover\n    try:\n        c..."}, {"qid": "", "rank": 14, "path": "tests/test_warnings.py", "score": 0.30104345083236694, "span_start": null, "span_end": null, "passage": "See Pydantic V2 Migration Guide at https://errors.pydantic.dev/{version_short()}/migration/'\n    )\n\n\ndef test_pydantic_deprecated_since_2_0_warning():\n    warning = PydanticDeprecatedSince20('Warning ..."}, {"qid": "", "rank": 15, "path": "pydantic/mypy.py", "score": 0.29962441325187683, "span_start": null, "span_end": null, "passage": "var_str = repr(var)\n                    detail = f'sym_node.node: {var_str} (of type {var.__class__})'\n                    error_unexpected_behavior(detail, self._api, self._cls)\n            else:\n   ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.2955920696258545, "span_start": null, "span_end": null, "passage": "\"\"\"Logic for generating pydantic-core schemas for standard library types Import of this module is deferred since it contains imports of many standard library modules"}, {"qid": "", "rank": 17, "path": "pydantic/deprecated/class_validators.py", "score": 0.29550713300704956, "span_start": null, "span_end": null, "passage": "\"\"\"Old `@validator` and `@root_validator` function validators from V1.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom functools import partial, partialmethod\nfrom types import FunctionTy..."}, {"qid": "", "rank": 18, "path": "pydantic/_migration.py", "score": 0.2908385694026947, "span_start": null, "span_end": null, "passage": "import sys\nfrom typing import Any, Callable, Dict\n\nfrom .version import version_short\n\nMOVED_IN_V2 = {\n    'pydantic.utils:version_info': 'pydantic.version:version_info',\n    'pydantic.error_wrappers:..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_validators.py", "score": 0.2908172607421875, "span_start": null, "span_end": null, "passage": "\"\"\"Validator functions for standard library types Import of this module is deferred since it contains imports of many standard library modules"}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_dataclasses.py", "score": 0.28874748945236206, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if hasattr(cls, '__post_init_post_parse__'):\n        warnings.warn(\n            'Support for `__post_init_post_parse__` has been dropped, the method will not be called', DeprecationWarning\n   ..."}], "latency_ms": 4.015922546386719, "gold_paths": ["tests/test_networks.py", "tests/test_types.py"]}
{"qid": "lens_main_func_68a27478", "query": "Update `pydantic.v1` stub to v1.10.17 (#9707)", "results": [{"qid": "", "rank": 1, "path": "tests/test_json_schema.py", "score": 0.6919645071029663, "span_start": null, "span_end": null, "passage": "This was reported as broken in https://github.com/pydantic/pydantic/issues/8689, which was\n    originally caused by the change made in https://github.com/pydantic/pydantic/pull/8583, which has\n    sin..."}, {"qid": "", "rank": 2, "path": "tests/test_forward_ref.py", "score": 0.6171002388000488, "span_start": null, "span_end": null, "passage": "# At the same time, `PydanticRecursiveRef.__or__` means that the second `|` works normally,\n    # which actually triggered a bug in the backport that needed fixing"}, {"qid": "", "rank": 3, "path": "pydantic/_migration.py", "score": 0.6167510747909546, "span_start": null, "span_end": null, "passage": "We are importing from `{new_location}` instead.'\n                'See the migration guide for more details: https://docs.pydantic.dev/latest/migration/'\n            )\n            return import_string(..."}, {"qid": "", "rank": 4, "path": "tests/test_warnings.py", "score": 0.6131225228309631, "span_start": null, "span_end": null, "passage": "See Pydantic V2 Migration Guide at https://errors.pydantic.dev/{version_short()}/migration/'\n    )\n\n\ndef test_pydantic_deprecated_since_2_0_warning():\n    warning = PydanticDeprecatedSince20('Warning ..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_typing_extra.py", "score": 0.6125615835189819, "span_start": null, "span_end": null, "passage": "The `module` argument is omitted as it breaks <3.9.8, =3.10.0 and isn't used in the calls below See https://github.com/python/cpython/pull/28560 for some background The backport happened on 3.9.8, see..."}, {"qid": "", "rank": 6, "path": "pydantic/experimental/__init__.py", "score": 0.6050186157226562, "span_start": null, "span_end": null, "passage": "\"\"\"The \"experimental\" module of pydantic contains potential new features that are subject to change.\"\"\"\n\nimport warnings\n\nfrom pydantic.warnings import PydanticExperimentalWarning\n\nwarnings.warn(\n    ..."}, {"qid": "", "rank": 7, "path": "tests/test_type_hints.py", "score": 0.6008873581886292, "span_start": null, "span_end": null, "passage": "pydantic.warnings.PydanticDeprecatedSince20: The `__fields__` attribute is deprecated,\n#      use `model_fields` instead"}, {"qid": "", "rank": 8, "path": "pydantic/v1/config.py", "score": 0.5992956161499023, "span_start": null, "span_end": null, "passage": "# Pydantic v2 doesn't depend on Cython at all"}, {"qid": "", "rank": 9, "path": "pydantic/_migration.py", "score": 0.5926151275634766, "span_start": null, "span_end": null, "passage": "'\n                f'See https://docs.pydantic.dev/{version_short()}/migration/#basesettings-has-moved-to-pydantic-settings '\n                'for more details.'\n            )\n        if import_path in..."}, {"qid": "", "rank": 10, "path": "tests/test_warnings.py", "score": 0.5917847156524658, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V2.1 to be removed in V3.0.'\n\n\ndef test_pydantic_deprecation_warning_2_0_migration_guide_link():\n    warning = PydanticDeprecationWarning('Warning message', since=(2, 0))\n\n    a..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5849010944366455, "span_start": null, "span_end": null, "passage": "This is not a limitation of pydantic_core, but if we try to handle\n        # this, the inference logic gets complicated very quickly, and could result in confusing\n        # debugging challenges for u..."}, {"qid": "", "rank": 12, "path": "pydantic/errors.py", "score": 0.5661342144012451, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version imp..."}, {"qid": "", "rank": 13, "path": "pydantic/version.py", "score": 0.5592424869537354, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return '.'.join(VERSION.split('.')[:2])\n\n\ndef version_info() -> str:\n    \"\"\"Return complete version information for Pydantic and its dependencies.\"\"\"\n    import importlib.metadata as importlib..."}, {"qid": "", "rank": 14, "path": "pydantic/warnings.py", "score": 0.5586519837379456, "span_start": null, "span_end": null, "passage": "This warning is raised when using experimental functionality in Pydantic It is raised to warn users that the functionality may change or be removed in future versions of Pydantic \"\"\""}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5582407712936401, "span_start": null, "span_end": null, "passage": "Note: `__get_pydantic_core_schema__` takes priority so it can\n        decide whether to use a `__pydantic_core_schema__` attribute, or generate a fresh schema"}, {"qid": "", "rank": 16, "path": "pydantic/dataclasses.py", "score": 0.5576271414756775, "span_start": null, "span_end": null, "passage": "\"\"\"\n        raise TypeError(\"'InitVar' object is not callable\")\n\n    dataclasses.InitVar.__call__ = _call_initvar\n\n\ndef rebuild_dataclass(\n    cls: type[PydanticDataclass],\n    *,\n    force: bool = Fa..."}, {"qid": "", "rank": 17, "path": "pydantic/version.py", "score": 0.5486875772476196, "span_start": null, "span_end": null, "passage": "\"\"\"The `version` module holds the version information for Pydantic.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\n__all__ = 'VERSION', 'version_info'\n\nVERSION = '2.8.0'\n\"\"\"The version of Pyd..."}, {"qid": "", "rank": 18, "path": "pydantic/_migration.py", "score": 0.5412143468856812, "span_start": null, "span_end": null, "passage": "import sys\nfrom typing import Any, Callable, Dict\n\nfrom .version import version_short\n\nMOVED_IN_V2 = {\n    'pydantic.utils:version_info': 'pydantic.version:version_info',\n    'pydantic.error_wrappers:..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.5411955118179321, "span_start": null, "span_end": null, "passage": "Returns:\n        A wrapped V2 style field validator Raises:\n        PydanticUserError: If the signature is not supported or the parameters are\n            not available in Pydantic V2"}, {"qid": "", "rank": 20, "path": "pydantic/warnings.py", "score": 0.5381611585617065, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V{self.since[0]}.{self.since[1]}'\n            f' to be removed in V{self.expected_removal[0]}.{self.expected_removal[1]}.'\n        )\n        if self.since == (2, 0):\n           ..."}], "latency_ms": 3.7887096405029297, "gold_paths": ["pydantic/v1/error_wrappers.py", "pydantic/v1/schema.py", "pydantic/v1/version.py"]}
{"qid": "lens_main_func_c66288a6", "query": "Relax type specification for `__validators__` values in `create_model` (#9697)", "results": [{"qid": "", "rank": 1, "path": "pydantic/functional_validators.py", "score": 0.667144775390625, "span_start": null, "span_end": null, "passage": "class ModelBeforeValidator(Protocol):\n    \"\"\"A `@model_validator` decorated function signature This is used when `mode='before'`.\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        cls: Any,\n  ..."}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.6618369817733765, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    # whether to validate default values during validation, default False\n    validate_default: bool\n    \"\"\"Whether to validate default values during validation Defaults to `False`.\"\"\"\n\n    valid..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/main.py", "score": 0.6609067916870117, "span_start": null, "span_end": null, "passage": ":param __model_name: name of the created model\n    :param __config__: config class to use for the new model\n    :param __base__: base class for the new model to inherit from\n    :param __module__: mod..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6589387655258179, "span_start": null, "span_end": null, "passage": "(Or we can extend it and keep it if we add something equivalent\n    to the v1-validator `always` kwarg to `field_validator`.)\n    \"\"\"\n    for validator in validators:\n        if validator.info.always:..."}, {"qid": "", "rank": 5, "path": "pydantic/functional_validators.py", "score": 0.6583237051963806, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        cls: type[_ModelType],\n        # this can be a dict, a model instance\n        # or anything else that gets passed to validate_python\n        ..."}, {"qid": "", "rank": 6, "path": "pydantic/functional_validators.py", "score": 0.6505659818649292, "span_start": null, "span_end": null, "passage": "class FreeModelBeforeValidator(Protocol):\n    \"\"\"A `@model_validator` decorated function signature This is used when `mode='before'`.\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        # this c..."}, {"qid": "", "rank": 7, "path": "pydantic/type_adapter.py", "score": 0.643635094165802, "span_start": null, "span_end": null, "passage": "Thus, this feature is opt-in to ensure backwards\n    compatibility Attributes:\n        core_schema: The core schema for the type validator (SchemaValidator): The schema validator for the type serializ..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.6431254744529724, "span_start": null, "span_end": null, "passage": "def make_v1_generic_root_validator(\n    validator: V1RootValidatorFunction, pre: bool\n) -> V2CoreBeforeRootValidator | V2CoreAfterRootValidator:\n    \"\"\"Wrap a V1 style root validator for V2 compatibil..."}, {"qid": "", "rank": 9, "path": "pydantic/main.py", "score": 0.6392420530319214, "span_start": null, "span_end": null, "passage": "Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n            an error if extra values are passed, but they will be igno..."}, {"qid": "", "rank": 10, "path": "pydantic/functional_validators.py", "score": 0.6368284225463867, "span_start": null, "span_end": null, "passage": "This is used when `mode='wrap'`.\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        cls: type[_ModelType],\n        # this can be a dict, a model instance\n        # or anything else that gets pa..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/fields.py", "score": 0.6340137720108032, "span_start": null, "span_end": null, "passage": "\"\"\"\n        self.validate_always = getattr(self.type_, 'validate_always', False) or any(\n            v.always for v in self.class_validators.values()\n        )\n\n        class_validators_ = self.class_..."}, {"qid": "", "rank": 12, "path": "pydantic/functional_validators.py", "score": 0.631556510925293, "span_start": null, "span_end": null, "passage": "@overload\ndef model_validator(\n    *,\n    mode: Literal['before'],\n) -> Callable[\n    [_AnyModeBeforeValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]\n]: .. @ove..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6305420398712158, "span_start": null, "span_end": null, "passage": "\"\"\"\n    for validator in validators:\n        info_arg = inspect_validator(validator.func, validator.info.mode)\n        val_type = 'with-info' if info_arg else 'no-info'\n\n        schema = _VALIDATOR_F_..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/main.py", "score": 0.6261334419250488, "span_start": null, "span_end": null, "passage": "@overload\ndef create_model(\n    __model_name: str,\n    *,\n    __config__: Optional[Type[BaseConfig]] = None,\n    __base__: Union[Type['Model'], Tuple[Type['Model'], ...]],\n    __module__: str = __name..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/fields.py", "score": 0.62441086769104, "span_start": null, "span_end": null, "passage": "assert self.sub_fields_mapping is not None\n            return v, ErrorWrapper(\n                InvalidDiscriminator(\n                    discriminator_key=self.discriminator_key,\n                    d..."}, {"qid": "", "rank": 16, "path": "pydantic/mypy.py", "score": 0.623291015625, "span_start": null, "span_end": null, "passage": "\"\"\"\n        cls = self._cls\n\n        lhs = stmt.lvalues[0]\n        if not isinstance(lhs, NameExpr) or not _fields.is_valid_field_name(lhs.name) or lhs.name == 'model_config':\n            return None\n..."}, {"qid": "", "rank": 17, "path": "pydantic/functional_validators.py", "score": 0.6212801933288574, "span_start": null, "span_end": null, "passage": "class ModelBeforeValidatorWithoutInfo(Protocol):\n    \"\"\"A @model_validator decorated function signature This is used when `mode='before'` and the function does not have info argument \"\"\"\n\n    def __ca..."}, {"qid": "", "rank": 18, "path": "pydantic/main.py", "score": 0.619520902633667, "span_start": null, "span_end": null, "passage": "Args:\n            obj: The object to validate strict: Whether to enforce types strictly from_attributes: Whether to extract data from object attributes context: Additional context to pass to the valid..."}, {"qid": "", "rank": 19, "path": "pydantic/main.py", "score": 0.6174690127372742, "span_start": null, "span_end": null, "passage": "The keys are the names of the validation methods to\n            be added to the model, and the values are the validation methods themselves You can read more about functional\n            validators [h..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.6159453392028809, "span_start": null, "span_end": null, "passage": "def model_validator(\n    *,\n    mode: Literal['wrap', 'before', 'after'],\n) -> Any:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#model-validators\n\n    Decorate model methods f..."}], "latency_ms": 3.969907760620117, "gold_paths": ["pydantic/main.py"]}
{"qid": "lens_main_func_9dac6844", "query": "Bump pyright to 1.1.367 and add type checking tests for pipeline API (#9674)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.5185922384262085, "span_start": null, "span_end": null, "passage": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable, Generic, Iterator, Mapping, TypeVar\n\nfrom pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator\nfrom t..."}, {"qid": "", "rank": 2, "path": "tests/pyright/pipeline_api.py", "score": 0.5165469646453857, "span_start": null, "span_end": null, "passage": "import datetime\nfrom typing import Annotated\n\nfrom pydantic.experimental.pipeline import validate_as\n\n# this test works by adding type ignores and having pyright fail with\n# an unused type ignore erro..."}, {"qid": "", "rank": 3, "path": "pydantic/experimental/pipeline.py", "score": 0.5119715332984924, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if isinstance(tp, EllipsisType):\n            return _Pipeline[_InT, Any](self._steps + (_ValidateAs(_FieldTypeMarker, strict=strict),))\n        return _Pipeline[_InT, _NewOutT](self._steps..."}, {"qid": "", "rank": 4, "path": "pydantic/deprecated/decorator.py", "score": 0.5050722360610962, "span_start": null, "span_end": null, "passage": "import warnings\nfrom functools import wraps\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Mapping, Optional, Tuple, Type, TypeVar, Union, overload\n\nfrom typing_extensions import depreca..."}, {"qid": "", "rank": 5, "path": "pydantic/config.py", "score": 0.5041321516036987, "span_start": null, "span_end": null, "passage": "By default, the validator and serializer\n        for said models is constructed immediately for FastAPI routes You also need to define\n        [`experimental_defer_build_mode=('model', 'type_adapter')..."}, {"qid": "", "rank": 6, "path": "tests/test_pipeline.py", "score": 0.5019115209579468, "span_start": null, "span_end": null, "passage": "\"\"\"Tests for the experimental transform module.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\nimport sys\nimport warnings\nfrom decimal import Decimal\nfrom typing import Any, Callable, Dict, F..."}, {"qid": "", "rank": 7, "path": "pydantic/deprecated/tools.py", "score": 0.49812018871307373, "span_start": null, "span_end": null, "passage": "from __future__ import annotations\n\nimport json\nimport warnings\nfrom typing import TYPE_CHECKING, Any, Callable, Type, TypeVar, Union\n\nfrom typing_extensions import deprecated\n\nfrom ..json_schema impo..."}, {"qid": "", "rank": 8, "path": "pydantic/fields.py", "score": 0.49064362049102783, "span_start": null, "span_end": null, "passage": "To avoid this error message, add `# type: ignore[misc]` to the `@computed_field` line [pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_core_utils.py", "score": 0.49062782526016235, "span_start": null, "span_end": null, "passage": "#   Issue: https://github.com/pydantic/pydantic-core/issues/615\n\n\nclass _WalkCoreSchema:\n    def __init__(self):\n        self._schema_type_to_method = self._build_schema_type_to_method()\n\n    def _bui..."}, {"qid": "", "rank": 10, "path": "pydantic/experimental/pipeline.py", "score": 0.4875302314758301, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}, {"qid": "", "rank": 11, "path": "pydantic/plugin/__init__.py", "score": 0.48525768518447876, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Callable, NamedTuple\n\nfrom pydantic_core import CoreConfig, CoreSchema, ValidationError\nfrom typing_extensions import Literal, Protocol..."}, {"qid": "", "rank": 12, "path": "pydantic/type_adapter.py", "score": 0.48362836241722107, "span_start": null, "span_end": null, "passage": "**Note:** By default, `TypeAdapter` does not respect the\n    [`defer_build=True`][pydantic.config.ConfigDict.defer_build] setting in the\n    [`model_config`][pydantic.BaseModel.model_config] or in the..."}, {"qid": "", "rank": 13, "path": "pydantic/type_adapter.py", "score": 0.47702643275260925, "span_start": null, "span_end": null, "passage": "\"\"\"Type adapter specification.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport sys\nfrom contextlib import contextmanager\nfrom dataclasses import is_dataclass\nfrom functools import cache..."}, {"qid": "", "rank": 14, "path": "pydantic/experimental/pipeline.py", "score": 0.4759347438812256, "span_start": null, "span_end": null, "passage": "def validate_as(self, tp: type[_NewOutT] | EllipsisType, *, strict: bool = False) -> _Pipeline[_InT, Any]:  # type: ignore\n        \"\"\"Validate / parse the input into a new type If no type is provided,..."}, {"qid": "", "rank": 15, "path": "pydantic/experimental/pipeline.py", "score": 0.4752727746963501, "span_start": null, "span_end": null, "passage": "This is useful when you need to reference the class in it's own type annotations \"\"\"\n        return _Pipeline[_InT, _NewOutT](self._steps + (_ValidateAsDefer(func),))\n\n    # constraints\n    @overload\n..."}, {"qid": "", "rank": 16, "path": "pydantic/plugin/_schema_validator.py", "score": 0.47250425815582275, "span_start": null, "span_end": null, "passage": "\"\"\"Pluggable schema validator for pydantic.\"\"\"\n\nfrom __future__ import annotations\n\nimport functools\nfrom typing import TYPE_CHECKING, Any, Callable, Iterable, TypeVar\n\nfrom pydantic_core import CoreC..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.46221399307250977, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n        return cls.__pydantic_validator__.validate_strings(ob..."}, {"qid": "", "rank": 18, "path": "tests/pyright/pyright_example.py", "score": 0.46155452728271484, "span_start": null, "span_end": null, "passage": "\"\"\"\nThis file is used to test pyright's ability to check pydantic code"}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_dataclasses.py", "score": 0.4615231156349182, "span_start": null, "span_end": null, "passage": "import _config, _decorators, _typing_extra\nfrom ._fields import collect_dataclass_fields\nfrom ._generate_schema import GenerateSchema\nfrom ._generics import get_standard_typevars_map\nfrom ._mock_val_s..."}, {"qid": "", "rank": 20, "path": "pydantic/fields.py", "score": 0.4566968083381653, "span_start": null, "span_end": null, "passage": "import types\nfrom ._internal import _decorators, _fields, _generics, _internal_dataclass, _repr, _typing_extra, _utils\nfrom .aliases import AliasChoices, AliasPath\nfrom .config import JsonDict\nfrom .e..."}], "latency_ms": 4.22978401184082, "gold_paths": ["pydantic/experimental/pipeline.py", "tests/pyright/pipeline_api.py", "tests/test_pipeline.py"]}
{"qid": "lens_main_func_ff51bc0b", "query": "Update citation version automatically (#9673)", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.33713072538375854, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file}#{slug})\\n'\n\n\ndef update_docstring(obj: GriffeObject) -> str:\n    return re.sub(\n        r'usage[\\- ]docs: ?https://docs\\.pydantic\\.dev/.+?..."}, {"qid": "", "rank": 2, "path": "pydantic/version.py", "score": 0.3208737373352051, "span_start": null, "span_end": null, "passage": "\"\"\"The `version` module holds the version information for Pydantic.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\n__all__ = 'VERSION', 'version_info'\n\nVERSION = '2.8.0'\n\"\"\"The version of Pyd..."}, {"qid": "", "rank": 3, "path": "release/make_history.py", "score": 0.3151208758354187, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nimport argparse\nimport json\nimport re\nimport subprocess\nimport sys\nfrom datetime import date\nfrom pathlib import Path\n\nimport requests\n\n\ndef main():..."}, {"qid": "", "rank": 4, "path": "pydantic/errors.py", "score": 0.307441771030426, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version imp..."}, {"qid": "", "rank": 5, "path": "tests/check_usage_docs.py", "score": 0.3062760531902313, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport re\nimport sys\nfrom pathlib import Path\n\nROOT_DIR = Path(__file__).parent.parent\nPYDANTIC_DIR = ROOT_DIR / 'pydantic'\nversion_file = PYDANTIC_DIR / 'version.py'\n\n\nversion = re.search(rb\"VER..."}, {"qid": "", "rank": 6, "path": "pydantic/fields.py", "score": 0.30604660511016846, "span_start": null, "span_end": null, "passage": "use `frozen` instead', DeprecationWarning)\n        if allow_mutation is False:\n            frozen = True\n\n    regex = extra.pop('regex', None)  # type: ignore\n    if regex is not None:\n        raise P..."}, {"qid": "", "rank": 7, "path": "tests/check_usage_docs.py", "score": 0.3030446767807007, "span_start": null, "span_end": null, "passage": "\"\"\"\nCheck that all `Usage docs` tags in docstrings link to the latest version of pydantic"}, {"qid": "", "rank": 8, "path": "pydantic/version.py", "score": 0.2789512872695923, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return '.'.join(VERSION.split('.')[:2])\n\n\ndef version_info() -> str:\n    \"\"\"Return complete version information for Pydantic and its dependencies.\"\"\"\n    import importlib.metadata as importlib..."}, {"qid": "", "rank": 9, "path": "tests/test_version.py", "score": 0.27844148874282837, "span_start": null, "span_end": null, "passage": "from unittest.mock import patch\n\nimport pytest\nfrom packaging.version import parse as parse_version\n\nimport pydantic\nfrom pydantic.version import version_info, version_short\n\n\ndef test_version_info():..."}, {"qid": "", "rank": 10, "path": "pydantic/dataclasses.py", "score": 0.27616629004478455, "span_start": null, "span_end": null, "passage": "field_args: dict = {'default': field_value}\n\n                # Handle `kw_only` for Python 3.10+\n                if sys.version_info >= (3, 10) and field_value.kw_only:\n                    field_args[..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.2664957344532013, "span_start": null, "span_end": null, "passage": "`Annotated[int, Strict]` as well as `Annotated[int, Strict()]`\n            res.update({k: v for k, v in vars(annotation).items() if not k.startswith('_')})\n        else:\n            remaining.append(a..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/fields.py", "score": 0.25971317291259766, "span_start": null, "span_end": null, "passage": "\"\"\"\n        field_info_from_config = config.get_field_info(field_name)\n\n        field_info = None\n        if get_origin(annotation) is Annotated:\n            field_infos = [arg for arg in get_args(ann..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.25620824098587036, "span_start": null, "span_end": null, "passage": "We might want to use this to print a warning if the mypy version being used is\n    newer, or especially older, than we expect (or need) Args:\n        version: The mypy version string Return:\n        T..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generate_schema.py", "score": 0.2552969455718994, "span_start": null, "span_end": null, "passage": "This gets called by `GenerateSchema._annotated_schema` but differs from it in that it does\n        not expect `source_type` to be an `Annotated` object, it expects it to be  the first argument of that..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_core_utils.py", "score": 0.2531065344810486, "span_start": null, "span_end": null, "passage": "# put all other keys that were on the def-ref schema into the inlined version\n                # in particular this is needed for `serialization`\n                if 'serialization' in s:\n              ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_fields.py", "score": 0.25065380334854126, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return _general_metadata_cls()(metadata)  # type: ignore\n\n\n@lru_cache(maxsize=None)\ndef _general_metadata_cls() -> type[BaseMetadata]:\n    \"\"\"Do it this way to avoid importing `annotated_types..."}, {"qid": "", "rank": 17, "path": "docs/plugins/using_update.py", "score": 0.24921861290931702, "span_start": null, "span_end": null, "passage": "from pathlib import Path\nfrom time import sleep\n\nimport requests\nimport tomli\n\nTHIS_DIR = Path(__file__).parent\n\nsession = requests.Session()\n\n\ndef update_lib(lib, *, retry=0):\n    repo = lib['repo']\n..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generate_schema.py", "score": 0.24875810742378235, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def get_ref(s: CoreSchema) -> str:\n            return s['ref']  # type: ignore\n\n        if schema['type'] == 'definitions':\n            self.defs.definitions.update({get_ref(s): s for s i..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_generate_schema.py", "score": 0.2487187385559082, "span_start": null, "span_end": null, "passage": "import AliasChoices, AliasPath\n        from ..fields import FieldInfo\n\n        if has_instance_in_type(field_info.annotation, (ForwardRef, str)):\n            types_namespace = self._types_namespace\n  ..."}, {"qid": "", "rank": 20, "path": "pydantic/json_schema.py", "score": 0.248127281665802, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema = {'type': 'string', 'format': 'base64url' if self._config.ser_json_bytes == 'base64' else 'binary'}\n        self.update_with_validations(json_schema, schema, self.ValidationsM..."}], "latency_ms": 4.340887069702148, "gold_paths": ["release/make_history.py"]}
{"qid": "lens_main_func_45813eb7", "query": "Fix type hint on `IpvAnyAddress` (#9640)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_validators.py", "score": 0.43710261583328247, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport math\nimport re\nimport typing\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.43113255500793457, "span_start": null, "span_end": null, "passage": "Unlike `typing.get_type_hints`, this function will not error if a forward reference is not resolvable"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.42679256200790405, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport collections\nimport collections.abc\nimport dataclasses\nimport decimal\nimport inspect\nimport os\nimport typing\nfrom enum import Enum\nfrom f..."}, {"qid": "", "rank": 4, "path": "tests/test_networks_ipaddress.py", "score": 0.419460654258728, "span_start": null, "span_end": null, "passage": "import json\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom typing import Any, List\n\nimport pytest\n\nfrom pydantic import BaseModel, IPvAnyAd..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/networks.py", "score": 0.4181429147720337, "span_start": null, "span_end": null, "passage": "# Define your own class if you want to specify network address check strictness try:\n            return IPv4Network(value)\n        except ValueError:\n            pass\n\n        try:\n            return ..."}, {"qid": "", "rank": 6, "path": "pydantic/deprecated/json.py", "score": 0.40387266874313354, "span_start": null, "span_end": null, "passage": "import datetime\nimport warnings\nfrom collections import deque\nfrom decimal import Decimal\nfrom enum import Enum\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interfac..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/networks.py", "score": 0.3999054431915283, "span_start": null, "span_end": null, "passage": "import re\nfrom ipaddress import (\n    IPv4Address,\n    IPv4Interface,\n    IPv4Network,\n    IPv6Address,\n    IPv6Interface,\n    IPv6Network,\n    _BaseAddress,\n    _BaseNetwork,\n)\nfrom typing import (\n ..."}, {"qid": "", "rank": 8, "path": "pydantic/networks.py", "score": 0.3954388499259949, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel\n    from pydantic.networks import IPvAnyAddress\n\n    class IpModel(BaseModel):\n        ip: IPvAnyAddress\n\n    print(IpModel(ip='127.0.0.1'))\n    #> ip=IPv4Addr..."}, {"qid": "", "rank": 9, "path": "pydantic/networks.py", "score": 0.39324986934661865, "span_start": null, "span_end": null, "passage": "# Define your own class if you want to specify network address check strictness"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_typing_extra.py", "score": 0.37539705634117126, "span_start": null, "span_end": null, "passage": "Before Python 3.10,\n                    # get_type_hints only evaluated the globalns of\n                    # a class To maintain backwards compatibility, we reverse\n                    # the globalns..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_validators.py", "score": 0.37533512711524963, "span_start": null, "span_end": null, "passage": "See more:\n    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network\n    \"\"\"\n    if isinstance(input_value, IPv4Network):\n        return input_value\n\n    try:\n        return IPv4Network(..."}, {"qid": "", "rank": 12, "path": "docs/plugins/conversion_table.py", "score": 0.37499886751174927, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nimport collections\nimport typing\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom datetime import date, datetime, time, timedelt..."}, {"qid": "", "rank": 13, "path": "pydantic/config.py", "score": 0.3715181052684784, "span_start": null, "span_end": null, "passage": "Although the configuration can be set using the `__pydantic_config__` attribute, it does not play well with type checkers,\n    especially with `TypedDict` !!"}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.3652850389480591, "span_start": null, "span_end": null, "passage": "warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.f..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/schema.py", "score": 0.3599053621292114, "span_start": null, "span_end": null, "passage": "import re\nimport warnings\nfrom collections import defaultdict\nfrom dataclasses import is_dataclass\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import Decimal\nfrom enum import Enu..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_typing_extra.py", "score": 0.357706218957901, "span_start": null, "span_end": null, "passage": "* prefixing `typing.` where appropriate\n        * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument https://github.com/python/cpython/blob/aaaf5174241496afca7ce4..."}, {"qid": "", "rank": 17, "path": "pydantic/type_adapter.py", "score": 0.35331082344055176, "span_start": null, "span_end": null, "passage": "As a workaround, you can explicitly\n            annotate your variable:\n\n            ```py\n            from typing import Union\n\n            from pydantic import TypeAdapter\n\n            ta: TypeAdapt..."}, {"qid": "", "rank": 18, "path": "pydantic/fields.py", "score": 0.35312420129776, "span_start": null, "span_end": null, "passage": "warning Deprecated\n                The `extra` kwargs is deprecated Use `json_schema_extra` instead Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo] The return annotation is `Any` so `F..."}, {"qid": "", "rank": 19, "path": "pydantic/networks.py", "score": 0.347678542137146, "span_start": null, "span_end": null, "passage": "\"\"\"The networks module contains types for common network-related fields.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses as _dataclasses\nimport re\nfrom importlib.metadata im..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/class_validators.py", "score": 0.34526270627975464, "span_start": null, "span_end": null, "passage": "import warnings\nfrom collections import ChainMap\nfrom functools import partial, partialmethod, wraps\nfrom itertools import chain\nfrom types import FunctionType\nfrom typing import TYPE_CHECKING, Any, C..."}], "latency_ms": 4.538536071777344, "gold_paths": ["pydantic/networks.py"]}
{"qid": "lens_main_func_13dc7c34", "query": "Fix annotation application logic (#9623)", "results": [{"qid": "", "rank": 1, "path": "pydantic/functional_validators.py", "score": 0.5815118551254272, "span_start": null, "span_end": null, "passage": "Therefore, when used, this annotation should generally be the final\n        annotation applied to a type"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.5506478548049927, "span_start": null, "span_end": null, "passage": "Args:\n        annotations: An iterable of annotations Returns:\n        An iterable of expanded annotations"}, {"qid": "", "rank": 3, "path": "pydantic/fields.py", "score": 0.49790483713150024, "span_start": null, "span_end": null, "passage": "\"\"\"\n        annotation = _typing_extra.eval_type_lenient(self.annotation, types_namespace)\n        self.annotation = _generics.replace_types(annotation, typevars_map)\n\n    def __repr_args__(self) -> R..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/fields.py", "score": 0.4974432587623596, "span_start": null, "span_end": null, "passage": "The FieldInfo may be set in typing.Annotated or the value, but not both If neither contain\n        a FieldInfo, a new one will be created using the config"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_typing_extra.py", "score": 0.4764593541622162, "span_start": null, "span_end": null, "passage": "This is often the same as obj.__annotations__, but it handles\n        forward references encoded as string literals, adds Optional[t] if a\n        default value equal to None is set and recursively re..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.473476767539978, "span_start": null, "span_end": null, "passage": "Args:\n        annotations: An iterable of annotations Returns:\n        A tuple contains a dict of known metadata and a list of unknown annotations"}, {"qid": "", "rank": 7, "path": "pydantic/fields.py", "score": 0.47306692600250244, "span_start": null, "span_end": null, "passage": "'\n                \"Make sure you don't have any field name clashing with a type annotation \",\n                code='unevaluable-type-annotation',\n            )\n\n        final = False\n        if _typin..."}, {"qid": "", "rank": 8, "path": "tests/test_json_schema.py", "score": 0.47061097621917725, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4691387414932251, "span_start": null, "span_end": null, "passage": "field_info.metadata = [*new_field_info.metadata, *field_info.metadata]\n\n        source_type, annotations = field_info.annotation, field_info.metadata\n\n        def set_discriminator(schema: CoreSchema)..."}, {"qid": "", "rank": 10, "path": "tests/test_dataclasses.py", "score": 0.46737873554229736, "span_start": null, "span_end": null, "passage": "That said, if you mix them like this, there is a good chance you'll run into surprising behavior/bugs (E.g., `x: Annotated[int, Field(gt=1, validate_default=True)] = field(default=0)` doesn't cause an..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generate_schema.py", "score": 0.46726906299591064, "span_start": null, "span_end": null, "passage": "`Annotated[int, Field(...)]` or `Annotated[int, Gt(0)]`.\"\"\"\n        from ..fields import FieldInfo\n\n        source_type, *annotations = self._get_args_resolving_forward_refs(\n            annotated_typ..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_model_construction.py", "score": 0.46510061621665955, "span_start": null, "span_end": null, "passage": "All model fields require a '\n                    f'type annotation; if `{var_name}` is not meant to be a field, you may be able to resolve this '\n                    f\"error by annotating it as a `Cla..."}, {"qid": "", "rank": 13, "path": "pydantic/functional_validators.py", "score": 0.46254295110702515, "span_start": null, "span_end": null, "passage": "You can also use `SkipValidation[int]` as a shorthand for `Annotated[int, SkipValidation]` This can be useful if you want to use a type annotation for documentation/IDE/type-checking purposes,\n       ..."}, {"qid": "", "rank": 14, "path": "pydantic/fields.py", "score": 0.45902031660079956, "span_start": null, "span_end": null, "passage": "Args:\n            annotation: The type hint annotation for which metadata has to be extracted Returns:\n            A tuple containing the extracted metadata type and the list of extra arguments"}, {"qid": "", "rank": 15, "path": "pydantic/fields.py", "score": 0.45827823877334595, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.default is PydanticUndefined and self.default_factory is None\n\n    def rebuild_annotation(self) -> Any:\n        \"\"\"Attempts to rebuild the original annotation for use in functi..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.45820510387420654, "span_start": null, "span_end": null, "passage": "\"\"\"\n    import annotated_types as at\n\n    from"}, {"qid": "", "rank": 17, "path": "pydantic/v1/schema.py", "score": 0.45734256505966187, "span_start": null, "span_end": null, "passage": ":param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/schema.py", "score": 0.45550745725631714, "span_start": null, "span_end": null, "passage": ":param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n..."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.45159029960632324, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not self.metadata:\n            return self.annotation\n        else:\n            # Annotated arguments must be a tuple\n            return typing_extensions.Annotated[(self.annotation, *s..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_signature.py", "score": 0.4502525329589844, "span_start": null, "span_end": null, "passage": "Args:\n        param (Parameter): The parameter\n\n    Returns:\n        Parameter: The custom processed parameter\n    \"\"\"\n    from ..fields import FieldInfo\n\n    param_default = param.default\n    if isin..."}], "latency_ms": 3.943920135498047, "gold_paths": ["pydantic/_internal/_generate_schema.py", "pydantic/_internal/_known_annotated_metadata.py", "tests/test_types.py"]}
{"qid": "lens_main_func_d93a0460", "query": "Add TLD not required corrections to docs (#9620)", "results": [{"qid": "", "rank": 1, "path": "pydantic/errors.py", "score": 0.4038318693637848, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version imp..."}, {"qid": "", "rank": 2, "path": "pydantic/networks.py", "score": 0.38663560152053833, "span_start": null, "span_end": null, "passage": "Without having an exhaustive list of TLDs, it would be impossible to differentiate between these two Therefore\n    underscores are allowed, but you can always do further validation in a validator if d..."}, {"qid": "", "rank": 3, "path": "pydantic/networks.py", "score": 0.3670092225074768, "span_start": null, "span_end": null, "passage": "warning \"Underscores in Hostnames\"\n    In Pydantic, underscores are allowed in all parts of a domain except the TLD Technically this might be wrong - in theory the hostname cannot have underscores, bu..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.36622318625450134, "span_start": null, "span_end": null, "passage": "# However, it still may make sense to apply the discriminator to this schema,\n            # as a way to get discriminated-union-style error messages, so we allow this here"}, {"qid": "", "rank": 5, "path": "tests/test_dataclasses.py", "score": 0.35051241517066956, "span_start": null, "span_end": null, "passage": "This is essentially a limitation of typing._GenericAlias"}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.34770268201828003, "span_start": null, "span_end": null, "passage": "During this recursion, we allow references to be resolved from the definitions\n    # that are originally present on the original, outermost `schema` Before `apply_discriminators` is called,\n    # `sim..."}, {"qid": "", "rank": 7, "path": "pydantic/networks.py", "score": 0.3457629084587097, "span_start": null, "span_end": null, "passage": "* TLD not required\n* Host required\n\"\"\"\nWebsocketUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['ws', 'wss'])]\n\"\"\"A type that will accept any ws or wss URL * TLD not required\n* H..."}, {"qid": "", "rank": 8, "path": "tests/check_usage_docs.py", "score": 0.34086287021636963, "span_start": null, "span_end": null, "passage": "\"\"\"\nCheck that all `Usage docs` tags in docstrings link to the latest version of pydantic"}, {"qid": "", "rank": 9, "path": "pydantic/errors.py", "score": 0.3393225073814392, "span_start": null, "span_end": null, "passage": "DEV_ERROR_DOCS_URL = f'https://errors.pydantic.dev/{version_short()}/u/'\nPydanticErrorCodes = Literal[\n    'class-not-fully-defined',\n    'custom-json-schema',\n    'decorator-missing-field',\n    'disc..."}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.3326171338558197, "span_start": null, "span_end": null, "passage": "* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host required\n\nAssuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export t..."}, {"qid": "", "rank": 11, "path": "pydantic/fields.py", "score": 0.32490667700767517, "span_start": null, "span_end": null, "passage": "To avoid this error message, add `# type: ignore[misc]` to the `@computed_field` line [pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error"}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.320292592048645, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # reminder: dicts are ordered and replacement does not alter the order\n        res = DecoratorInfos()\n        for base in reversed(mro(model_dc)[1:]):\n            existing: DecoratorInfos ..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_core_utils.py", "score": 0.31833210587501526, "span_start": null, "span_end": null, "passage": "\"\"\"\nHAS_INVALID_SCHEMAS_METADATA_KEY = 'pydantic.internal.invalid'\n\"\"\"Used to mark a schema that is invalid because it refers to a definition that was not yet defined when the\nschema was first encount..."}, {"qid": "", "rank": 14, "path": "pydantic/config.py", "score": 0.3142926096916199, "span_start": null, "span_end": null, "passage": "By specifying a `json_schema_mode_override` though, this prevents the conflict between\n    the validation and serialization schemas (since both will use the specified schema), and so prevents the suff..."}, {"qid": "", "rank": 15, "path": "pydantic/dataclasses.py", "score": 0.30896568298339844, "span_start": null, "span_end": null, "passage": "This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails This is analogous to `B..."}, {"qid": "", "rank": 16, "path": "pydantic/plugin/__init__.py", "score": 0.30770713090896606, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Callable, NamedTuple\n\nfrom pydantic_core import CoreConfig, CoreSchema, ValidationError\nfrom typing_extensions import Literal, Protocol..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/env_settings.py", "score": 0.307477742433548, "span_start": null, "span_end": null, "passage": "'\n                        'Instead use the \"env\" field setting"}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.3071475625038147, "span_start": null, "span_end": null, "passage": "# In this case, we do the same thing we do in\n            # `pydantic._internal._discriminated_union._ApplyInferredDiscriminator._apply_to_root`, namely,\n            # package the generated schema bac..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3056509494781494, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The input schema Returns:\n            The new core schema Raises:\n            TypeError:\n                - If `discriminator` is used with invalid union variant - If `discrim..."}, {"qid": "", "rank": 20, "path": "pydantic/fields.py", "score": 0.3046855926513672, "span_start": null, "span_end": null, "passage": "warning Deprecated\n                The `extra` kwargs is deprecated Use `json_schema_extra` instead Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo] The return annotation is `Any` so `F..."}], "latency_ms": 4.29081916809082, "gold_paths": ["pydantic/networks.py"]}
{"qid": "lens_main_func_8333bd59", "query": "Fix bug with mypy plugin's handling of covariant typevar fields (#9606)", "results": [{"qid": "", "rank": 1, "path": "tests/mypy/outputs/1.1.1/pyproject-default_toml/fail2.py", "score": 0.5935779809951782, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types"}, {"qid": "", "rank": 2, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/fail2.py", "score": 0.5935779809951782, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types"}, {"qid": "", "rank": 3, "path": "pydantic/mypy.py", "score": 0.5670408010482788, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self.type is not None:\n            with state.strict_optional_set(api.options.strict_optional):\n                self.type = map_type_from_supertype(self.type, sub_type, self.info)\n\n\ncla..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/mypy.py", "score": 0.5503687858581543, "span_start": null, "span_end": null, "passage": "if isinstance(tvd, TypeVarType):\n            self_type = tvd\n        else:\n            self_type = TypeVarType(tvd)\n\n        add_method(\n            ctx,\n            'construct',\n            construct..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/mypy.py", "score": 0.5421760678291321, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self.plugin_config.debug_dataclass_transform:\n            return\n        info_metaclass = ctx.cls.info.declared_metaclass\n        assert info_metaclass, \"callback not passed from 'get_m..."}, {"qid": "", "rank": 6, "path": "pydantic/main.py", "score": 0.5399582982063293, "span_start": null, "span_end": null, "passage": "ModelT = TypeVar('ModelT', bound='BaseModel')\nTupleGenerator = Generator[Tuple[str, Any], None, None]\n# should be `set[int] | set[str] | dict[int, IncEx] | dict[str, IncEx] | None`, but mypy can't cop..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_dataclasses.py", "score": 0.5334203243255615, "span_start": null, "span_end": null, "passage": "\"\"\"\n    typevars_map = get_standard_typevars_map(cls)\n    fields = collect_dataclass_fields(cls, types_namespace, typevars_map=typevars_map, config_wrapper=config_wrapper)\n\n    cls.__pydantic_fields__..."}, {"qid": "", "rank": 8, "path": "pydantic/mypy.py", "score": 0.525200366973877, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self.plugin_config.debug_dataclass_transform:\n            return\n        info_metaclass = ctx.cls.info.declared_metaclass\n        assert info_metaclass, \"callback not passed from 'get_m..."}, {"qid": "", "rank": 9, "path": "tests/mypy/modules/fail3.py", "score": 0.521076500415802, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types \"\"\"\nfrom typing import Generic, List, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass Model(BaseModel):\n    list_of_ints: List[int]\n\n\nclass W..."}, {"qid": "", "rank": 10, "path": "pydantic/types.py", "score": 0.5195090174674988, "span_start": null, "span_end": null, "passage": "warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.f..."}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.5150303840637207, "span_start": null, "span_end": null, "passage": "from mypy.types import TypeVarType as TypeVarDef\n\nCONFIGFILE_KEY = 'pydantic-mypy'\nMETADATA_KEY = 'pydantic-mypy-metadata'\nBASEMODEL_FULLNAME = 'pydantic.main.BaseModel'\nBASESETTINGS_FULLNAME = 'pydan..."}, {"qid": "", "rank": 12, "path": "tests/test_titles.py", "score": 0.5126508474349976, "span_start": null, "span_end": null, "passage": "import re\nimport typing\nfrom typing import Any, Callable, List\n\nimport pytest\nimport typing_extensions\n\nimport pydantic\nfrom pydantic import BaseModel, ConfigDict, Field, TypeAdapter, computed_field\nf..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.5074295997619629, "span_start": null, "span_end": null, "passage": "warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.f..."}, {"qid": "", "rank": 14, "path": "pydantic/mypy.py", "score": 0.5067736506462097, "span_start": null, "span_end": null, "passage": "self._api.add_plugin_dependency(make_wildcard_trigger(info.fullname))\n\n            for name, data in info.metadata[METADATA_KEY]['fields'].items():\n                field = PydanticModelField.deseriali..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_fields.py", "score": 0.5057689547538757, "span_start": null, "span_end": null, "passage": "To avoid false positives in the NameError check above\n            try:\n                delattr(cls, ann_name)\n            except AttributeError:\n                pass  # indicates the attribute was on ..."}, {"qid": "", "rank": 16, "path": "pydantic/mypy.py", "score": 0.5019033551216125, "span_start": null, "span_end": null, "passage": "\"\"\"\n        info = self._cls.info\n        arguments = [\n            field.to_argument(\n                info,\n                typed=typed,\n                force_optional=requires_dynamic_aliases or is_..."}, {"qid": "", "rank": 17, "path": "pydantic/mypy.py", "score": 0.49511218070983887, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if '__init__' in self._cls.info.names and not self._cls.info.names['__init__'].plugin_generated:\n            return  # Don't generate an __init__ if one already exists\n\n        typed = sel..."}, {"qid": "", "rank": 18, "path": "pydantic/fields.py", "score": 0.49397188425064087, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not self.metadata:\n            return self.annotation\n        else:\n            # Annotated arguments must be a tuple\n            return typing_extensions.Annotated[(self.annotation, *s..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/typing.py", "score": 0.49380797147750854, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if type(tp).__name__ in AnnotatedTypeNames:\n            return cast(Type[Any], Annotated)  # mypy complains about _SpecialForm\n        return _typing_get_origin(tp) or getattr(tp, '__origi..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/mypy.py", "score": 0.49311065673828125, "span_start": null, "span_end": null, "passage": "This can be dropped if/when https://github.com/python/mypy/issues/7301 is merged\n    \"\"\"\n    info = ctx.cls.info\n\n    # First remove any previously generated methods with the same name\n    # to avoid ..."}], "latency_ms": 5.008697509765625, "gold_paths": ["pydantic/mypy.py", "tests/mypy/modules/covariant_typevar.py", "tests/mypy/test_mypy.py"]}
{"qid": "lens_main_func_8fef5629", "query": "Add fallback default value for private fields in __setstate__ of BaseModel (#9584)", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/main.py", "score": 0.5302586555480957, "span_start": null, "span_end": null, "passage": "\"_{var_name}\" or \"__{var_name}__\"'\n                        )\n                    private_attributes[var_name] = value\n                elif config.underscore_attrs_are_private and is_valid_private_name..."}, {"qid": "", "rank": 2, "path": "pydantic/fields.py", "score": 0.5179901719093323, "span_start": null, "span_end": null, "passage": "!! warning\n        You generally shouldn't be creating `ModelPrivateAttr` instances directly, instead use\n        `pydantic.fields.PrivateAttr` (This is similar to `FieldInfo` vs `Field`.)\n\n    Attrib..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/schema.py", "score": 0.5124205946922302, "span_start": null, "span_end": null, "passage": "# The behaviour is the same as `BaseModel` reference, where the default title\n    # is in the definitions part of the schema"}, {"qid": "", "rank": 4, "path": "pydantic/main.py", "score": 0.5073663592338562, "span_start": null, "span_end": null, "passage": "__pydantic_fields_set__: An instance attribute with the names of fields explicitly set __pydantic_private__: Instance attribute with the values of private attributes set on the model instance \"\"\"\n\n   ..."}, {"qid": "", "rank": 5, "path": "tests/test_private_attributes.py", "score": 0.505790650844574, "span_start": null, "span_end": null, "passage": "\"\n            'If you want to set a value on the class, use `Model._bar = value`.'\n        ),\n    ):\n        m._bar = 1\n\n\ndef test_private_attribute_intersection_with_extra_field():\n    class Model(Ba..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/fields.py", "score": 0.5001705884933472, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if default is not Undefined and default_factory is not None:\n        raise ValueError('cannot specify both default and default_factory')\n\n    return ModelPrivateAttr(\n        default,\n        ..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/mypy.py", "score": 0.485533207654953, "span_start": null, "span_end": null, "passage": "\"\"\"\n        expr = stmt.rvalue\n        if isinstance(expr, TempNode):\n            # TempNode means annotation-only, so only non-required if Optional\n            value_type = get_proper_type(cls.info[l..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/main.py", "score": 0.4824967384338379, "span_start": null, "span_end": null, "passage": "with `root_validator`)\n            object_setattr(self, '__dict__', new_values)\n        else:\n            self.__dict__[name] = value\n\n        self.__fields_set__.add(name)\n\n    def __getstate__(self)..."}, {"qid": "", "rank": 9, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.4805671274662018, "span_start": null, "span_end": null, "passage": "# Not required\n    f: Optional[int]\n    g: int = 1\n    h: int = Field(1)\n    i: int = Field(None)\n    j = 1\n\n\nDefaultTestingModel()\n\n\nclass UndefinedAnnotationModel(BaseModel):\n    undefined: Undefine..."}, {"qid": "", "rank": 10, "path": "tests/mypy/modules/plugin_fail.py", "score": 0.4805671274662018, "span_start": null, "span_end": null, "passage": "# Not required\n    f: Optional[int]\n    g: int = 1\n    h: int = Field(1)\n    i: int = Field(None)\n    j = 1\n\n\nDefaultTestingModel()\n\n\nclass UndefinedAnnotationModel(BaseModel):\n    undefined: Undefine..."}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.47406113147735596, "span_start": null, "span_end": null, "passage": "return False\n        for field in fields:\n            if field.type is None:\n                return False\n\n        is_settings = any(base.fullname == BASESETTINGS_FULLNAME for base in info.mro[:-1])\n ..."}, {"qid": "", "rank": 12, "path": "pydantic/fields.py", "score": 0.47197651863098145, "span_start": null, "span_end": null, "passage": "Private attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner Private attributes are stored in `__private_attributes__` on the model Args:\n        d..."}, {"qid": "", "rank": 13, "path": "pydantic/fields.py", "score": 0.46703147888183594, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if default is not PydanticUndefined and default_factory is not None:\n        raise TypeError('cannot specify both default and default_factory')\n\n    return ModelPrivateAttr(\n        default,\n ..."}, {"qid": "", "rank": 14, "path": "tests/test_edge_cases.py", "score": 0.46290338039398193, "span_start": null, "span_end": null, "passage": "\"\n            'All field definitions, including overrides, require a type annotation.'\n        ),\n    ):\n\n        class Bar(Foo):\n            x: float = 12.3\n            a = 123.0\n\n    class Bar2(Foo)..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/mypy.py", "score": 0.46197089552879333, "span_start": null, "span_end": null, "passage": "if name is None or name == 'default':\n                    return arg.__class__ is EllipsisExpr\n                if name == 'default_factory':\n                    return False\n            # In this case..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/mypy.py", "score": 0.45593398809432983, "span_start": null, "span_end": null, "passage": "In particular:\n        * determines the model config and fields,\n        * adds a fields-aware signature for the initializer and construct methods\n        * freezes the class if allow_mutation = False..."}, {"qid": "", "rank": 17, "path": "pydantic/mypy.py", "score": 0.45515453815460205, "span_start": null, "span_end": null, "passage": "\"\"\"\n        set_str = self._api.named_type(f'{BUILTINS_NAME}.set', [self._api.named_type(f'{BUILTINS_NAME}.str')])\n        optional_set_str = UnionType([set_str, NoneType()])\n        fields_set_argume..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_model_construction.py", "score": 0.45404261350631714, "span_start": null, "span_end": null, "passage": "\"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_pos..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_model_construction.py", "score": 0.45370423793792725, "span_start": null, "span_end": null, "passage": "if bases:\n            base_field_names, class_vars, base_private_attributes = mcs._collect_bases_data(bases)\n\n            config_wrapper = ConfigWrapper.for_model(bases, namespace, kwargs)\n           ..."}, {"qid": "", "rank": 20, "path": "pydantic/fields.py", "score": 0.45067909359931946, "span_start": null, "span_end": null, "passage": "Example:\n            This is how you can create a field with default value like this:\n\n            ```python\n            import pydantic\n\n            class MyModel(pydantic.BaseModel):\n               ..."}], "latency_ms": 4.61578369140625, "gold_paths": ["pydantic/main.py"]}
{"qid": "lens_main_func_8a776e1a", "query": "Minor docs update - 2.7 note on `use_attribute_docstrings` (#9577)", "results": [{"qid": "", "rank": 1, "path": "tests/check_usage_docs.py", "score": 0.6506129503250122, "span_start": null, "span_end": null, "passage": "\"\"\"\nCheck that all `Usage docs` tags in docstrings link to the latest version of pydantic"}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.5902785062789917, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    use_attribute_docstrings: bool\n    '''\n    Whether docstrings of attributes (bare string literals immediately following the attribute declaration)\n    should be used for field descriptions De..."}, {"qid": "", "rank": 3, "path": "pydantic/errors.py", "score": 0.5547642111778259, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version imp..."}, {"qid": "", "rank": 4, "path": "pydantic/config.py", "score": 0.5204085111618042, "span_start": null, "span_end": null, "passage": "!! warning \"Usage with `TypedDict`\"\n        Due to current limitations, attribute docstrings detection may not work as expected when using `TypedDict`\n        (in particular when multiple `TypedDict` ..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5040234923362732, "span_start": null, "span_end": null, "passage": "So don't overwrite existing attributes # We skip over \"attributes\" that are present in the metadata_lookup dict because these won't\n                    # actually end up as attributes of the `FieldInf..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_fields.py", "score": 0.4932681620121002, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return _general_metadata_cls()(metadata)  # type: ignore\n\n\n@lru_cache(maxsize=None)\ndef _general_metadata_cls() -> type[BaseMetadata]:\n    \"\"\"Do it this way to avoid importing `annotated_types..."}, {"qid": "", "rank": 7, "path": "docs/plugins/griffe_doclinks.py", "score": 0.48359304666519165, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file}#{slug})\\n'\n\n\ndef update_docstring(obj: GriffeObject) -> str:\n    return re.sub(\n        r'usage[\\- ]docs: ?https://docs\\.pydantic\\.dev/.+?..."}, {"qid": "", "rank": 8, "path": "pydantic/fields.py", "score": 0.4791761636734009, "span_start": null, "span_end": null, "passage": "warning Deprecated\n                The `extra` kwargs is deprecated Use `json_schema_extra` instead Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo] The return annotation is `Any` so `F..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.4765046238899231, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class Model(BaseModel):\n        model_config = ConfigDict(use_attribute_docstrings=True)\n\n        x: str\n        \"\"\"\n        Example o..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_model_construction.py", "score": 0.4752644896507263, "span_start": null, "span_end": null, "passage": "Attributes:\n        msg: The deprecation message to be emitted wrapped_property: The property instance if the deprecated field is a computed field, or `None` field_name: The name of the field being de..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.46468886733055115, "span_start": null, "span_end": null, "passage": "\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nimport inspect\nimport textwrap\nfrom typing import Any\n\n\nclass DocstringVisitor(ast.NodeVisito..."}, {"qid": "", "rank": 12, "path": "tests/test_fields.py", "score": 0.462922066450119, "span_start": null, "span_end": null, "passage": "However, it is possible that this API is still being in use by applications and\n    third-party tools \"\"\"\n    with pytest.raises(TypeError) as e:\n        fields.FieldInfo.from_field(annotation=())\n\n  ..."}, {"qid": "", "rank": 13, "path": "pydantic/fields.py", "score": 0.4557918310165405, "span_start": null, "span_end": null, "passage": "default: The default value of the field Returns:\n            A field object with the passed values \"\"\"\n        if annotation is default:\n            raise PydanticUserError(\n                'Error whe..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_fields.py", "score": 0.45413845777511597, "span_start": null, "span_end": null, "passage": "To avoid false positives in the NameError check above\n            try:\n                delattr(cls, ann_name)\n            except AttributeError:\n                pass  # indicates the attribute was on ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_core_utils.py", "score": 0.45063430070877075, "span_start": null, "span_end": null, "passage": "\"\"\"\nHAS_INVALID_SCHEMAS_METADATA_KEY = 'pydantic.internal.invalid'\n\"\"\"Used to mark a schema that is invalid because it refers to a definition that was not yet defined when the\nschema was first encount..."}, {"qid": "", "rank": 16, "path": "tests/test_type_hints.py", "score": 0.4434294104576111, "span_start": null, "span_end": null, "passage": "pydantic.warnings.PydanticDeprecatedSince20: The `__fields__` attribute is deprecated,\n#      use `model_fields` instead"}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.4374641478061676, "span_start": null, "span_end": null, "passage": "They should be passed in the format:\n            `<name>=(<type>, <default value>)`, `<name>=(<type>, <FieldInfo>)`, or `typing.Annotated[<type>, <FieldInfo>]` Any additional metadata in `typing.Annot..."}, {"qid": "", "rank": 18, "path": "pydantic/main.py", "score": 0.4364166855812073, "span_start": null, "span_end": null, "passage": "# This can happen if a `ValidationError` is raised during initialization and the instance's\n        # repr is generated as part of the exception handling Therefore, we use `getattr` here\n        # wit..."}, {"qid": "", "rank": 19, "path": "pydantic/dataclasses.py", "score": 0.4363895058631897, "span_start": null, "span_end": null, "passage": "if field_value.repr is not True:\n                    field_args['repr'] = field_value.repr\n\n                setattr(cls, field_name, dataclasses.field(**field_args))\n                # In Python 3.8, d..."}, {"qid": "", "rank": 20, "path": "pydantic/fields.py", "score": 0.4333339333534241, "span_start": null, "span_end": null, "passage": "\"\"\"\n        flattened_field_infos: list[FieldInfo] = []\n        for field_info in field_infos:\n            flattened_field_infos.extend(x for x in field_info.metadata if isinstance(x, FieldInfo))\n    ..."}], "latency_ms": 3.9784908294677734, "gold_paths": ["pydantic/config.py"]}
{"qid": "lens_main_func_8a896c51", "query": "Fix typing of `TypeAdapter` (#9570)", "results": [{"qid": "", "rank": 1, "path": "pydantic/type_adapter.py", "score": 0.576324999332428, "span_start": null, "span_end": null, "passage": "A `TypeAdapter` instance exposes some of the functionality from `BaseModel` instance methods\n    for types that do not have such methods (such as dataclasses, primitive types, and more) **Note:** `Typ..."}, {"qid": "", "rank": 2, "path": "pydantic/type_adapter.py", "score": 0.5125703811645508, "span_start": null, "span_end": null, "passage": "module: The module that passes to plugin if provided !! note\n            You cannot use the `config` argument when instantiating a `TypeAdapter` if the type you're using has its own\n            config..."}, {"qid": "", "rank": 3, "path": "pydantic/type_adapter.py", "score": 0.5073471665382385, "span_start": null, "span_end": null, "passage": "For backward compatibility we don't rebuild model mocks\n                # here as part of __init__ even though TypeAdapter itself is not using deferred building"}, {"qid": "", "rank": 4, "path": "pydantic/type_adapter.py", "score": 0.49334973096847534, "span_start": null, "span_end": null, "passage": "As a workaround, you can explicitly\n            annotate your variable:\n\n            ```py\n            from typing import Union\n\n            from pydantic import TypeAdapter\n\n            ta: TypeAdapt..."}, {"qid": "", "rank": 5, "path": "pydantic/type_adapter.py", "score": 0.48854750394821167, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if _type_has_config(type) and config is not None:\n            raise PydanticUserError(\n                'Cannot use `config` when the type is a BaseModel, dataclass or TypedDict.'\n         ..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_repr.py", "score": 0.47699105739593506, "span_start": null, "span_end": null, "passage": "Takes some logic from `typing._type_repr`"}, {"qid": "", "rank": 7, "path": "pydantic/type_adapter.py", "score": 0.4673582911491394, "span_start": null, "span_end": null, "passage": "This is required for _parent_depth used for\n# ForwardRef resolution We may enter the TypeAdapter schema building via different TypeAdapter functions Hence, we\n# need to keep track of the frame depth r..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_model_construction.py", "score": 0.46431979537010193, "span_start": null, "span_end": null, "passage": "# It would be nice to remove this error and still have things behave as expected, it's just\n                            # challenging because we are using a custom `__class_getitem__` to parametrize g..."}, {"qid": "", "rank": 9, "path": "pydantic/type_adapter.py", "score": 0.4631114900112152, "span_start": null, "span_end": null, "passage": "**Note:** By default, `TypeAdapter` does not respect the\n    [`defer_build=True`][pydantic.config.ConfigDict.defer_build] setting in the\n    [`model_config`][pydantic.BaseModel.model_config] or in the..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generics.py", "score": 0.4425388276576996, "span_start": null, "span_end": null, "passage": "Specifically, this works with standard typing generics and typing._GenericAlias"}, {"qid": "", "rank": 11, "path": "tests/test_dataclasses.py", "score": 0.43695440888404846, "span_start": null, "span_end": null, "passage": "This is essentially a limitation of typing._GenericAlias"}, {"qid": "", "rank": 12, "path": "pydantic/type_adapter.py", "score": 0.43639329075813293, "span_start": null, "span_end": null, "passage": "note\n            The `_parent_depth` argument is named with an underscore to suggest its private nature and discourage use It may be deprecated in a minor version, so we only recommend using it if you..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_typing_extra.py", "score": 0.43004274368286133, "span_start": null, "span_end": null, "passage": "\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport re\n..."}, {"qid": "", "rank": 14, "path": "tests/test_deprecated.py", "score": 0.42956721782684326, "span_start": null, "span_end": null, "passage": "Use `pydantic.TypeAdapter.validate_python` instead',\n        '`schema_json_of` is deprecated Use `pydantic.TypeAdapter.json_schema` instead',\n        '`schema_of` is deprecated Use `pydantic.TypeAdapt..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/typing.py", "score": 0.42814332246780396, "span_start": null, "span_end": null, "passage": "import sys\nimport typing\nfrom collections.abc import Callable\nfrom os import PathLike\nfrom typing import (  # type: ignore\n    TYPE_CHECKING,\n    AbstractSet,\n    Any,\n    Callable as TypingCallable,\n..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_utils.py", "score": 0.4168616533279419, "span_start": null, "span_end": null, "passage": "import _repr, _typing_extra\n\nif typing.TYPE_CHECKING:\n    MappingIntStrAny: TypeAlias = 'typing.Mapping[int, Any] | typing.Mapping[str, Any]'\n    AbstractSetIntStr: TypeAlias = 'typing.AbstractSet[int..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_typing_extra.py", "score": 0.4049034118652344, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        if sys.version_info >= (3, 13):\n            return typing._eval_type(  # type: ignore\n                value, globalns, localns, type_params=type_params\n            )\n        else:..."}, {"qid": "", "rank": 18, "path": "pydantic/type_adapter.py", "score": 0.3984983563423157, "span_start": null, "span_end": null, "passage": "def __init__(\n        self,\n        type: Any,\n        *,\n        config: ConfigDict | None = None,\n        _parent_depth: int = 2,\n        module: str | None = None,\n    ) -> None:\n        \"\"\"Initial..."}, {"qid": "", "rank": 19, "path": "pydantic/deprecated/tools.py", "score": 0.38933873176574707, "span_start": null, "span_end": null, "passage": "from __future__ import annotations\n\nimport json\nimport warnings\nfrom typing import TYPE_CHECKING, Any, Callable, Type, TypeVar, Union\n\nfrom typing_extensions import deprecated\n\nfrom ..json_schema impo..."}, {"qid": "", "rank": 20, "path": "tests/mypy/outputs/1.0.1/pyproject-default_toml/fail3.py", "score": 0.3841192424297333, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types \"\"\"\nfrom typing import Generic, List, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass Model(BaseModel):\n    list_of_ints: List[int]\n\n\nclass W..."}], "latency_ms": 3.5660266876220703, "gold_paths": ["pydantic/type_adapter.py"]}
{"qid": "lens_main_func_137d4d83", "query": "Minor refactors for new tests and docs (#9564)", "results": [{"qid": "", "rank": 1, "path": "tests/test_forward_ref.py", "score": 0.4749007225036621, "span_start": null, "span_end": null, "passage": "#   The initial attempt to refactor them into a single parameterized test was not straightforward due to the use of the\n#   `create_module` fixture and the requirement that `from __future__ import ann..."}, {"qid": "", "rank": 2, "path": "tests/test_internal.py", "score": 0.42494040727615356, "span_start": null, "span_end": null, "passage": "\"\"\"\nTests for internal things that are complex enough to warrant their own unit tests"}, {"qid": "", "rank": 3, "path": "tests/test_serialize.py", "score": 0.39636653661727905, "span_start": null, "span_end": null, "passage": "\"\"\"\nNew tests for v2 of serialization logic"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3854294419288635, "span_start": null, "span_end": null, "passage": "During this recursion, we allow references to be resolved from the definitions\n    # that are originally present on the original, outermost `schema` Before `apply_discriminators` is called,\n    # `sim..."}, {"qid": "", "rank": 5, "path": "tests/test_docs_extraction.py", "score": 0.35812142491340637, "span_start": null, "span_end": null, "passage": "d: int = 1\n\n        def dummy_method(self) -> None:\n            \"\"\"Docs for dummy_method that won't be used for d\"\"\"\n\n        e: int = Field(1, description='Real description')\n        \"\"\"Won't be used..."}, {"qid": "", "rank": 6, "path": "tests/test_dataclasses.py", "score": 0.35810014605522156, "span_start": null, "span_end": null, "passage": "while working on one specific test"}, {"qid": "", "rank": 7, "path": "docs/plugins/griffe_doclinks.py", "score": 0.35803937911987305, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file}#{slug})\\n'\n\n\ndef update_docstring(obj: GriffeObject) -> str:\n    return re.sub(\n        r'usage[\\- ]docs: ?https://docs\\.pydantic\\.dev/.+?..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_core_utils.py", "score": 0.3553324341773987, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return s.get('ref', None)\n\n\ndef collect_definitions(schema: core_schema.CoreSchema) -> dict[str, core_schema.CoreSchema]:\n    defs: dict[str, CoreSchema] = {}\n\n    def _record_valid_refs(s: co..."}, {"qid": "", "rank": 9, "path": "tests/test_forward_ref.py", "score": 0.3507390022277832, "span_start": null, "span_end": null, "passage": "assert module.Foobar.__pydantic_complete__ is False\n\n\ndef test_undefined_types_warning_raised_by_usage(create_module):\n    with pytest_raises_user_error_for_undefined_type('Foobar', 'UndefinedType'):\n..."}, {"qid": "", "rank": 10, "path": "tests/test_forward_ref.py", "score": 0.34776511788368225, "span_start": null, "span_end": null, "passage": "type checking approach: (2a) `from __future__ import annotations` vs (2b) `ForwardRef`\n#\n#   The parameter tags \"1a\", \"1b\", \"2a\", and \"2b\" are used in the test names below, to indicate which combinati..."}, {"qid": "", "rank": 11, "path": "tests/test_validate_call.py", "score": 0.3431447744369507, "span_start": null, "span_end": null, "passage": "def __repr__(self) -> str:\n            assert False\n\n    Class(50)\n\n\ndef test_methods_are_not_rebound():\n    class Thing:\n        def __init__(self, x: int):\n            self.x = x\n\n        def a(self..."}, {"qid": "", "rank": 12, "path": "tests/test_fastapi_json_schema.py", "score": 0.33841729164123535, "span_start": null, "span_end": null, "passage": "\"\"\"\nThis file contains an initial proposal that can be scrapped and reworked if/when appropriate Either way, this test file should probably be removed once the actual FastAPI implementation\nis complet..."}, {"qid": "", "rank": 13, "path": "docs/plugins/main.py", "score": 0.33667707443237305, "span_start": null, "span_end": null, "passage": "https://youtrack.jetbrains.com/issue/IDEA-297873 & https://python-markdown.github.io/extensions/fenced_code_blocks/\n    \"\"\"\n\n    def remove_attrs(match: re.Match[str]) -> str:\n        suffix = re.sub(..."}, {"qid": "", "rank": 14, "path": "tests/test_docs_extraction.py", "score": 0.3344869017601013, "span_start": null, "span_end": null, "passage": "d: int\n\n        def dummy_method(self) -> None:\n            \"\"\"Docs for dummy that won't be used for d\"\"\"\n\n        e: Annotated[int, Field(description='Real description')]\n        \"\"\"Won't be used\"\"\"\n..."}, {"qid": "", "rank": 15, "path": "tests/mypy/outputs/1.0.1/pyproject-default_toml/success.py", "score": 0.32739707827568054, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest pydantic's compliance with mypy Do a little skipping about with types to demonstrate its usage"}, {"qid": "", "rank": 16, "path": "tests/mypy/outputs/1.0.1/mypy-default_ini/success.py", "score": 0.32739707827568054, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest pydantic's compliance with mypy Do a little skipping about with types to demonstrate its usage"}, {"qid": "", "rank": 17, "path": "tests/mypy/modules/success.py", "score": 0.32739707827568054, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest pydantic's compliance with mypy Do a little skipping about with types to demonstrate its usage"}, {"qid": "", "rank": 18, "path": "tests/test_types.py", "score": 0.3261452615261078, "span_start": null, "span_end": null, "passage": "assert f.password.__class__.__name__ == 'SecretStr'\n    assert f.empty_password.__class__.__name__ == 'SecretStr'\n\n    # Assert str and repr are correct"}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.32529979944229126, "span_start": null, "span_end": null, "passage": "copied_definitions = deepcopy(definitions)\n        definitions_schema = {'$defs': copied_definitions}\n        for _iter in range(100):  # prevent an infinite loop in the case of a bug, 100 iterations ..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_core_utils.py", "score": 0.3246898055076599, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return f(schema.copy(), _dispatch)\n\n\ndef simplify_schema_references(schema: core_schema.CoreSchema) -> core_schema.CoreSchema:  # noqa: C901\n    definitions: dict[str, core_schema.CoreSchema] ..."}], "latency_ms": 3.6013126373291016, "gold_paths": ["tests/test_annotated.py", "tests/test_examples.py", "tests/test_utils.py"]}
{"qid": "lens_main_func_f48d03e1", "query": "Add testing coverage for pretty_print (#9469)", "results": [{"qid": "", "rank": 1, "path": "tests/test_utils.py", "score": 0.5104674100875854, "span_start": null, "span_end": null, "passage": "Given varied output, this test verifies that the content of the output is as expected,\n    Rather than doing robust formatting testing"}, {"qid": "", "rank": 2, "path": "tests/test_utils.py", "score": 0.4943721890449524, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # This can break the test by adding color to the output streams\n    monkeypatch.delenv('FORCE_COLOR', raising=False)\n\n    pretty_print_core_schema(schema=schema, include_metadata=include_metad..."}, {"qid": "", "rank": 3, "path": "pydantic/mypy.py", "score": 0.48476219177246094, "span_start": null, "span_end": null, "passage": "\"\"\"\n        info = self._cls.info\n        for field in fields:\n            sym_node = info.names.get(field.name)\n            if sym_node is not None:\n                var = sym_node.node\n              ..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_repr.py", "score": 0.45524632930755615, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n\nclass Representation:\n    # Mixin to provide `__str__`, `__repr__`, and `__pretty__` and `__rich_repr__` methods # `__pretty__` is used b..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/generics.py", "score": 0.4493611454963684, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    for key, field in created_model.__fields__.items():\n        if key not in fields:\n            assert field.type_.__class__ is not DeferredType\n            # https://github.com/nedbat/coverage..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/mypy.py", "score": 0.433695912361145, "span_start": null, "span_end": null, "passage": "\"\"\"\n        ctx = self._ctx\n        info = ctx.cls.info\n        for field in fields:\n            sym_node = info.names.get(field.name)\n            if sym_node is not None:\n                var = sym_no..."}, {"qid": "", "rank": 7, "path": "tests/test_types.py", "score": 0.3989625871181488, "span_start": null, "span_end": null, "passage": "assert f.password.__class__.__name__ == 'SecretStr'\n    assert f.empty_password.__class__.__name__ == 'SecretStr'\n\n    # Assert str and repr are correct"}, {"qid": "", "rank": 8, "path": "pydantic/v1/mypy.py", "score": 0.3916096091270447, "span_start": null, "span_end": null, "passage": "\"\"\"\n    fn = x.fullname\n    if callable(fn):  # pragma: no cover\n        return fn()\n    return fn\n\n\ndef get_name(x: Union[FuncBase, SymbolNode]) -> str:\n    \"\"\"\n    Used for compatibility with mypy 0..."}, {"qid": "", "rank": 9, "path": "tests/mypy/outputs/1.1.1/pyproject-default_toml/fail2.py", "score": 0.385980486869812, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types"}, {"qid": "", "rank": 10, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/fail2.py", "score": 0.385980486869812, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types"}, {"qid": "", "rank": 11, "path": "pydantic/v1/utils.py", "score": 0.3850547671318054, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        eval('__IPYTHON__')\n    except NameError:\n        return False\n    else:  # pragma: no cover\n        return True\n\n\ndef is_valid_identifier(identifier: str) -> bool:\n    \"\"\"\n    Ch..."}, {"qid": "", "rank": 12, "path": "tests/test_discriminated_union.py", "score": 0.38205111026763916, "span_start": null, "span_end": null, "passage": "Issue: https://github.com/pydantic/pydantic/issues/9235'\n)\ndef test_discriminated_union_model_dump_with_nested_class():\n    class SomeEnum(str, Enum):\n        CAT = 'cat'\n        DOG = 'dog'\n\n    clas..."}, {"qid": "", "rank": 13, "path": "tests/test_config.py", "score": 0.3808731436729431, "span_start": null, "span_end": null, "passage": "assert len(all_warnings) in [1, 2]\n        expected_warnings = [\n            'Support for class-based `config` is deprecated, use ConfigDict instead',\n        ]\n        if len(all_warnings) == 2:\n    ..."}, {"qid": "", "rank": 14, "path": "tests/test_edge_cases.py", "score": 0.37959426641464233, "span_start": null, "span_end": null, "passage": "m = Model(v=123)\n    assert m.v == 123\n\n    m = Model(v='123')\n    assert m.v == '123'\n\n    m = Model(v=b'foobar')\n    assert m.v == 'foobar'\n\n    m = Model(v=12.0)\n    assert m.v == 12\n\n    with pyte..."}, {"qid": "", "rank": 15, "path": "tests/test_discriminated_union.py", "score": 0.3794516921043396, "span_start": null, "span_end": null, "passage": "core_schema.with_info_wrap_validator_function(lambda x, y, z: x, dog),\n        ]\n    )\n\n    with pytest.raises(\n        TypeError, match=\"'str' is not a valid discriminated union variant; should be a ..."}, {"qid": "", "rank": 16, "path": "pydantic/mypy.py", "score": 0.37340033054351807, "span_start": null, "span_end": null, "passage": "\"\"\"\n    api.fail('Required dynamic aliases disallowed', context, code=ERROR_ALIAS)\n\n\ndef error_unexpected_behavior(\n    detail: str, api: CheckerPluginInterface | SemanticAnalyzerPluginInterface, cont..."}, {"qid": "", "rank": 17, "path": "tests/test_validators.py", "score": 0.3725782036781311, "span_start": null, "span_end": null, "passage": "import contextlib\nimport re\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom datetime import date, datetime\nfrom enum import Enum\nfrom functools import partial, partialmethod\nfrom ..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_mock_val_ser.py", "score": 0.37020981311798096, "span_start": null, "span_end": null, "passage": "Args:\n        cls: The model class to set the mocks on\n        cls_name: Name of the model class, used in error messages\n        undefined_name: Name of the undefined thing, used in error messages\n   ..."}, {"qid": "", "rank": 19, "path": "tests/conftest.py", "score": 0.36884909868240356, "span_start": null, "span_end": null, "passage": "import importlib\nimport inspect\nimport os\nimport re\nimport secrets\nimport subprocess\nimport sys\nimport textwrap\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom types import FunctionTyp..."}, {"qid": "", "rank": 20, "path": "tests/test_fields.py", "score": 0.3687421679496765, "span_start": null, "span_end": null, "passage": "# I'm mostly including this test now to document the behavior\n    class Model(RootModel[int]):\n        root: str\n\n    assert Model.model_validate('abc').root == 'abc'\n    with pytest.raises(Validation..."}], "latency_ms": 3.626108169555664, "gold_paths": ["tests/test_utils.py"]}
{"qid": "lens_main_func_fc87631f", "query": "Updates type signature for Field() constructor (#9484)", "results": [{"qid": "", "rank": 1, "path": "pydantic/functional_serializers.py", "score": 0.5187151432037354, "span_start": null, "span_end": null, "passage": "Four signatures are supported:\n\n    - `(self, value: Any, info: FieldSerializationInfo)`\n    - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`\n    - `(value: Any..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_signature.py", "score": 0.49998360872268677, "span_start": null, "span_end": null, "passage": "from __future__ import annotations\n\nimport dataclasses\nfrom inspect import Parameter, Signature, signature\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import PydanticUndefined\n..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_decorators.py", "score": 0.47744953632354736, "span_start": null, "span_end": null, "passage": "An error is raised if the function has an invalid signature Args:\n        serializer: The serializer function to inspect mode: The serializer mode, either 'plain' or 'wrap' computed_field: When serial..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/types.py", "score": 0.47608429193496704, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        @classmethod\n        def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n            field_schema.update(type='boolean')\n\n        @classmethod\n        def __get_validators__..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/generics.py", "score": 0.4754732847213745, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_dataclasses.py", "score": 0.47451305389404297, "span_start": null, "span_end": null, "passage": "import _config, _decorators, _typing_extra\nfrom ._fields import collect_dataclass_fields\nfrom ._generate_schema import GenerateSchema\nfrom ._generics import get_standard_typevars_map\nfrom ._mock_val_s..."}, {"qid": "", "rank": 7, "path": "pydantic/experimental/pipeline.py", "score": 0.4740296006202698, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if isinstance(tp, EllipsisType):\n            return _Pipeline[_InT, Any](self._steps + (_ValidateAs(_FieldTypeMarker, strict=strict),))\n        return _Pipeline[_InT, _NewOutT](self._steps..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/mypy.py", "score": 0.4734926223754883, "span_start": null, "span_end": null, "passage": "\"\"\"\n        ctx = self._ctx\n        set_str = ctx.api.named_type(f'{BUILTINS_NAME}.set', [ctx.api.named_type(f'{BUILTINS_NAME}.str')])\n        optional_set_str = UnionType([set_str, NoneType()])\n     ..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/main.py", "score": 0.46224352717399597, "span_start": null, "span_end": null, "passage": "ANNOTATED_FIELD_UNTOUCHED_TYPES: Tuple[Any, ...] = (property, type, classmethod, staticmethod)\n# When creating a `BaseModel` instance, we bypass all the methods, properties.."}, {"qid": "", "rank": 10, "path": "pydantic/experimental/pipeline.py", "score": 0.4581339955329895, "span_start": null, "span_end": null, "passage": "That is, the transformation is applied to after the value is parsed to the field's type \"\"\"\n        return _Pipeline[_InT, _NewOutT](self._steps + (_Transform(func),))\n\n    @overload\n    def validate_..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4569268226623535, "span_start": null, "span_end": null, "passage": "import AliasChoices, AliasPath\n        from ..fields import FieldInfo\n\n        if has_instance_in_type(field_info.annotation, (ForwardRef, str)):\n            types_namespace = self._types_namespace\n  ..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_dataclasses.py", "score": 0.4541739821434021, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if hasattr(cls, '__post_init_post_parse__'):\n        warnings.warn(\n            'Support for `__post_init_post_parse__` has been dropped, the method will not be called', DeprecationWarning\n   ..."}, {"qid": "", "rank": 13, "path": "pydantic/mypy.py", "score": 0.45299971103668213, "span_start": null, "span_end": null, "passage": "return False\n        for field in fields:\n            if field.type is None:\n                return False\n\n        is_settings = any(base.fullname == BASESETTINGS_FULLNAME for base in info.mro[:-1])\n ..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generics.py", "score": 0.4503055214881897, "span_start": null, "span_end": null, "passage": "Returns:\n        A new type representing the basic structure of `type_` with all\n        `typevar_map` keys recursively replaced"}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.44819456338882446, "span_start": null, "span_end": null, "passage": "`@computed_field(return_type=int|str)`)',\n                code='model-field-missing-annotation',\n            )\n\n        return_type = replace_types(return_type, self._typevars_map)\n        # Create a ..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/schema.py", "score": 0.4465774893760681, "span_start": null, "span_end": null, "passage": "This function looks through `field_class_to_schema` for a class that matches the given `field_type`,\n    and then modifies the given `schema` with the information from that type"}, {"qid": "", "rank": 17, "path": "pydantic/functional_validators.py", "score": 0.44349998235702515, "span_start": null, "span_end": null, "passage": "_V2Validator = Union[\n        _V2ValidatorClsMethod,\n        _core_schema.WithInfoValidatorFunction,\n        _OnlyValueValidatorClsMethod,\n        _core_schema.NoInfoValidatorFunction,\n    ]\n\n    _V2W..."}, {"qid": "", "rank": 18, "path": "pydantic/functional_validators.py", "score": 0.442087858915329, "span_start": null, "span_end": null, "passage": "usage should be `@validator('<field_name_1>', '<field_name_2>', ...)`\",\n            code='validator-invalid-fields',\n        )\n\n    def dec(\n        f: Callable[..., Any] | staticmethod[Any, Any] | cl..."}, {"qid": "", "rank": 19, "path": "pydantic/fields.py", "score": 0.4403109550476074, "span_start": null, "span_end": null, "passage": "warning \"Overriding with `computed_field`\"\n        You can't override a field from a parent class with a `computed_field` in the child class `mypy` complains about this behavior if allowed, and `datac..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_typing_extra.py", "score": 0.43919771909713745, "span_start": null, "span_end": null, "passage": "It can be either a `typing.NamedTuple` or `collections.namedtuple` \"\"\"\n    from ._utils import lenient_issubclass\n\n    return lenient_issubclass(type_, tuple) and hasattr(type_, '_fields')\n\n\ntest_new_..."}], "latency_ms": 3.60107421875, "gold_paths": ["pydantic/fields.py"]}
{"qid": "lens_main_func_e874535a", "query": "Fixed type hint of validation context (#9508)", "results": [{"qid": "", "rank": 1, "path": "pydantic/type_adapter.py", "score": 0.6076779365539551, "span_start": null, "span_end": null, "passage": "context: Additional context to pass to the validator Returns:\n            The default value wrapped in a `Some` if there is one or None if not"}, {"qid": "", "rank": 2, "path": "pydantic/plugin/__init__.py", "score": 0.5717647671699524, "span_start": null, "span_end": null, "passage": "strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators \"\"\"\n        pass"}, {"qid": "", "rank": 3, "path": "pydantic/main.py", "score": 0.5644443035125732, "span_start": null, "span_end": null, "passage": "# This can happen if a `ValidationError` is raised during initialization and the instance's\n        # repr is generated as part of the exception handling Therefore, we use `getattr` here\n        # wit..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.5630815029144287, "span_start": null, "span_end": null, "passage": "def make_v1_generic_root_validator(\n    validator: V1RootValidatorFunction, pre: bool\n) -> V2CoreBeforeRootValidator | V2CoreAfterRootValidator:\n    \"\"\"Wrap a V1 style root validator for V2 compatibil..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5367640852928162, "span_start": null, "span_end": null, "passage": "This serves as an auxiliary function for re-implementing that logic, by looping over a provided\n    collection of (v1-style) ValidatorDecoratorInfo's and checking if any of them have `always=True` We ..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/types.py", "score": 0.5295067429542542, "span_start": null, "span_end": null, "passage": "\"\"\"\n            if isinstance(value, bool):\n                return value\n\n            raise errors.StrictBoolError()\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ INTEGER TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.5292648077011108, "span_start": null, "span_end": null, "passage": "V1Validator = Union[\n    V1ValidatorWithValues, V1ValidatorWithValuesKwOnly, V1ValidatorWithKwargs, V1ValidatorWithValuesAndKwargs\n]\n\n\ndef can_be_keyword(param: Parameter) -> bool:\n    return param.ki..."}, {"qid": "", "rank": 8, "path": "pydantic/functional_validators.py", "score": 0.5285754203796387, "span_start": null, "span_end": null, "passage": "You can also use `SkipValidation[int]` as a shorthand for `Annotated[int, SkipValidation]` This can be useful if you want to use a type annotation for documentation/IDE/type-checking purposes,\n       ..."}, {"qid": "", "rank": 9, "path": "pydantic/functional_validators.py", "score": 0.5229769945144653, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 10, "path": "pydantic/functional_validators.py", "score": 0.5229769349098206, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 11, "path": "pydantic/functional_validators.py", "score": 0.5229769349098206, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 12, "path": "pydantic/functional_validators.py", "score": 0.5229769349098206, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 13, "path": "pydantic/functional_validators.py", "score": 0.5138036012649536, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def dec(f: Any) -> _decorators.PydanticDescriptorProxy[Any]:\n        # auto apply the @classmethod decorator\n        f = _decorators.ensure_classmethod_based_on_signature(f)\n        dec_info ..."}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.5092681050300598, "span_start": null, "span_end": null, "passage": "Attributes:\n        strict: Whether to validate the field in strict mode"}, {"qid": "", "rank": 15, "path": "pydantic/type_adapter.py", "score": 0.5056805610656738, "span_start": null, "span_end": null, "passage": "strict: Whether to strictly check types context: Additional context to use during validation Returns:\n            The validated object \"\"\"\n        return self.validator.validate_json(data, strict=stri..."}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.4974967837333679, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return Annotated[FrozenSet[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]\n\n\nAnyItemType = TypeVar('AnyItemType')\n\n\ndef conlist(\n    item_typ..."}, {"qid": "", "rank": 17, "path": "pydantic/functional_validators.py", "score": 0.49702417850494385, "span_start": null, "span_end": null, "passage": "_V2Validator = Union[\n        _V2ValidatorClsMethod,\n        _core_schema.WithInfoValidatorFunction,\n        _OnlyValueValidatorClsMethod,\n        _core_schema.NoInfoValidatorFunction,\n    ]\n\n    _V2W..."}, {"qid": "", "rank": 18, "path": "pydantic/functional_validators.py", "score": 0.4962792992591858, "span_start": null, "span_end": null, "passage": "Args:\n        mode: A required string literal that specifies the validation mode It can be one of the following: 'wrap', 'before', or 'after' Returns:\n        A decorator that can be used to decorate ..."}, {"qid": "", "rank": 19, "path": "pydantic/experimental/pipeline.py", "score": 0.4939720630645752, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if isinstance(tp, EllipsisType):\n            return _Pipeline[_InT, Any](self._steps + (_ValidateAs(_FieldTypeMarker, strict=strict),))\n        return _Pipeline[_InT, _NewOutT](self._steps..."}, {"qid": "", "rank": 20, "path": "tests/test_types.py", "score": 0.4938691258430481, "span_start": null, "span_end": null, "passage": "Set `arbitrary_types_allowed=True`',\n    ):\n\n        class Model(BaseModel):\n            x: CustomIterable\n\n\ndef test_typing_extension_literal_field():\n    from typing_extensions import Literal\n\n    c..."}], "latency_ms": 3.657817840576172, "gold_paths": ["pydantic/main.py"]}
{"qid": "lens_main_func_52599452", "query": "Implement deprecated field in json schema (#9298)", "results": [{"qid": "", "rank": 1, "path": "pydantic/fields.py", "score": 0.7552417516708374, "span_start": null, "span_end": null, "passage": "description: Description to use when including this computed field in JSON Schema, defaults to the function's\n            docstring\n        deprecated: A deprecation message (or an instance of `warnin..."}, {"qid": "", "rank": 2, "path": "tests/test_deprecated_fields.py", "score": 0.637906551361084, "span_start": null, "span_end": null, "passage": "import importlib.metadata\n\nimport pytest\nfrom packaging.version import Version\nfrom typing_extensions import Annotated, Self, deprecated\n\nfrom pydantic import BaseModel, Field, computed_field, field_v..."}, {"qid": "", "rank": 3, "path": "pydantic/fields.py", "score": 0.6287999153137207, "span_start": null, "span_end": null, "passage": "If `True`, a default deprecation message will be emitted when accessing the field json_schema_extra: A dict or callable to provide extra JSON schema properties frozen: Whether the field is frozen If t..."}, {"qid": "", "rank": 4, "path": "pydantic/fields.py", "score": 0.6199376583099365, "span_start": null, "span_end": null, "passage": "json_schema_extra: A dict or callable to provide extra JSON schema properties repr: A boolean indicating whether to include the field in the __repr__ output"}, {"qid": "", "rank": 5, "path": "pydantic/config.py", "score": 0.6146738529205322, "span_start": null, "span_end": null, "passage": "Defaults to `True`.\"\"\"\n\n    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n    \"\"\"A dict or callable to provide extra JSON schema properties Defaults to `None`.\"\"\"\n\n    json_encoders: di..."}, {"qid": "", "rank": 6, "path": "tests/test_deprecated.py", "score": 0.6114597320556641, "span_start": null, "span_end": null, "passage": "Use `json_schema_extra` instead"}, {"qid": "", "rank": 7, "path": "pydantic/fields.py", "score": 0.5943450927734375, "span_start": null, "span_end": null, "passage": "discriminator: Field name or Discriminator for discriminating the type in a tagged union deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` b..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_model_construction.py", "score": 0.5795989036560059, "span_start": null, "span_end": null, "passage": "Attributes:\n        msg: The deprecation message to be emitted wrapped_property: The property instance if the deprecated field is a computed field, or `None` field_name: The name of the field being de..."}, {"qid": "", "rank": 9, "path": "pydantic/fields.py", "score": 0.5786081552505493, "span_start": null, "span_end": null, "passage": "warning Deprecated\n                The `extra` kwargs is deprecated Use `json_schema_extra` instead Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo] The return annotation is `Any` so `F..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.5779393315315247, "span_start": null, "span_end": null, "passage": "For backwards compatibility with v1, this does not raise an error, but can be overridden to change this Args:\n            schema: The core schema Returns:\n            The generated JSON schema \"\"\"\n   ..."}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.575393795967102, "span_start": null, "span_end": null, "passage": "Args:\n            field: The schema for the field itself Returns:\n            `True` if the field should be included in the generated JSON schema, `False` otherwise"}, {"qid": "", "rank": 12, "path": "pydantic/fields.py", "score": 0.5740911960601807, "span_start": null, "span_end": null, "passage": "field_title_generator: A callable that takes a field name and returns title for it description: Description of the computed field to include in the serialization JSON schema deprecated: A deprecation ..."}, {"qid": "", "rank": 13, "path": "pydantic/config.py", "score": 0.5713576078414917, "span_start": null, "span_end": null, "passage": "By specifying a `json_schema_mode_override` though, this prevents the conflict between\n    the validation and serialization schemas (since both will use the specified schema), and so prevents the suff..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.5711404085159302, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self.mode == 'serialization' and self._config.json_schema_serialization_defaults_required:\n            return not field.get('serialization_exclude')\n        else:\n            if field['..."}, {"qid": "", "rank": 15, "path": "tests/test_fastapi_json_schema.py", "score": 0.5691731572151184, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def handle_invalid_for_json_schema(self, schema: CoreSchemaOrField, error_info: str) -> JsonSchemaValue:\n        # NOTE: I think it may be a good idea to rework this method to either not use ..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.5661746263504028, "span_start": null, "span_end": null, "passage": "This class generates JSON schemas based on configured parameters The default schema dialect\n    is [https://json-schema.org/draft/2020-12/schema](https://json-schema.org/draft/2020-12/schema) The clas..."}, {"qid": "", "rank": 17, "path": "pydantic/fields.py", "score": 0.5545827150344849, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    decorator_repr: ClassVar[str] = '@computed_field'\n    wrapped_property: property\n    return_type: Any\n    alias: str | None\n    alias_priority: int | None\n    title: str | None\n    field_titl..."}, {"qid": "", "rank": 18, "path": "pydantic/main.py", "score": 0.5536542534828186, "span_start": null, "span_end": null, "passage": "Since this gets called by `BaseModel.model_json_schema` you can override the\n                `schema_generator` argument to that function to change JSON schema generation globally\n                for ..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.5506331920623779, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n_MODE_TITLE_MAPPING: dict[JsonSchemaMode, str] = {'validation': 'Input', 'serialization': 'Output'}\n\n\n@deprecated(\n    '`update_json_schema` is deprecated, use a simple `my_dict.update(update_dic..."}, {"qid": "", "rank": 20, "path": "pydantic/fields.py", "score": 0.5469508171081543, "span_start": null, "span_end": null, "passage": "examples: Example values to use when including this computed field in JSON Schema\n        json_schema_extra: A dict or callable to provide extra JSON schema properties repr: whether to include this co..."}], "latency_ms": 3.643512725830078, "gold_paths": ["pydantic/json_schema.py", "tests/test_json_schema.py"]}
{"qid": "lens_main_func_c4885087", "query": "Fix a bug when setting StringConstraint(strict=False) (#9476)", "results": [{"qid": "", "rank": 1, "path": "pydantic/experimental/pipeline.py", "score": 0.4462747573852539, "span_start": null, "span_end": null, "passage": "@overload\n    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]: .. @overload\n    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _P..."}, {"qid": "", "rank": 2, "path": "pydantic/types.py", "score": 0.44476839900016785, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return Annotated[  # pyright: ignore[reportReturnType]\n        bytes,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Len(min_length or 0, max_length),\n    ]\n\n\n..."}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.44191980361938477, "span_start": null, "span_end": null, "passage": "=== \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, constr\n\n            class Foo(BaseModel):\n                bar: constr(strip_whitespace=True, to_upper=True, patter..."}, {"qid": "", "rank": 4, "path": "pydantic/types.py", "score": 0.4389674663543701, "span_start": null, "span_end": null, "passage": "warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`StringConstraints`..."}, {"qid": "", "rank": 5, "path": "pydantic/config.py", "score": 0.42999687790870667, "span_start": null, "span_end": null, "passage": "Defaults to `False`.\"\"\"\n\n    str_strip_whitespace: bool\n    \"\"\"Whether to strip leading and trailing whitespace for str types.\"\"\"\n\n    str_min_length: int\n    \"\"\"The minimum length for str types Defau..."}, {"qid": "", "rank": 6, "path": "pydantic/types.py", "score": 0.42519813776016235, "span_start": null, "span_end": null, "passage": "=== \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, conint\n\n            class Foo(BaseModel):\n                bar: conint(strict=True, gt=0)\n            ```\n\n        ..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/fields.py", "score": 0.4239486753940582, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = (\n        'default',\n        'default_factory',\n        'alias',\n        'alias_priority',\n        'title',\n        'description',\n        'exclude',\n        'include',\n        'c..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.42062482237815857, "span_start": null, "span_end": null, "passage": "Finally, this module makes liberal use of `# type: ignore[<code>]` pragmas This is because Hypothesis annotates `register_type_strategy()` with\n`(T, SearchStrategy[T])`, but in most cases we register ..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/types.py", "score": 0.41586965322494507, "span_start": null, "span_end": null, "passage": "\"\"\"\n            if isinstance(value, bool):\n                return value\n\n            raise errors.StrictBoolError()\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ INTEGER TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n..."}, {"qid": "", "rank": 10, "path": "pydantic/experimental/pipeline.py", "score": 0.4046379327774048, "span_start": null, "span_end": null, "passage": "@overload\n    def constrain(\n        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n    ) -> _Pipeline[_InT, _NewOutInterval]: .. @overload\n    def constrain(self: _Pipel..."}, {"qid": "", "rank": 11, "path": "pydantic/plugin/__init__.py", "score": 0.4015415906906128, "span_start": null, "span_end": null, "passage": "strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators \"\"\"\n        pass"}, {"qid": "", "rank": 12, "path": "pydantic/v1/schema.py", "score": 0.3977249562740326, "span_start": null, "span_end": null, "passage": ":param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.3939823508262634, "span_start": null, "span_end": null, "passage": "Args:\n        strict: Whether to validate the date value in strict mode Defaults to `None` gt: The value must be greater than this Defaults to `None` ge: The value must be greater than or equal to thi..."}, {"qid": "", "rank": 14, "path": "pydantic/type_adapter.py", "score": 0.39328768849372864, "span_start": null, "span_end": null, "passage": "context: Additional context to pass to the validator Returns:\n            The default value wrapped in a `Some` if there is one or None if not"}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.3906290531158447, "span_start": null, "span_end": null, "passage": "=== \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, confloat\n\n            class Foo(BaseModel):\n                bar: confloat(strict=True, gt=0)\n            ```\n\n    ..."}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.39061564207077026, "span_start": null, "span_end": null, "passage": "\"\"\"  # noqa: D212\n    return Annotated[  # pyright: ignore[reportReturnType]\n        str,\n        StringConstraints(\n            strip_whitespace=strip_whitespace,\n            to_upper=to_upper,\n     ..."}, {"qid": "", "rank": 17, "path": "pydantic/experimental/pipeline.py", "score": 0.38916683197021484, "span_start": null, "span_end": null, "passage": "@overload\n    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]: .. @overload\n    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint..."}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.3853227496147156, "span_start": null, "span_end": null, "passage": "Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)\n        \"\"\"\n        if name not in self.tracked_config_fields:\n            return None\n   ..."}, {"qid": "", "rank": 19, "path": "pydantic/experimental/pipeline.py", "score": 0.3825165927410126, "span_start": null, "span_end": null, "passage": "@overload\n    def constrain(\n        self: _Pipeline[_InT, _NewOutT], constraint: annotated_types.MultipleOf\n    ) -> _Pipeline[_InT, _NewOutT]: .. @overload\n    def constrain(\n        self: _Pipeline..."}, {"qid": "", "rank": 20, "path": "pydantic/fields.py", "score": 0.38178518414497375, "span_start": null, "span_end": null, "passage": "(Only applies to dataclasses.)\n        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode) strict: If `True`, strict validation is applied..."}], "latency_ms": 3.6640167236328125, "gold_paths": ["pydantic/types.py", "tests/test_types.py"]}
{"qid": "lens_main_func_d1f650a3", "query": "\ud83d\udcd6 docs: Update docs for `NewPath` (#9462)", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.46105971932411194, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file}#{slug})\\n'\n\n\ndef update_docstring(obj: GriffeObject) -> str:\n    return re.sub(\n        r'usage[\\- ]docs: ?https://docs\\.pydantic\\.dev/.+?..."}, {"qid": "", "rank": 2, "path": "pydantic/errors.py", "score": 0.44978153705596924, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version imp..."}, {"qid": "", "rank": 3, "path": "tests/check_usage_docs.py", "score": 0.4283596873283386, "span_start": null, "span_end": null, "passage": "\"\"\"\nCheck that all `Usage docs` tags in docstrings link to the latest version of pydantic"}, {"qid": "", "rank": 4, "path": "pydantic/_migration.py", "score": 0.4242112636566162, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if name == '__path__':\n            raise AttributeError(f'module {module!r} has no attribute {name!r}')\n\n        import warnings\n\n        from ._internal._validators import import_string\n\n..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/env_settings.py", "score": 0.40138673782348633, "span_start": null, "span_end": null, "passage": "\"\"\"\n        secrets: Dict[str, Optional[str]] = {}\n\n        if self.secrets_dir is None:\n            return secrets\n\n        secrets_path = Path(self.secrets_dir).expanduser()\n\n        if not secrets_..."}, {"qid": "", "rank": 6, "path": "pydantic/_migration.py", "score": 0.3757070302963257, "span_start": null, "span_end": null, "passage": "We are importing from `{new_location}` instead.'\n                'See the migration guide for more details: https://docs.pydantic.dev/latest/migration/'\n            )\n            return import_string(..."}, {"qid": "", "rank": 7, "path": "docs/plugins/griffe_doclinks.py", "score": 0.3614047169685364, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n' f'    [`{api_link}`][{api_link}]<br>\\n\\n' f'{content}')\n\n    heading = file_path.stem.replace('_', ' ').title()\n    return f'!!"}, {"qid": "", "rank": 8, "path": "pydantic/_migration.py", "score": 0.3541034460067749, "span_start": null, "span_end": null, "passage": "'\n                f'See https://docs.pydantic.dev/{version_short()}/migration/#basesettings-has-moved-to-pydantic-settings '\n                'for more details.'\n            )\n        if import_path in..."}, {"qid": "", "rank": 9, "path": "docs/plugins/main.py", "score": 0.34560626745224, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nimport json\nimport logging\nimport os\nimport re\nimport textwrap\nfrom pathlib import Path\nfrom textwrap import indent\n\nimport autoflake\nimport pyupgra..."}, {"qid": "", "rank": 10, "path": "pydantic/main.py", "score": 0.34201642870903015, "span_start": null, "span_end": null, "passage": "Args:\n            update: Values to change/add in the new model Note: the data is not validated\n                before creating the new model You should trust this data deep: Set to `True` to make a d..."}, {"qid": "", "rank": 11, "path": "docs/plugins/griffe_doclinks.py", "score": 0.34128326177597046, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file})\\n'\n\n\ndef replace_links(m: re.Match, *, api_link: str) -> str:\n    path_group = m.group(1)\n    if '#' not in path_group:\n        # no head..."}, {"qid": "", "rank": 12, "path": "pydantic/errors.py", "score": 0.32978957891464233, "span_start": null, "span_end": null, "passage": "DEV_ERROR_DOCS_URL = f'https://errors.pydantic.dev/{version_short()}/u/'\nPydanticErrorCodes = Literal[\n    'class-not-fully-defined',\n    'custom-json-schema',\n    'decorator-missing-field',\n    'disc..."}, {"qid": "", "rank": 13, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.3261752724647522, "span_start": null, "span_end": null, "passage": "'\n            'If a directory is passed, a default filename is used.'\n        ),\n    )\n    parser.add_argument(\n        '--min-n-fields',\n        type=int,\n        default=0,\n        help=('Test the p..."}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.3215373754501343, "span_start": null, "span_end": null, "passage": "```py\nfrom pathlib import Path\n\nfrom pydantic import BaseModel, FilePath, ValidationError\n\nclass Model(BaseModel):\n    f: FilePath\n\npath = Path('text.txt')\npath.touch()\nm = Model(f='text.txt')\nprint(m..."}, {"qid": "", "rank": 15, "path": "pydantic/schema.py", "score": 0.32152360677719116, "span_start": null, "span_end": null, "passage": "\"\"\"The `schema` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_core_utils.py", "score": 0.3213697671890259, "span_start": null, "span_end": null, "passage": "\"\"\"\nHAS_INVALID_SCHEMAS_METADATA_KEY = 'pydantic.internal.invalid'\n\"\"\"Used to mark a schema that is invalid because it refers to a definition that was not yet defined when the\nschema was first encount..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.32056277990341187, "span_start": null, "span_end": null, "passage": "```py\nfrom pathlib import Path\n\nfrom pydantic import BaseModel, DirectoryPath, ValidationError\n\nclass Model(BaseModel):\n    f: DirectoryPath\n\npath = Path('directory/')\npath.mkdir()\nm = Model(f='direct..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/mypy.py", "score": 0.3204435408115387, "span_start": null, "span_end": null, "passage": "var_str = repr(var)\n                    detail = f'sym_node.node: {var_str} (of type {var.__class__})'\n                    error_unexpected_behavior(detail, ctx.api, ctx.cls)\n            else:\n       ..."}, {"qid": "", "rank": 19, "path": "pydantic/utils.py", "score": 0.3181769847869873, "span_start": null, "span_end": null, "passage": "\"\"\"The `utils` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 20, "path": "pydantic/dataclasses.py", "score": 0.31664109230041504, "span_start": null, "span_end": null, "passage": "This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails This is analogous to `B..."}], "latency_ms": 3.5812854766845703, "gold_paths": ["pydantic/types.py"]}
{"qid": "lens_main_func_7bdfac37", "query": "\ud83e\uddea test: Add more cases in `test_json_schema` (#9457)", "results": [{"qid": "", "rank": 1, "path": "tests/test_deprecated.py", "score": 0.674514651298523, "span_start": null, "span_end": null, "passage": "Use `json_schema_extra` instead"}, {"qid": "", "rank": 2, "path": "pydantic/json_schema.py", "score": 0.5868581533432007, "span_start": null, "span_end": null, "passage": "\"\"\"\n        items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])\n        json_schema = {'type': 'array', 'items': items_schema}\n        self.update_with_v..."}, {"qid": "", "rank": 3, "path": "pydantic/json_schema.py", "score": 0.580329418182373, "span_start": null, "span_end": null, "passage": "Args:\n                schema_or_field: The core schema to generate a JSON schema from Returns:\n                The generated JSON schema Raises:\n                TypeError: If an unexpected schema type..."}, {"qid": "", "rank": 4, "path": "pydantic/fields.py", "score": 0.5764503479003906, "span_start": null, "span_end": null, "passage": "json_schema_extra: A dict or callable to provide extra JSON schema properties repr: A boolean indicating whether to include the field in the __repr__ output"}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.5653095245361328, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self._used:\n            raise PydanticUserError(\n                'This JSON schema generator has already been used to generate a JSON schema"}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.5628011226654053, "span_start": null, "span_end": null, "passage": "if use_strict:\n            return self.generate_inner(schema['strict_schema'])\n        else:\n            return self.generate_inner(schema['lax_schema'])\n\n    def json_or_python_schema(self, schema: c..."}, {"qid": "", "rank": 7, "path": "pydantic/json_schema.py", "score": 0.554876446723938, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema \"\"\"\n        json_schema = {'type': 'string'}\n        self.update_with_validations(json_schema, schema, self.Val..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.5547077655792236, "span_start": null, "span_end": null, "passage": "Args:\n            json_schema: The schema to resolve Returns:\n            The resolved schema"}, {"qid": "", "rank": 9, "path": "pydantic/json_schema.py", "score": 0.5542497634887695, "span_start": null, "span_end": null, "passage": "Args:\n            field: The schema for the field itself Returns:\n            `True` if the field should be included in the generated JSON schema, `False` otherwise"}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.5505468845367432, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # TODO: Need to read the default value off of model config or whatever\n        use_strict = schema.get('strict', False)  # TODO: replace this default False\n        # If your JSON schema fa..."}, {"qid": "", "rank": 11, "path": "tests/test_fastapi_json_schema.py", "score": 0.5496087074279785, "span_start": null, "span_end": null, "passage": "assert (\n        FastAPIGenerateJsonSchema.handle_invalid_for_json_schema\n        is not GenerateJsonSchema.handle_invalid_for_json_schema\n    )\n\n\ndef test_collect_errors() -> None:\n    class Car:\n   ..."}, {"qid": "", "rank": 12, "path": "tests/test_json_schema.py", "score": 0.5473798513412476, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        foo = 'f'\n        bar = 'b'\n\n        @classmethod\n        def __get_pydantic_json_schema__(\n            cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler\n        ) -> JsonSchema..."}, {"qid": "", "rank": 13, "path": "pydantic/json_schema.py", "score": 0.5450621247291565, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # Note: 'multi-host-uri' is a custom/pydantic-specific format, not part of the JSON Schema spec\n        json_schema = {'type': 'string', 'format': 'multi-host-uri', 'minLength': 1}\n       ..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.5419871807098389, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema: JsonSchemaValue = {'type': 'object'}\n\n        keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\n        keys_pattern = keys_sc..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.5400829315185547, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema = self.str_schema(core_schema.str_schema())\n        if self.mode == 'validation':\n            multiple_of = schema.get('multiple_of')\n            le = schema.get('le')\n        ..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.5395482778549194, "span_start": null, "span_end": null, "passage": "Use `tuple_schema` instead.',\n            PydanticDeprecatedSince26,\n            stacklevel=2,\n        )\n        return self.tuple_schema(schema)\n\n    def tuple_schema(self, schema: core_schema.TupleS..."}, {"qid": "", "rank": 17, "path": "pydantic/fields.py", "score": 0.5379592180252075, "span_start": null, "span_end": null, "passage": "use `pattern` instead', code='removed-kwargs')\n\n    if extra:\n        warn(\n            'Using extra keyword arguments on `Field` is deprecated and will be removed.'\n            ' Use `json_schema_ext..."}, {"qid": "", "rank": 18, "path": "tests/test_json_schema.py", "score": 0.5361025333404541, "span_start": null, "span_end": null, "passage": "Model.model_rebuild()\n\n    assert Model.model_json_schema() == {\n        '$defs': {\n            'Model': {\n                'title': 'Model',\n                'type': 'object',\n                'properti..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.5332751870155334, "span_start": null, "span_end": null, "passage": "please report it'\n    return schema_generator_instance.generate(cls.__pydantic_core_schema__, mode=mode)\n\n\ndef models_json_schema(\n    models: Sequence[tuple[type[BaseModel] | type[PydanticDataclass],..."}, {"qid": "", "rank": 20, "path": "pydantic/json_schema.py", "score": 0.5330513715744019, "span_start": null, "span_end": null, "passage": "Use `tuple_schema` instead.', category=None)\n    @final\n    def tuple_positional_schema(self, schema: core_schema.TupleSchema) -> JsonSchemaValue:\n        \"\"\"Replaced by `tuple_schema`.\"\"\"\n        war..."}], "latency_ms": 3.718852996826172, "gold_paths": ["tests/test_json_schema.py"]}
{"qid": "lens_main_func_46a05652", "query": "Add warning when set \"alias\" in low level annontated field (#9170)", "results": [{"qid": "", "rank": 1, "path": "pydantic/mypy.py", "score": 0.6658681631088257, "span_start": null, "span_end": null, "passage": "This will be called when `warn_required_dynamic_aliases=True`"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_fields.py", "score": 0.6052855253219604, "span_start": null, "span_end": null, "passage": "# Nothing stops us from just creating a new FieldInfo for this type hint, so we do this field_info = FieldInfo.from_annotation(ann_type)\n        else:\n            _warn_on_nested_alias_in_annotation(a..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5433807373046875, "span_start": null, "span_end": null, "passage": "- If discriminator fields have different aliases - If discriminator field not of type `Literal`"}, {"qid": "", "rank": 4, "path": "tests/test_aliases.py", "score": 0.5344051122665405, "span_start": null, "span_end": null, "passage": "The specific alias, if specified, or\n        # 2 The alias, if specified, or\n        # 3 The generated alias (i.e"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5264922976493835, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n\n        if (\n            computed_field_info.alias_priority is None\n            or computed_field_info.alias_priority <= 1\n            or computed_fiel..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5257536768913269, "span_start": null, "span_end": null, "passage": "An alias is specified, but the priority is <= 1\n        if (\n            field_info.alias_priority is None\n            or field_info.alias_priority <= 1\n            or field_info.alias is None\n       ..."}, {"qid": "", "rank": 7, "path": "pydantic/mypy.py", "score": 0.5254415273666382, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not config.populate_by_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_extra:\n       ..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/config.py", "score": 0.5115346908569336, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        fields_value = cls.fields.get(name)\n\n        if isinstance(fields_value, str):\n            field_info: Dict[str, Any] = {'alias': fields_value}\n        elif isinstance(fields_value, dict)..."}, {"qid": "", "rank": 9, "path": "pydantic/fields.py", "score": 0.5081096291542053, "span_start": null, "span_end": null, "passage": "it should be `str`, `AliasChoices`, or `AliasPath`')\n\n    if serialization_alias in (_Unset, None) and isinstance(alias, str):\n        serialization_alias = alias\n\n    if validation_alias in (_Unset, ..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/mypy.py", "score": 0.5064634084701538, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not config.allow_population_by_field_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_..."}, {"qid": "", "rank": 11, "path": "pydantic/aliases.py", "score": 0.5058364868164062, "span_start": null, "span_end": null, "passage": "Returns None if the alias generator is None Raises:\n            TypeError: If the alias generator produces an invalid type \"\"\"\n        alias = None\n        if alias_generator := getattr(self, alias_ki..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_signature.py", "score": 0.4815756678581238, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def _alias_if_valid(x: Any) -> str | None:\n        \"\"\"Return the alias if it is a valid alias and identifier, else None.\"\"\"\n        return x if isinstance(x, str) and is_valid_identifier(x) e..."}, {"qid": "", "rank": 13, "path": "tests/test_dataclasses.py", "score": 0.4794606566429138, "span_start": null, "span_end": null, "passage": "This is essentially a limitation of typing._GenericAlias"}, {"qid": "", "rank": 14, "path": "pydantic/config.py", "score": 0.47831541299819946, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    loc_by_alias: bool\n    \"\"\"Whether to use the actual key provided in the data (e.g alias) for error `loc`s rather than the field's name Defaults to `True`.\"\"\"\n\n    alias_generator: Callable[[s..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/mypy.py", "score": 0.47533130645751953, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 16, "path": "pydantic/mypy.py", "score": 0.47533130645751953, "span_start": null, "span_end": null, "passage": "`has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal If `has_dynamic_alias` is True, `alias` will be None"}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_config.py", "score": 0.4612553119659424, "span_start": null, "span_end": null, "passage": "alias or first alias for \"field required\" errors) instead of field_names\n    # to construct error `loc`s, default `True`\n    loc_by_alias: bool\n    alias_generator: Callable[[str], str] | AliasGenerat..."}, {"qid": "", "rank": 18, "path": "pydantic/aliases.py", "score": 0.45330023765563965, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    alias: Callable[[str], str] | None = None\n    validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None\n    serialization_alias: Callable[[str], str] | None = None\n\n    ..."}, {"qid": "", "rank": 19, "path": "tests/test_main.py", "score": 0.4524657726287842, "span_start": null, "span_end": null, "passage": "with warnings.catch_warnings(record=True) as captured_warnings:\n        # Start capturing all warnings\n        warnings.simplefilter('always')\n\n        class ChildWithoutRedefinedField(BaseModel, Pare..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/mypy.py", "score": 0.45206326246261597, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if isinstance(type_, AnyType):\n            # Annotated as Any\n            return True\n        if isinstance(type_, UnionType) and any(\n            isinstance(item, NoneType) or isinstance(..."}], "latency_ms": 3.5877227783203125, "gold_paths": ["pydantic/_internal/_fields.py", "tests/test_annotated.py"]}
{"qid": "lens_main_func_0e3337fd", "query": "docs(fields): fix link to union modes (#9431)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4900296926498413, "span_start": null, "span_end": null, "passage": "# However, it still may make sense to apply the discriminator to this schema,\n            # as a way to get discriminated-union-style error messages, so we allow this here"}, {"qid": "", "rank": 2, "path": "pydantic/v1/fields.py", "score": 0.4544724225997925, "span_start": null, "span_end": null, "passage": "tagged) `Union` of sub models with a common field"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4383774995803833, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The input schema Returns:\n            The new core schema Raises:\n            TypeError:\n                - If `discriminator` is used with invalid union variant - If `discrim..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/typing.py", "score": 0.4252585172653198, "span_start": null, "span_end": null, "passage": "For unions, basic simplifications used by Union constructor are performed"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4109286367893219, "span_start": null, "span_end": null, "passage": "This function does that, but also handles nested unions and defaults \"\"\"\n        if schema['type'] == 'literal':\n            return schema['expected']\n\n        elif schema['type'] == 'union':\n        ..."}, {"qid": "", "rank": 6, "path": "pydantic/types.py", "score": 0.40449899435043335, "span_start": null, "span_end": null, "passage": "This allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,\n    but without needing to have a single shared field across all the union choices This also makes i..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4042637348175049, "span_start": null, "span_end": null, "passage": "self._discriminator_alias: str | None = None\n\n        # `_should_be_nullable` indicates whether the converted union has `None` as an allowed value # If `None` is an acceptable value of the (possibly-w..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_generics.py", "score": 0.39587050676345825, "span_start": null, "span_end": null, "passage": "Because we parse items as the first Union type that is successful, we get slightly more consistent behavior\n    if we make an effort to distinguish the ordering of items in a union It would be best if..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.39571547508239746, "span_start": null, "span_end": null, "passage": "Here, \"handling\" entails:\n        * Coalescing nested unions and compatible tagged-unions\n        * Tracking the presence of 'none' and 'nullable' schemas occurring as choices\n        * Validating tha..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3935006260871887, "span_start": null, "span_end": null, "passage": "Initially, choices\n        # from the union in the wrapped schema will be appended to this list, and the recursive choice-handling\n        # algorithm may add more choices to this stack as (nested) un..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generics.py", "score": 0.3896522521972656, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # The _union_orderings_key is placed at the start here to ensure there cannot be a collision with an\n    # _early_cache_key, as that function will always produce a BaseModel subclass as the fi..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_generics.py", "score": 0.38894933462142944, "span_start": null, "span_end": null, "passage": "Thanks to caching internal to the `typing` module, it is not possible to distinguish between\n    List[Union[int, float]] and List[Union[float, int]] (and similarly for other \"parent\" origins besides L..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.38080334663391113, "span_start": null, "span_end": null, "passage": "[Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    discriminator: str | Callable[[Any], Hashable]\n    \"\"\"The callable or field name for discriminating the type in a tagged..."}, {"qid": "", "rank": 14, "path": "pydantic/fields.py", "score": 0.3807867169380188, "span_start": null, "span_end": null, "passage": "Later `FieldInfo` instances override earlier ones Returns:\n            FieldInfo: A merged FieldInfo instance"}, {"qid": "", "rank": 15, "path": "pydantic/fields.py", "score": 0.3735061287879944, "span_start": null, "span_end": null, "passage": "decimal_places: Maximum number of decimal places allowed for numbers union_mode: The strategy to apply when validating a union Can be `smart` (the default), or `left_to_right` See [Union Mode](../conc..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_core_utils.py", "score": 0.368429958820343, "span_start": null, "span_end": null, "passage": "import _repr\nfrom ._typing_extra import is_generic_alias\n\nAnyFunctionSchema = Union[\n    core_schema.AfterValidatorFunctionSchema,\n    core_schema.BeforeValidatorFunctionSchema,\n    core_schema.WrapVa..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.3672252297401428, "span_start": null, "span_end": null, "passage": "self._should_be_nullable = False\n\n        # `_is_nullable` is used to track if the final produced schema will definitely be nullable;\n        # we set it to True if the input schema is wrapped in a nu..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/fields.py", "score": 0.3668616712093353, "span_start": null, "span_end": null, "passage": "The FieldInfo may be set in typing.Annotated or the value, but not both If neither contain\n        a FieldInfo, a new one will be created using the config"}, {"qid": "", "rank": 19, "path": "tests/test_generics.py", "score": 0.3653064966201782, "span_start": null, "span_end": null, "passage": "#  I am sure we can solve this problem, just need to put a bit more effort in #  While I don't think we should block merging this functionality on getting the next line to pass,\n    #  I think we shou..."}, {"qid": "", "rank": 20, "path": "tests/mypy/modules/plugin_fail_baseConfig.py", "score": 0.36515888571739197, "span_start": null, "span_end": null, "passage": "c: int = Field(...)\n    d: Union[int, str]\n    e = .."}], "latency_ms": 3.5829544067382812, "gold_paths": ["pydantic/fields.py"]}
{"qid": "lens_main_func_1ea21160", "query": "[Docs] Fix ModuleNotFoundError in Pydantic Extra Types (#9433)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_fields.py", "score": 0.769806981086731, "span_start": null, "span_end": null, "passage": "\"\"\"\n    module_name = getattr(obj, '__module__', None)\n    globalns: dict[str, Any] | None = None\n    if module_name:\n        try:\n            globalns = sys.modules[module_name].__dict__\n        exce..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_typing_extra.py", "score": 0.7497228384017944, "span_start": null, "span_end": null, "passage": "The `module` argument is omitted as it breaks <3.9.8, =3.10.0 and isn't used in the calls below See https://github.com/python/cpython/pull/28560 for some background The backport happened on 3.9.8, see..."}, {"qid": "", "rank": 3, "path": "pydantic/_migration.py", "score": 0.747125506401062, "span_start": null, "span_end": null, "passage": "'\n                f'See https://docs.pydantic.dev/{version_short()}/migration/#basesettings-has-moved-to-pydantic-settings '\n                'for more details.'\n            )\n        if import_path in..."}, {"qid": "", "rank": 4, "path": "pydantic/dataclasses.py", "score": 0.7454323768615723, "span_start": null, "span_end": null, "passage": "\"\"\"\n        raise TypeError(\"'InitVar' object is not callable\")\n\n    dataclasses.InitVar.__call__ = _call_initvar\n\n\ndef rebuild_dataclass(\n    cls: type[PydanticDataclass],\n    *,\n    force: bool = Fa..."}, {"qid": "", "rank": 5, "path": "tests/test_json_schema.py", "score": 0.7427050471305847, "span_start": null, "span_end": null, "passage": "This was reported as broken in https://github.com/pydantic/pydantic/issues/8689, which was\n    originally caused by the change made in https://github.com/pydantic/pydantic/pull/8583, which has\n    sin..."}, {"qid": "", "rank": 6, "path": "tests/test_type_hints.py", "score": 0.7381188273429871, "span_start": null, "span_end": null, "passage": "pydantic.warnings.PydanticDeprecatedSince20: The `__fields__` attribute is deprecated,\n#      use `model_fields` instead"}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.7179766893386841, "span_start": null, "span_end": null, "passage": "\"\"\"The types module contains custom types used by pydantic.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport base64\nimport dataclasses as _dataclasses\nimport re\nfrom datetime import date..."}, {"qid": "", "rank": 8, "path": "tests/test_forward_ref.py", "score": 0.7052063345909119, "span_start": null, "span_end": null, "passage": "assert module.Foobar.__pydantic_complete__ is False\n\n\ndef test_undefined_types_warning_1b_suppressed_via_config_2b_forward_ref(create_module):\n    @create_module\n    def module():\n        from typing ..."}, {"qid": "", "rank": 9, "path": "pydantic/errors.py", "score": 0.6970583200454712, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, message: str) -> None:\n        super().__init__(message, code='import-error')\n\n\nclass PydanticSchemaGenerationError(PydanticUserError):\n    \"\"\"An error raised during failur..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.6968550682067871, "span_start": null, "span_end": null, "passage": "\"\"\"Logic for generating pydantic-core schemas for standard library types Import of this module is deferred since it contains imports of many standard library modules"}, {"qid": "", "rank": 11, "path": "pydantic/experimental/__init__.py", "score": 0.6919786930084229, "span_start": null, "span_end": null, "passage": "\"\"\"The \"experimental\" module of pydantic contains potential new features that are subject to change.\"\"\"\n\nimport warnings\n\nfrom pydantic.warnings import PydanticExperimentalWarning\n\nwarnings.warn(\n    ..."}, {"qid": "", "rank": 12, "path": "pydantic/errors.py", "score": 0.6915096044540405, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, message: str, *, code: PydanticErrorCodes | None) -> None:\n        self.message = message\n        self.code = code\n\n    def __str__(self) -> str:\n        if self.code is No..."}, {"qid": "", "rank": 13, "path": "pydantic/errors.py", "score": 0.6837813854217529, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version imp..."}, {"qid": "", "rank": 14, "path": "pydantic/root_model.py", "score": 0.6823818683624268, "span_start": null, "span_end": null, "passage": "\"\"\"RootModel class and type definitions.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport typing\nfrom copy import copy, deepcopy\n\nfrom pydantic_core import PydanticUndefined\n\nfrom"}, {"qid": "", "rank": 15, "path": "pydantic/config.py", "score": 0.6813477277755737, "span_start": null, "span_end": null, "passage": "Although the configuration can be set using the `__pydantic_config__` attribute, it does not play well with type checkers,\n    especially with `TypedDict` !!"}, {"qid": "", "rank": 16, "path": "tests/test_deprecated.py", "score": 0.6794933080673218, "span_start": null, "span_end": null, "passage": "Use `pydantic.TypeAdapter.validate_python` instead',\n        '`schema_json_of` is deprecated Use `pydantic.TypeAdapter.json_schema` instead',\n        '`schema_of` is deprecated Use `pydantic.TypeAdapt..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_dataclasses.py", "score": 0.677688717842102, "span_start": null, "span_end": null, "passage": "\"\"\"Private logic for creating pydantic dataclasses.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport typing\nimport warnings\nfrom functools import partial, wraps\nfrom t..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_fields.py", "score": 0.6750010251998901, "span_start": null, "span_end": null, "passage": "\"\"\"Private logic related to fields (the `Field()` function and `FieldInfo` class), and arguments to `Annotated`.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport sys\ni..."}, {"qid": "", "rank": 19, "path": "pydantic/_migration.py", "score": 0.6708763837814331, "span_start": null, "span_end": null, "passage": "import sys\nfrom typing import Any, Callable, Dict\n\nfrom .version import version_short\n\nMOVED_IN_V2 = {\n    'pydantic.utils:version_info': 'pydantic.version:version_info',\n    'pydantic.error_wrappers:..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.6694635152816772, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nfrom typing import TYPE_CHECKING, Any, Hashable, Sequence\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom ..errors import PydanticUserError..."}], "latency_ms": 3.711223602294922, "gold_paths": ["docs/plugins/main.py"]}
{"qid": "lens_main_func_86025fc5", "query": "Make detection of TypeVar defaults robust to the CPython PEP-696 implementation (#9426)", "results": [{"qid": "", "rank": 1, "path": "pydantic/mypy.py", "score": 0.6948622465133667, "span_start": null, "span_end": null, "passage": "In particular, possibly use the signature of __set__ \"\"\"\n        default = sym.type\n        if sym.implicit:\n            return default\n        t = get_proper_type(sym.type)\n\n        # Perform a simpl..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generics.py", "score": 0.6352807283401489, "span_start": null, "span_end": null, "passage": "(See https://github.com/python/cpython/issues/86483 for reference.)\n    \"\"\"\n    if isinstance(typevar_values, tuple):\n        args_data = []\n        for value in typevar_values:\n            args_data...."}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.6137956976890564, "span_start": null, "span_end": null, "passage": "\"\"\"The types module contains custom types used by pydantic.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport base64\nimport dataclasses as _dataclasses\nimport re\nfrom datetime import date..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/typing.py", "score": 0.6120520830154419, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if type(tp).__name__ in AnnotatedTypeNames:\n            return cast(Type[Any], Annotated)  # mypy complains about _SpecialForm\n        return _typing_get_origin(tp) or getattr(tp, '__origi..."}, {"qid": "", "rank": 5, "path": "pydantic/deprecated/decorator.py", "score": 0.6118303537368774, "span_start": null, "span_end": null, "passage": "import warnings\nfrom functools import wraps\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Mapping, Optional, Tuple, Type, TypeVar, Union, overload\n\nfrom typing_extensions import depreca..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_typing_extra.py", "score": 0.608665943145752, "span_start": null, "span_end": null, "passage": "\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport re\n..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/annotated_types.py", "score": 0.602257251739502, "span_start": null, "span_end": null, "passage": "import sys\nfrom typing import TYPE_CHECKING, Any, Dict, FrozenSet, NamedTuple, Type\n\nfrom pydantic.v1.fields import Required\nfrom pydantic.v1.main import BaseModel, create_model\nfrom pydantic.v1.typin..."}, {"qid": "", "rank": 8, "path": "tests/test_type_hints.py", "score": 0.6004816293716431, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport inspect\nimport sys\nfrom typing import (\n    Any,\n    Dict,\n    Generic,\n    Optional,\n    Set,\n    TypeVar,\n)\n\nimport pytest\nimport typing_extensions\n\nfrom pydantic import (\n    BaseModel,..."}, {"qid": "", "rank": 9, "path": "tests/test_types.py", "score": 0.6000156402587891, "span_start": null, "span_end": null, "passage": "# There's still edge cases (again, arbitrary behavior...)\n        # and it's harder to explain, but could lead to a better user experience in some cases\n        # It will depend on how the complaints ..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_typing_extra.py", "score": 0.5999496579170227, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return typing.ForwardRef(arg, is_argument)\n\nelse:\n    _make_forward_ref = typing.ForwardRef\n\n\nif sys.version_info >= (3, 10):\n    get_type_hints = typing.get_type_hints\n\nelse:\n    \"\"\"\n    ..."}, {"qid": "", "rank": 11, "path": "pydantic/config.py", "score": 0.5969300270080566, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n\n_TypeT = TypeVar('_TypeT', bound=type)\n\n\ndef with_config(config: ConfigDict) -> Callable[[_TypeT], _TypeT]:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/config/#configuration-with-d..."}, {"qid": "", "rank": 12, "path": "pydantic/fields.py", "score": 0.5949904918670654, "span_start": null, "span_end": null, "passage": "This method applies the `typevars_map` to the annotation in place Args:\n            typevars_map: A dictionary mapping type variables to their concrete types types_namespace (dict | None): A dictionar..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_typing_extra.py", "score": 0.5877535343170166, "span_start": null, "span_end": null, "passage": "* prefixing `typing.` where appropriate\n        * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument https://github.com/python/cpython/blob/aaaf5174241496afca7ce4..."}, {"qid": "", "rank": 14, "path": "pydantic/mypy.py", "score": 0.5876595377922058, "span_start": null, "span_end": null, "passage": "if isinstance(self.type, TypeVarType):\n                modified_type = self.type.copy_modified()\n                modified_type.variance = INVARIANT\n                self.type = modified_type\n\n        i..."}, {"qid": "", "rank": 15, "path": "tests/test_types.py", "score": 0.58241868019104, "span_start": null, "span_end": null, "passage": "# There's still edge cases (again, arbitrary behavior...)\n        # and it's harder to explain, but could lead to a better user experience in some cases\n        # It will depend on how the complaints ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.5759667158126831, "span_start": null, "span_end": null, "passage": "Example:\n        ```py\n        from typing import List, Tuple, Union\n\n        from pydantic._internal._generics import replace_types\n\n        replace_types(Tuple[str, Union[List[str], float]], {str: i..."}, {"qid": "", "rank": 17, "path": "tests/benchmarks/test_fastapi_startup_generics.py", "score": 0.5726205706596375, "span_start": null, "span_end": null, "passage": "\"\"\"https://github.com/pydantic/pydantic/issues/6768\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any, Generic, List, TypeVar\n\nfrom typing_extensions import Annot..."}, {"qid": "", "rank": 18, "path": "pydantic/dataclasses.py", "score": 0.572365939617157, "span_start": null, "span_end": null, "passage": "def _call_initvar(*args: Any, **kwargs: Any) -> NoReturn:\n        \"\"\"This function does nothing but raise an error that is as similar as possible to what you'd get\n        if you were to try calling `..."}, {"qid": "", "rank": 19, "path": "tests/test_create_model.py", "score": 0.5722465515136719, "span_start": null, "span_end": null, "passage": "import platform\nimport re\nfrom typing import Generic, Optional, Tuple, TypeVar\n\nimport pytest\nfrom typing_extensions import Annotated\n\nfrom pydantic import (\n    BaseModel,\n    ConfigDict,\n    Field,\n..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/typing.py", "score": 0.5720698237419128, "span_start": null, "span_end": null, "passage": "AnnotatedTypeNames = {'AnnotatedMeta', '_AnnotatedAlias'}\n\n\nLITERAL_TYPES: Set[Any] = {Literal}\nif hasattr(typing, 'Literal'):\n    LITERAL_TYPES.add(typing.Literal)\n\n\nif sys.version_info < (3, 8):\n\n  ..."}], "latency_ms": 3.615140914916992, "gold_paths": ["pydantic/_internal/_generate_schema.py"]}
{"qid": "lens_main_func_8925e4fe", "query": "added @classmethod to @model_validator(mode='before') in docs and acr\u2026 (#9410)", "results": [{"qid": "", "rank": 1, "path": "pydantic/functional_validators.py", "score": 0.6368588209152222, "span_start": null, "span_end": null, "passage": "class ModelBeforeValidator(Protocol):\n    \"\"\"A `@model_validator` decorated function signature This is used when `mode='before'`.\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        cls: Any,\n  ..."}, {"qid": "", "rank": 2, "path": "pydantic/functional_validators.py", "score": 0.632291316986084, "span_start": null, "span_end": null, "passage": "@overload\ndef model_validator(\n    *,\n    mode: Literal['before'],\n) -> Callable[\n    [_AnyModeBeforeValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]\n]: .. @ove..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/class_validators.py", "score": 0.622651219367981, "span_start": null, "span_end": null, "passage": "def root_validator(\n    _func: Optional[AnyCallable] = None, *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False\n) -> Union['AnyClassMethod', Callable[[AnyCallable], 'AnyCla..."}, {"qid": "", "rank": 4, "path": "pydantic/functional_validators.py", "score": 0.6146911382675171, "span_start": null, "span_end": null, "passage": "ModelAfterValidatorWithoutInfo = Callable[[_ModelType], _ModelType]\n\"\"\"A `@model_validator` decorated function signature This is used when `mode='after'` and the function does not\nhave info argument \"..."}, {"qid": "", "rank": 5, "path": "pydantic/functional_validators.py", "score": 0.6104946136474609, "span_start": null, "span_end": null, "passage": "class FreeModelBeforeValidator(Protocol):\n    \"\"\"A `@model_validator` decorated function signature This is used when `mode='before'`.\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        # this c..."}, {"qid": "", "rank": 6, "path": "pydantic/functional_validators.py", "score": 0.6100326776504517, "span_start": null, "span_end": null, "passage": "Args:\n        field: The first field the `field_validator` should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one *fields: Addition..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.6089993119239807, "span_start": null, "span_end": null, "passage": "Attributes:\n        decorator_repr: A class variable representing the decorator string, '@validator' fields: A tuple of field names the validator should be called on mode: The proposed validator mode ..."}, {"qid": "", "rank": 8, "path": "pydantic/deprecated/class_validators.py", "score": 0.6068844795227051, "span_start": null, "span_end": null, "passage": "usage should be `@validator('<field_name_1>', '<field_name_2>', ...)`\",\n            code='validator-invalid-fields',\n        )\n\n    mode: Literal['before', 'after'] = 'before' if pre is True else 'aft..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generate_schema.py", "score": 0.6024136543273926, "span_start": null, "span_end": null, "passage": "(Or we can extend it and keep it if we add something equivalent\n    to the v1-validator `always` kwarg to `field_validator`.)\n    \"\"\"\n    for validator in validators:\n        if validator.info.always:..."}, {"qid": "", "rank": 10, "path": "pydantic/deprecated/class_validators.py", "score": 0.6011579632759094, "span_start": null, "span_end": null, "passage": "@deprecated(\n    'Pydantic V1 style `@root_validator` validators are deprecated.'\n    ' You should migrate to Pydantic V2 style `@model_validator` validators,'\n    ' see the migration guide for more d..."}, {"qid": "", "rank": 11, "path": "pydantic/functional_validators.py", "score": 0.5985932946205139, "span_start": null, "span_end": null, "passage": "usage should be `@validator('<field_name_1>', '<field_name_2>', ...)`\",\n            code='validator-invalid-fields',\n        )\n\n    def dec(\n        f: Callable[..., Any] | staticmethod[Any, Any] | cl..."}, {"qid": "", "rank": 12, "path": "pydantic/functional_validators.py", "score": 0.5958577394485474, "span_start": null, "span_end": null, "passage": "class ModelBeforeValidatorWithoutInfo(Protocol):\n    \"\"\"A @model_validator decorated function signature This is used when `mode='before'` and the function does not have info argument \"\"\"\n\n    def __ca..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_decorators.py", "score": 0.5767959356307983, "span_start": null, "span_end": null, "passage": "fields: A tuple of field names the validator should be called on mode: The proposed validator mode check_fields: Whether to check that the fields actually exist on the model \"\"\"\n\n    decorator_repr: C..."}, {"qid": "", "rank": 14, "path": "pydantic/functional_validators.py", "score": 0.5738755464553833, "span_start": null, "span_end": null, "passage": "def model_validator(\n    *,\n    mode: Literal['wrap', 'before', 'after'],\n) -> Any:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#model-validators\n\n    Decorate model methods f..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/main.py", "score": 0.5653075575828552, "span_start": null, "span_end": null, "passage": ":param __model_name: name of the created model\n    :param __config__: config class to use for the new model\n    :param __base__: base class for the new model to inherit from\n    :param __module__: mod..."}, {"qid": "", "rank": 16, "path": "pydantic/functional_validators.py", "score": 0.563005805015564, "span_start": null, "span_end": null, "passage": "class FreeModelBeforeValidatorWithoutInfo(Protocol):\n    \"\"\"A @model_validator decorated function signature This is used when `mode='before'` and the function does not have info argument \"\"\"\n\n    def ..."}, {"qid": "", "rank": 17, "path": "pydantic/functional_validators.py", "score": 0.5520047545433044, "span_start": null, "span_end": null, "passage": "This is used when `mode='after'`.\"\"\"\n\n_AnyModelWrapValidator = Union[ModelWrapValidator[_ModelType], ModelWrapValidatorWithoutInfo[_ModelType]]\n_AnyModeBeforeValidator = Union[\n    FreeModelBeforeVali..."}, {"qid": "", "rank": 18, "path": "pydantic/deprecated/class_validators.py", "score": 0.5517948865890503, "span_start": null, "span_end": null, "passage": "Args:\n        __field (str): The first field the validator should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one *fields (str): Ad..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/fields.py", "score": 0.5504596829414368, "span_start": null, "span_end": null, "passage": "\"\"\"\n        self.validate_always = getattr(self.type_, 'validate_always', False) or any(\n            v.always for v in self.class_validators.values()\n        )\n\n        class_validators_ = self.class_..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/main.py", "score": 0.5486003160476685, "span_start": null, "span_end": null, "passage": "_is_base_model_class_defined = False\n\n\n@dataclass_transform(kw_only_default=True, field_specifiers=(Field,))\nclass ModelMetaclass(ABCMeta):\n    @no_type_check  # noqa C901\n    def __new__(mcs, name, b..."}], "latency_ms": 3.9811134338378906, "gold_paths": ["tests/test_dataclasses.py", "tests/test_root_model.py", "tests/test_validators.py"]}
{"qid": "lens_main_func_07b64739", "query": "Fix duplicate test name (#9387)", "results": [{"qid": "", "rank": 1, "path": "tests/test_dataclasses.py", "score": 0.4261893033981323, "span_start": null, "span_end": null, "passage": "while working on one specific test"}, {"qid": "", "rank": 2, "path": "pydantic/v1/mypy.py", "score": 0.3760187327861786, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        # Get a nice unique name instead"}, {"qid": "", "rank": 3, "path": "tests/test_generics.py", "score": 0.3328292667865753, "span_start": null, "span_end": null, "passage": "#  I am sure we can solve this problem, just need to put a bit more effort in #  While I don't think we should block merging this functionality on getting the next line to pass,\n    #  I think we shou..."}, {"qid": "", "rank": 4, "path": "tests/test_deprecated.py", "score": 0.3317674994468689, "span_start": null, "span_end": null, "passage": "use `Set` instead'):\n\n        class Model(BaseModel):\n            x: List[int] = Field(None, unique_items=True)\n\n\ndef test_unique_items_conlist():\n    with pytest.raises(PydanticUserError, match='`uni..."}, {"qid": "", "rank": 5, "path": "tests/mypy/outputs/1.1.1/pyproject-default_toml/fail2.py", "score": 0.32871386408805847, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types"}, {"qid": "", "rank": 6, "path": "tests/mypy/outputs/1.1.1/mypy-default_ini/fail2.py", "score": 0.32871386408805847, "span_start": null, "span_end": null, "passage": "\"\"\"\nTest mypy failure with invalid types"}, {"qid": "", "rank": 7, "path": "tests/test_types.py", "score": 0.32556891441345215, "span_start": null, "span_end": null, "passage": "assert f == f.model_copy()\n    copied_with_changes = f.model_copy()\n    copied_with_changes.password = SecretBytes(b'4321')\n    assert f != copied_with_changes\n\n\ndef test_secretbytes_equality():\n    a..."}, {"qid": "", "rank": 8, "path": "tests/test_deprecated.py", "score": 0.323047399520874, "span_start": null, "span_end": null, "passage": "(Extra keys: 'include')\",\n        '`include` is deprecated and does nothing It will be removed, use `exclude` instead',\n    ]\n    assert [w.message.message for w in all_warnings] == expected_warnings\n..."}, {"qid": "", "rank": 9, "path": "tests/test_types.py", "score": 0.3225615620613098, "span_start": null, "span_end": null, "passage": "assert f.value.__class__.__name__ == 'SecretDate'\n\n    # Assert str and repr are correct"}, {"qid": "", "rank": 10, "path": "tests/test_types.py", "score": 0.3125961422920227, "span_start": null, "span_end": null, "passage": "assert f.password.__class__.__name__ == 'SecretStr'\n    assert f.empty_password.__class__.__name__ == 'SecretStr'\n\n    # Assert str and repr are correct"}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_utils.py", "score": 0.3085669279098511, "span_start": null, "span_end": null, "passage": "We update the list if another one with the same name is set\n    (e.g model validator overridden in subclass)"}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.30111220479011536, "span_start": null, "span_end": null, "passage": "`model_name` is accepted for the purpose of producing useful error messages"}, {"qid": "", "rank": 13, "path": "tests/test_plugin_loader.py", "score": 0.2903452515602112, "span_start": null, "span_end": null, "passage": "import importlib.metadata as importlib_metadata\nimport os\nfrom unittest.mock import patch\n\nimport pytest\n\nimport pydantic.plugin._loader as loader\n\n\nclass EntryPoint:\n    def __init__(self, name, valu..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/fields.py", "score": 0.2901823818683624, "span_start": null, "span_end": null, "passage": "# TypeError: `discriminator_value` is unhashable"}, {"qid": "", "rank": 15, "path": "pydantic/v1/utils.py", "score": 0.28711462020874023, "span_start": null, "span_end": null, "passage": "We update the list if another one with the same name is set\n    (e.g root validator overridden in subclass)\n    \"\"\"\n    result: List[T] = []\n    result_names: List[str] = []\n    for v in input_list:\n ..."}, {"qid": "", "rank": 16, "path": "pydantic/mypy.py", "score": 0.2866528630256653, "span_start": null, "span_end": null, "passage": "if name in info.names:\n        # Get a nice unique name instead r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    # Add decorator for is_classm..."}, {"qid": "", "rank": 17, "path": "tests/test_types.py", "score": 0.2835964858531952, "span_start": null, "span_end": null, "passage": "assert str(f.password) == \"b'**********'\"\n    assert str(f.empty_password) == \"b''\"\n    assert repr(f.password) == \"SecretBytes(b'**********')\"\n    assert repr(f.empty_password) == \"SecretBytes(b'')\"\n..."}, {"qid": "", "rank": 18, "path": "tests/test_config.py", "score": 0.28313058614730835, "span_start": null, "span_end": null, "passage": "MyModel.model_config['title'] = 'MyTitle'\n        MyModel.model_config['frozen'] = True\n        assert 'str_to_lower' not in MyModel.model_config\n\n    def test_base_config_custom_init_signature(self):..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/mypy.py", "score": 0.28145718574523926, "span_start": null, "span_end": null, "passage": "\"\"\"\n        ctx = self._ctx\n        info = ctx.cls.info\n        for field in fields:\n            sym_node = info.names.get(field.name)\n            if sym_node is not None:\n                var = sym_no..."}, {"qid": "", "rank": 20, "path": "tests/test_utils.py", "score": 0.2724384665489197, "span_start": null, "span_end": null, "passage": "Given varied output, this test verifies that the content of the output is as expected,\n    Rather than doing robust formatting testing"}], "latency_ms": 3.431081771850586, "gold_paths": ["tests/test_aliases.py"]}
{"qid": "lens_main_func_4d7bef62", "query": "Add job for auto labeling (#9367)", "results": [{"qid": "", "rank": 1, "path": "pydantic/fields.py", "score": 0.31013253331184387, "span_start": null, "span_end": null, "passage": "\"\"\"\n        annotation = _typing_extra.eval_type_lenient(self.annotation, types_namespace)\n        self.annotation = _generics.replace_types(annotation, typevars_map)\n\n    def __repr_args__(self) -> R..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.30460408329963684, "span_start": null, "span_end": null, "passage": "\"\"\"\n    import annotated_types as at\n\n    from"}, {"qid": "", "rank": 3, "path": "pydantic/deprecated/decorator.py", "score": 0.2877272069454193, "span_start": null, "span_end": null, "passage": "@overload\ndef validate_arguments(func: 'AnyCallableT') -> 'AnyCallableT': .."}, {"qid": "", "rank": 4, "path": "pydantic/validate_call_decorator.py", "score": 0.2862851619720459, "span_start": null, "span_end": null, "passage": "\"\"\"Decorator for validating function calls.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport functools\nfrom typing import TYPE_CHECKING, Any, Callable, TypeVar, overload\n\nfrom ._internal..."}, {"qid": "", "rank": 5, "path": "pydantic/fields.py", "score": 0.28547871112823486, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if annotation is not None:\n            if _typing_extra.is_annotated(annotation):\n                first_arg, *extra_args = typing_extensions.get_args(annotation)\n                return fir..."}, {"qid": "", "rank": 6, "path": "tests/test_validators.py", "score": 0.2778692841529846, "span_start": null, "span_end": null, "passage": "This is why I've set the default to '' instead of None # But, I think this is a good thing, and I don't think we should try to support this"}, {"qid": "", "rank": 7, "path": "tests/test_json_schema.py", "score": 0.275290846824646, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class Model(BaseModel):\n        a: int = .. b: Annotated[int, 'placeholder'] = .. c: Annotated[int, Field()] = .."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_signature.py", "score": 0.2706291079521179, "span_start": null, "span_end": null, "passage": "Args:\n        param (Parameter): The parameter\n\n    Returns:\n        Parameter: The custom processed parameter\n    \"\"\"\n    from ..fields import FieldInfo\n\n    param_default = param.default\n    if isin..."}, {"qid": "", "rank": 9, "path": "pydantic/validate_call_decorator.py", "score": 0.2589065432548523, "span_start": null, "span_end": null, "passage": "\"\"\"\n    local_ns = _typing_extra.parent_frame_namespace()\n\n    def validate(function: AnyCallableT) -> AnyCallableT:\n        if isinstance(function, (classmethod, staticmethod)):\n            name = ty..."}, {"qid": "", "rank": 10, "path": "pydantic/fields.py", "score": 0.2585197687149048, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if self.default_factory is None:\n            return _utils.smart_deepcopy(self.default)\n        elif call_default_factory:\n            return self.default_factory()\n        else:\n         ..."}, {"qid": "", "rank": 11, "path": "pydantic/types.py", "score": 0.25093498826026917, "span_start": null, "span_end": null, "passage": "Also provides a way to label a union case in error messages When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\n    should be used to identify tha..."}, {"qid": "", "rank": 12, "path": "pydantic/mypy.py", "score": 0.24879658222198486, "span_start": null, "span_end": null, "passage": "This should be performed in a later phase"}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_decorators.py", "score": 0.2466912567615509, "span_start": null, "span_end": null, "passage": "\"\"\"\n    sig = signature(unwrap_wrapped_function(function))\n    first = next(iter(sig.parameters.values()), None)\n    if first and first.name == 'self':\n        return True\n    return False\n\n\ndef ensur..."}, {"qid": "", "rank": 14, "path": "pydantic/experimental/pipeline.py", "score": 0.24480219185352325, "span_start": null, "span_end": null, "passage": "@overload\n    def constrain(\n        self: _Pipeline[_InT, _NewOutT], constraint: annotated_types.MultipleOf\n    ) -> _Pipeline[_InT, _NewOutT]: .. @overload\n    def constrain(\n        self: _Pipeline..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.24465325474739075, "span_start": null, "span_end": null, "passage": "Args:\n        annotations: An iterable of annotations Returns:\n        An iterable of expanded annotations"}, {"qid": "", "rank": 16, "path": "pydantic/fields.py", "score": 0.24354219436645508, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.default is PydanticUndefined and self.default_factory is None\n\n    def rebuild_annotation(self) -> Any:\n        \"\"\"Attempts to rebuild the original annotation for use in functi..."}, {"qid": "", "rank": 17, "path": "pydantic/fields.py", "score": 0.2423611879348755, "span_start": null, "span_end": null, "passage": "default: The default value of the field Returns:\n            A field object with the passed values \"\"\"\n        if annotation is default:\n            raise PydanticUserError(\n                'Error whe..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_typing_extra.py", "score": 0.23736044764518738, "span_start": null, "span_end": null, "passage": "base_globals, base_locals = base_locals, base_globals\n                for name, value in ann.items():\n                    if value is None:\n                        value = type(None)\n                 ..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/fields.py", "score": 0.23677510023117065, "span_start": null, "span_end": null, "passage": "Some arguments\n    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str`` :param default: since this is replacing the field\u2019s default, its first argument is used\n..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_typing_extra.py", "score": 0.23669229447841644, "span_start": null, "span_end": null, "passage": "This is often the same as obj.__annotations__, but it handles\n        forward references encoded as string literals, adds Optional[t] if a\n        default value equal to None is set and recursively re..."}], "latency_ms": 3.4117698669433594, "gold_paths": ["release/check_relnotes.py"]}
{"qid": "lens_main_func_cff0f373", "query": "Fix typing of `_frame_depth` (#9353)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generics.py", "score": 0.6199638843536377, "span_start": null, "span_end": null, "passage": "Args:\n        depth: The depth to get the frame Returns:\n        A tuple contains `module_name` and `called_globally` Raises:\n        RuntimeError: If the function is not called inside a function"}, {"qid": "", "rank": 2, "path": "pydantic/type_adapter.py", "score": 0.5044987201690674, "span_start": null, "span_end": null, "passage": "This is required for _parent_depth used for\n# ForwardRef resolution We may enter the TypeAdapter schema building via different TypeAdapter functions Hence, we\n# need to keep track of the frame depth r..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generics.py", "score": 0.47079551219940186, "span_start": null, "span_end": null, "passage": "\"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except Attribu..."}, {"qid": "", "rank": 4, "path": "pydantic/type_adapter.py", "score": 0.4601205885410309, "span_start": null, "span_end": null, "passage": "\"\"\"\n    local_ns = _typing_extra.parent_frame_namespace(parent_depth=parent_depth)\n    global_ns = sys._getframe(max(parent_depth - 1, 1)).f_globals.copy()\n    global_ns.update(local_ns or {})\n    gen..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_typing_extra.py", "score": 0.4506514072418213, "span_start": null, "span_end": null, "passage": "\"\"\"\n    frame = sys._getframe(parent_depth)\n    # if f_back is None, it's the global module namespace and we don't need to include it here\n    if frame.f_back is None:\n        return None\n    else:\n  ..."}, {"qid": "", "rank": 6, "path": "pydantic/type_adapter.py", "score": 0.4329243302345276, "span_start": null, "span_end": null, "passage": "note\n            The `_parent_depth` argument is named with an underscore to suggest its private nature and discourage use It may be deprecated in a minor version, so we only recommend using it if you..."}, {"qid": "", "rank": 7, "path": "pydantic/type_adapter.py", "score": 0.42850032448768616, "span_start": null, "span_end": null, "passage": "self._init_core_attrs(rebuild_mocks=False)\n\n    @contextmanager\n    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n        self._parent_depth += depth\n        try:\n            yield\n      ..."}, {"qid": "", "rank": 8, "path": "pydantic/main.py", "score": 0.42606663703918457, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not force and cls.__pydantic_complete__:\n            return None\n        else:\n            if '__pydantic_core_schema__' in cls.__dict__:\n                delattr(cls, '__pydantic_core_s..."}, {"qid": "", "rank": 9, "path": "pydantic/type_adapter.py", "score": 0.4193940758705139, "span_start": null, "span_end": null, "passage": "def _frame_depth(\n    depth: int,\n) -> Callable[[Callable[Concatenate[TypeAdapterT, P], R]], Callable[Concatenate[TypeAdapterT, P], R]]:\n    def wrapper(func: Callable[Concatenate[TypeAdapterT, P], R]..."}, {"qid": "", "rank": 10, "path": "pydantic/dataclasses.py", "score": 0.39917707443237305, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if not force and cls.__pydantic_complete__:\n        return None\n    else:\n        if _types_namespace is not None:\n            types_namespace: dict[str, Any] | None = _types_namespace.copy()\n..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.3899694085121155, "span_start": null, "span_end": null, "passage": "dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n    return dedent_source\n\n\ndef _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n    frame = inspect.currentframe()\n\n    whil..."}, {"qid": "", "rank": 12, "path": "pydantic/type_adapter.py", "score": 0.3710114359855652, "span_start": null, "span_end": null, "passage": "return config.get('defer_build', False) is True and 'type_adapter' in config.get(\n            'experimental_defer_build_mode', tuple()\n        )\n\n    @_frame_depth(1)\n    def validate_python(\n        ..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_dataclasses.py", "score": 0.3681008517742157, "span_start": null, "span_end": null, "passage": "Raises:\n        PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations"}, {"qid": "", "rank": 14, "path": "pydantic/type_adapter.py", "score": 0.3582375645637512, "span_start": null, "span_end": null, "passage": "On the other hand this function can be called with arbitrary objects,\n    including type aliases, where `__module__` (always `typing.py`) is not useful So instead we look at the globals in our parent ..."}, {"qid": "", "rank": 15, "path": "pydantic/type_adapter.py", "score": 0.35260242223739624, "span_start": null, "span_end": null, "passage": "strict: Whether to strictly check types context: Additional context to use during validation Returns:\n            The validated object \"\"\"\n        return self.validator.validate_strings(obj, strict=st..."}, {"qid": "", "rank": 16, "path": "pydantic/type_adapter.py", "score": 0.34972476959228516, "span_start": null, "span_end": null, "passage": "strict: Whether to strictly check types context: Additional context to use during validation Returns:\n            The validated object \"\"\"\n        return self.validator.validate_json(data, strict=stri..."}, {"qid": "", "rank": 17, "path": "pydantic/validate_call_decorator.py", "score": 0.3479773998260498, "span_start": null, "span_end": null, "passage": "\"\"\"\n    local_ns = _typing_extra.parent_frame_namespace()\n\n    def validate(function: AnyCallableT) -> AnyCallableT:\n        if isinstance(function, (classmethod, staticmethod)):\n            name = ty..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generics.py", "score": 0.3437100648880005, "span_start": null, "span_end": null, "passage": "\"\"\"\n    namespace: dict[str, Any] = {'__module__': origin.__module__}\n    bases = (origin,)\n    meta, ns, kwds = prepare_class(model_name, bases)\n    namespace.update(ns)\n    created_model = meta(\n   ..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/generics.py", "score": 0.3399238586425781, "span_start": null, "span_end": null, "passage": "model_name = cls.__concrete_name__(params)\n        validators = gather_all_validators(cls)\n\n        type_hints = get_all_type_hints(cls).items()\n        instance_type_hints = {k: v for k, v in type_hi..."}, {"qid": "", "rank": 20, "path": "pydantic/type_adapter.py", "score": 0.33927035331726074, "span_start": null, "span_end": null, "passage": "# This second overload is for unsupported special forms (such as Annotated, Union, etc.)\n    # Currently there is no way to type this correctly\n    # See https://github.com/python/typing/pull/1618\n   ..."}], "latency_ms": 3.444671630859375, "gold_paths": ["pydantic/type_adapter.py"]}
{"qid": "lens_main_func_37fa1bce", "query": "Provide missing generics for `classmethod` in `create_model` (#9338)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_model_construction.py", "score": 0.6577655076980591, "span_start": null, "span_end": null, "passage": "# It would be nice to remove this error and still have things behave as expected, it's just\n                            # challenging because we are using a custom `__class_getitem__` to parametrize g..."}, {"qid": "", "rank": 2, "path": "pydantic/v1/generics.py", "score": 0.6455573439598083, "span_start": null, "span_end": null, "passage": "_assigned_parameters = AssignedParameters()\n\n\nclass GenericModel(BaseModel):\n    __slots__ = ()\n    __concrete__: ClassVar[bool] = False\n\n    if TYPE_CHECKING:\n        # Putting this in a TYPE_CHECKIN..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/main.py", "score": 0.6374571323394775, "span_start": null, "span_end": null, "passage": "If it *hasn't* been created, we assume that the `__new__` call we're in the middle of is for\n# the `BaseModel` class, since that's defined immediately after the metaclass"}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_model_construction.py", "score": 0.6368465423583984, "span_start": null, "span_end": null, "passage": "Args:\n            cls_name: The name of the class to be created bases: The base classes of the class to be created namespace: The attribute dictionary of the class to be created __pydantic_generic_met..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_model_construction.py", "score": 0.628624677658081, "span_start": null, "span_end": null, "passage": "Ex:\n                        # class MyModel(RootModel, Generic[T]):\n                        #    root: T\n                        # Should instead just be:\n                        # class MyModel(RootM..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/generics.py", "score": 0.6228041648864746, "span_start": null, "span_end": null, "passage": "__parameters__: ClassVar[Tuple[TypeVarType, ...]]\n\n    # Setting the return type as Type[Any] instead of Type[BaseModel] prevents PyCharm warnings\n    def __class_getitem__(cls: Type[GenericModelT], p..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/generics.py", "score": 0.6157844066619873, "span_start": null, "span_end": null, "passage": "_prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...])..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/main.py", "score": 0.60999596118927, "span_start": null, "span_end": null, "passage": "added to the model\nUNTOUCHED_TYPES: Tuple[Any, ...] = (FunctionType,) + ANNOTATED_FIELD_UNTOUCHED_TYPES\n# Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we n..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_model_construction.py", "score": 0.6069015264511108, "span_start": null, "span_end": null, "passage": "This logic must be called after class has been created since validation functions must be bound\n    and `get_type_hints` requires a class object Args:\n        cls: BaseModel or dataclass cls_name: The..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/main.py", "score": 0.6010099053382874, "span_start": null, "span_end": null, "passage": "@overload\ndef create_model(\n    __model_name: str,\n    *,\n    __config__: Optional[Type[BaseConfig]] = None,\n    __base__: Union[Type['Model'], Tuple[Type['Model'], ...]],\n    __module__: str = __name..."}, {"qid": "", "rank": 11, "path": "pydantic/main.py", "score": 0.5990094542503357, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_model_construction.py", "score": 0.5971595048904419, "span_start": null, "span_end": null, "passage": "\"\"\"Private logic for creating models.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport builtins\nimport operator\nimport typing\nimport warnings\nimport weakref\nfrom abc import ABCMeta\nfrom ..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/generics.py", "score": 0.5949984788894653, "span_start": null, "span_end": null, "passage": "_generic_types_cache[_cache_key(params)] = created_model\n        if len(params) == 1:\n            _generic_types_cache[_cache_key(params[0])] = created_model\n\n        # Recursively walk class type hin..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_generics.py", "score": 0.5948049426078796, "span_start": null, "span_end": null, "passage": "Since BaseModel.__class_getitem__ does not produce a typing._GenericAlias, and the BaseModel generic info is\n    stored in the __pydantic_generic_metadata__ attribute, we need special handling here \"\"..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/main.py", "score": 0.5874077081680298, "span_start": null, "span_end": null, "passage": "ANNOTATED_FIELD_UNTOUCHED_TYPES: Tuple[Any, ...] = (property, type, classmethod, staticmethod)\n# When creating a `BaseModel` instance, we bypass all the methods, properties.."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.5851960182189941, "span_start": null, "span_end": null, "passage": "# _GENERIC_TYPES_CACHE = DeepChainMap(GenericTypesCache(), LimitedDict())\n\n_GENERIC_TYPES_CACHE = GenericTypesCache()\n\n\nclass PydanticGenericMetadata(typing_extensions.TypedDict):\n    origin: type[Bas..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/main.py", "score": 0.5845230221748352, "span_start": null, "span_end": null, "passage": ":param __model_name: name of the created model\n    :param __config__: config class to use for the new model\n    :param __base__: base class for the new model to inherit from\n    :param __module__: mod..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_core_utils.py", "score": 0.5825951099395752, "span_start": null, "span_end": null, "passage": "This `args_override` argument was added for the purpose of creating valid recursive references\n    when creating generic models without needing to create a concrete class"}, {"qid": "", "rank": 19, "path": "pydantic/main.py", "score": 0.5815331339836121, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n    def __class_getitem__(\n        cls, typevar_values: type[Any] | tuple[type[Any], ...]\n    ) -> type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n        cached = _generics.get..."}, {"qid": "", "rank": 20, "path": "pydantic/main.py", "score": 0.5739316344261169, "span_start": null, "span_end": null, "passage": "Given a generic class\n                `Model` with 2 type variables and a concrete model `Model[str, int]`,\n                the value `(str, int)` would be passed to `params` Returns:\n            Stri..."}], "latency_ms": 3.8194656372070312, "gold_paths": ["pydantic/main.py"]}
{"qid": "lens_main_func_c4d2edc4", "query": "Fix Outputted Model JSON Schema for Sequence type (#9303)", "results": [{"qid": "", "rank": 1, "path": "pydantic/json_schema.py", "score": 0.653602659702301, "span_start": null, "span_end": null, "passage": "please report it'\n    return schema_generator_instance.generate(cls.__pydantic_core_schema__, mode=mode)\n\n\ndef models_json_schema(\n    models: Sequence[tuple[type[BaseModel] | type[PydanticDataclass],..."}, {"qid": "", "rank": 2, "path": "pydantic/main.py", "score": 0.6359262466430664, "span_start": null, "span_end": null, "passage": "Since this gets called by `BaseModel.model_json_schema` you can override the\n                `schema_generator` argument to that function to change JSON schema generation globally\n                for ..."}, {"qid": "", "rank": 3, "path": "pydantic/json_schema.py", "score": 0.6282525658607483, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # TODO: Need to read the default value off of model config or whatever\n        use_strict = schema.get('strict', False)  # TODO: replace this default False\n        # If your JSON schema fa..."}, {"qid": "", "rank": 4, "path": "pydantic/config.py", "score": 0.6177142858505249, "span_start": null, "span_end": null, "passage": "model_config = ConfigDict(json_schema_mode_override='validation')\n\n    print(ForceInputModel.model_json_schema(mode='serialization'))\n    '''\n    {\n        'properties': {\n            'a': {\n         ..."}, {"qid": "", "rank": 5, "path": "tests/test_main.py", "score": 0.607314944267273, "span_start": null, "span_end": null, "passage": "The argument strict=True\n    # in model_validate_json method is not overwriting the one set with ConfigDict(strict=False)\n    # for sequence like types"}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.5978612899780273, "span_start": null, "span_end": null, "passage": "Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 7, "path": "pydantic/json_schema.py", "score": 0.5959866046905518, "span_start": null, "span_end": null, "passage": "Args:\n                schema_or_field: The core schema to generate a JSON schema from Returns:\n                The generated JSON schema Raises:\n                TypeError: If an unexpected schema type..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.5811495184898376, "span_start": null, "span_end": null, "passage": "pprint(Model.model_json_schema())\n            '''\n            {\n                'properties': {\n                    'a': {\n                        'anyOf': [\n                            {'type': 'inte..."}, {"qid": "", "rank": 9, "path": "pydantic/main.py", "score": 0.5758081078529358, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.__pydantic_serializer__.to_json(\n            self,\n            indent=indent,\n            include=include,\n            exclude=exclude,\n            context=context,\n           ..."}, {"qid": "", "rank": 10, "path": "pydantic/main.py", "score": 0.5752447247505188, "span_start": null, "span_end": null, "passage": "Returns:\n            A JSON string representation of the model"}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.5741750001907349, "span_start": null, "span_end": null, "passage": "Args:\n        models: A sequence of tuples of the form (model, mode) by_alias: Whether field aliases should be used as keys in the generated JSON Schema title: The title of the generated JSON Schema d..."}, {"qid": "", "rank": 12, "path": "pydantic/json_schema.py", "score": 0.5655065774917603, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.generate_inner(schema['schema'])\n\n    def model_field_schema(self, schema: core_schema.ModelField) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema ..."}, {"qid": "", "rank": 13, "path": "pydantic/type_adapter.py", "score": 0.561097264289856, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.serializer.to_json(\n            instance,\n            indent=indent,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclud..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.5587049722671509, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.generate_inner(schema['return_schema'])\n\n    def model_schema(self, schema: core_schema.ModelSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schem..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.5477169156074524, "span_start": null, "span_end": null, "passage": "keys of the \"definitions\" object that will eventually go into the JSON schema\n#       * by default, these look like \"MyModel\", though may change in the presence of collisions\n#       * eventually, we ..."}, {"qid": "", "rank": 16, "path": "pydantic/main.py", "score": 0.5417482852935791, "span_start": null, "span_end": null, "passage": "Args:\n            by_alias: Whether to use attribute aliases or not ref_template: The reference template schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n    ..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_validators.py", "score": 0.5415164828300476, "span_start": null, "span_end": null, "passage": "# Additionally, we should be able to remove one of either this validator or the\n    # SequenceValidator in _std_types_schema.py (preferably this one, while porting over some logic) # Effectively, a re..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.535441517829895, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.535441517829895, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 20, "path": "pydantic/json_schema.py", "score": 0.535441517829895, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}], "latency_ms": 4.201412200927734, "gold_paths": ["pydantic/_internal/_generate_schema.py", "pydantic/_internal/_known_annotated_metadata.py", "tests/test_json_schema.py"]}
{"qid": "lens_main_func_6b992fda", "query": "\ud83d\udc65 Update Pydantic People (#9326)", "results": [{"qid": "", "rank": 1, "path": "tests/test_json_schema.py", "score": 0.5620943903923035, "span_start": null, "span_end": null, "passage": "This was reported as broken in https://github.com/pydantic/pydantic/issues/8689, which was\n    originally caused by the change made in https://github.com/pydantic/pydantic/pull/8583, which has\n    sin..."}, {"qid": "", "rank": 2, "path": "tests/test_forward_ref.py", "score": 0.555557370185852, "span_start": null, "span_end": null, "passage": "# At the same time, `PydanticRecursiveRef.__or__` means that the second `|` works normally,\n    # which actually triggered a bug in the backport that needed fixing"}, {"qid": "", "rank": 3, "path": "pydantic/v1/config.py", "score": 0.5388617515563965, "span_start": null, "span_end": null, "passage": "# Pydantic v2 doesn't depend on Cython at all"}, {"qid": "", "rank": 4, "path": ".github/actions/people/people.py", "score": 0.5050656199455261, "span_start": null, "span_end": null, "passage": "\"\"\"Use the github API to get lists of people who have contributed in various ways to Pydantic This logic is inspired by that of @tiangolo's\n[FastAPI people script](https://github.com/tiangolo/fastapi/..."}, {"qid": "", "rank": 5, "path": "tests/test_forward_ref.py", "score": 0.5045602917671204, "span_start": null, "span_end": null, "passage": "# The presence of the `__pydantic_complete__` is a good indicator of this"}, {"qid": "", "rank": 6, "path": "tests/test_forward_ref.py", "score": 0.5045602917671204, "span_start": null, "span_end": null, "passage": "# The presence of the `__pydantic_complete__` is a good indicator of this"}, {"qid": "", "rank": 7, "path": "pydantic/warnings.py", "score": 0.5000889897346497, "span_start": null, "span_end": null, "passage": "This warning is raised when using experimental functionality in Pydantic It is raised to warn users that the functionality may change or be removed in future versions of Pydantic \"\"\""}, {"qid": "", "rank": 8, "path": "tests/test_type_hints.py", "score": 0.4966973662376404, "span_start": null, "span_end": null, "passage": "pydantic.warnings.PydanticDeprecatedSince20: The `__fields__` attribute is deprecated,\n#      use `model_fields` instead"}, {"qid": "", "rank": 9, "path": "pydantic/experimental/__init__.py", "score": 0.4897581934928894, "span_start": null, "span_end": null, "passage": "\"\"\"The \"experimental\" module of pydantic contains potential new features that are subject to change.\"\"\"\n\nimport warnings\n\nfrom pydantic.warnings import PydanticExperimentalWarning\n\nwarnings.warn(\n    ..."}, {"qid": "", "rank": 10, "path": "pydantic/fields.py", "score": 0.47750839591026306, "span_start": null, "span_end": null, "passage": "use `frozen` instead', DeprecationWarning)\n        if allow_mutation is False:\n            frozen = True\n\n    regex = extra.pop('regex', None)  # type: ignore\n    if regex is not None:\n        raise P..."}, {"qid": "", "rank": 11, "path": "tests/mypy/outputs/1.0.1/mypy-plugin_ini/custom_constructor.py", "score": 0.4753395915031433, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    id: int\n    name: str\n    birth_year: int\n\n    def __init__(self, id: int) -> None:\n# MYPY: note: \"Person\" defined here\n        super().__..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_typing_extra.py", "score": 0.4735567569732666, "span_start": null, "span_end": null, "passage": "The `module` argument is omitted as it breaks <3.9.8, =3.10.0 and isn't used in the calls below See https://github.com/python/cpython/pull/28560 for some background The backport happened on 3.9.8, see..."}, {"qid": "", "rank": 13, "path": "pydantic/version.py", "score": 0.4727907180786133, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return '.'.join(VERSION.split('.')[:2])\n\n\ndef version_info() -> str:\n    \"\"\"Return complete version information for Pydantic and its dependencies.\"\"\"\n    import importlib.metadata as importlib..."}, {"qid": "", "rank": 14, "path": "pydantic/errors.py", "score": 0.4705672562122345, "span_start": null, "span_end": null, "passage": "Attributes:\n        message: A message describing the error code: An optional error code from PydanticErrorCodes enum"}, {"qid": "", "rank": 15, "path": "pydantic/errors.py", "score": 0.46576061844825745, "span_start": null, "span_end": null, "passage": "# 'u' refers to \"user errors\" - e.g errors caused by developers using pydantic, as opposed to validation errors"}, {"qid": "", "rank": 16, "path": "pydantic/errors.py", "score": 0.45929738879203796, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version imp..."}, {"qid": "", "rank": 17, "path": "tests/mypy/modules/strict_equality.py", "score": 0.45869603753089905, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\nprint(user.username == int('1'))\nprint(user.username == 'test')"}, {"qid": "", "rank": 18, "path": "pydantic/version.py", "score": 0.45653218030929565, "span_start": null, "span_end": null, "passage": "\"\"\"The `version` module holds the version information for Pydantic.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\n__all__ = 'VERSION', 'version_info'\n\nVERSION = '2.8.0'\n\"\"\"The version of Pyd..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4560169577598572, "span_start": null, "span_end": null, "passage": "This is not a limitation of pydantic_core, but if we try to handle\n        # this, the inference logic gets complicated very quickly, and could result in confusing\n        # debugging challenges for u..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.45579779148101807, "span_start": null, "span_end": null, "passage": "Returns:\n        A wrapped V2 style field validator Raises:\n        PydanticUserError: If the signature is not supported or the parameters are\n            not available in Pydantic V2"}], "latency_ms": 4.153013229370117, "gold_paths": [".github/actions/people/people.py"]}
{"qid": "lens_main_func_73d10494", "query": "adds test case for unexpected discriminated union behavior (#9236)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.6120661497116089, "span_start": null, "span_end": null, "passage": "# However, it still may make sense to apply the discriminator to this schema,\n            # as a way to get discriminated-union-style error messages, so we allow this here"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5511000156402588, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The input schema Returns:\n            The new core schema Raises:\n            TypeError:\n                - If `discriminator` is used with invalid union variant - If `discrim..."}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.5468885898590088, "span_start": null, "span_end": null, "passage": "This allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,\n    but without needing to have a single shared field across all the union choices This also makes i..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generics.py", "score": 0.5466331243515015, "span_start": null, "span_end": null, "passage": "Because we parse items as the first Union type that is successful, we get slightly more consistent behavior\n    if we make an effort to distinguish the ordering of items in a union It would be best if..."}, {"qid": "", "rank": 5, "path": "pydantic/types.py", "score": 0.5423556566238403, "span_start": null, "span_end": null, "passage": "Consider this example, which is much more performant with the use of `Discriminator` and thus a `TaggedUnion`\n    than it would be as a normal `Union`"}, {"qid": "", "rank": 6, "path": "tests/test_discriminated_union.py", "score": 0.5332624912261963, "span_start": null, "span_end": null, "passage": "Issue: https://github.com/pydantic/pydantic/issues/9235'\n)\ndef test_discriminated_union_model_dump_with_nested_class():\n    class SomeEnum(str, Enum):\n        CAT = 'cat'\n        DOG = 'dog'\n\n    clas..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/typing.py", "score": 0.5284310579299927, "span_start": null, "span_end": null, "passage": "For unions, basic simplifications used by Union constructor are performed"}, {"qid": "", "rank": 8, "path": "tests/test_edge_cases.py", "score": 0.5172140598297119, "span_start": null, "span_end": null, "passage": "m = Model(v='s')\n    assert m.v == 's'\n\n    m = Model(v=b'b')\n    assert m.v == b'b'\n\n    m = Model(v=None)\n    assert m.v is None\n\n\ndef test_union_int_str():\n    class Model(BaseModel):\n        v: Un..."}, {"qid": "", "rank": 9, "path": "pydantic/types.py", "score": 0.5068960189819336, "span_start": null, "span_end": null, "passage": "[Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    tag: str\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n   ..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5016657114028931, "span_start": null, "span_end": null, "passage": "PydanticUserError:\n            - If a model in union doesn't have a discriminator field - If discriminator field has a non-string alias - If discriminator fields have different aliases - If discrimina..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generics.py", "score": 0.49760979413986206, "span_start": null, "span_end": null, "passage": "Thanks to caching internal to the `typing` module, it is not possible to distinguish between\n    List[Union[int, float]] and List[Union[float, int]] (and similarly for other \"parent\" origins besides L..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.49110060930252075, "span_start": null, "span_end": null, "passage": "\"\"\"\n    from ..types import Discriminator\n\n    if isinstance(discriminator, Discriminator):\n        if isinstance(discriminator.discriminator, str):\n            discriminator = discriminator.discrimin..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.4873187243938446, "span_start": null, "span_end": null, "passage": "[Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    discriminator: str | Callable[[Any], Hashable]\n    \"\"\"The callable or field name for discriminating the type in a tagged..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4870915412902832, "span_start": null, "span_end": null, "passage": "Here, \"handling\" entails:\n        * Coalescing nested unions and compatible tagged-unions\n        * Tracking the presence of 'none' and 'nullable' schemas occurring as choices\n        * Validating tha..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.47740864753723145, "span_start": null, "span_end": null, "passage": "self._discriminator_alias: str | None = None\n\n        # `_should_be_nullable` indicates whether the converted union has `None` as an allowed value # If `None` is an acceptable value of the (possibly-w..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4756963849067688, "span_start": null, "span_end": null, "passage": "This is done by:\n    * Validating that the input schema is compatible with the provided discriminator\n    * Introspecting the schema to determine which discriminator values should map to which union c..."}, {"qid": "", "rank": 17, "path": "tests/test_discriminated_union.py", "score": 0.46973538398742676, "span_start": null, "span_end": null, "passage": "import re\nimport sys\nfrom enum import Enum, IntEnum\nfrom types import SimpleNamespace\nfrom typing import Any, Callable, Generic, List, Optional, Sequence, TypeVar, Union\n\nimport pytest\nfrom dirty_equa..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.46630269289016724, "span_start": null, "span_end": null, "passage": "#\n        # Rather than trying to do the most powerful inference possible, I think we should eventually\n        # expose a way to more-manually control the way the TaggedUnionSchema is constructed thr..."}, {"qid": "", "rank": 19, "path": "pydantic/types.py", "score": 0.4634709060192108, "span_start": null, "span_end": null, "passage": "Also provides a way to label a union case in error messages When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\n    should be used to identify tha..."}, {"qid": "", "rank": 20, "path": "pydantic/deprecated/class_validators.py", "score": 0.45731914043426514, "span_start": null, "span_end": null, "passage": "V1Validator = Union[\n        _OnlyValueValidatorClsMethod,\n        _V1ValidatorWithValuesClsMethod,\n        _V1ValidatorWithValuesKwOnlyClsMethod,\n        _V1ValidatorWithKwargsClsMethod,\n        _V1V..."}], "latency_ms": 3.8106441497802734, "gold_paths": ["tests/test_discriminated_union.py"]}
{"qid": "lens_main_func_82e46640", "query": "Fix model json schema with config types (#9287)", "results": [{"qid": "", "rank": 1, "path": "pydantic/json_schema.py", "score": 0.70628821849823, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # TODO: Need to read the default value off of model config or whatever\n        use_strict = schema.get('strict', False)  # TODO: replace this default False\n        # If your JSON schema fa..."}, {"qid": "", "rank": 2, "path": "pydantic/main.py", "score": 0.6674149036407471, "span_start": null, "span_end": null, "passage": "Since this gets called by `BaseModel.model_json_schema` you can override the\n                `schema_generator` argument to that function to change JSON schema generation globally\n                for ..."}, {"qid": "", "rank": 3, "path": "pydantic/config.py", "score": 0.6532210111618042, "span_start": null, "span_end": null, "passage": "model_config = ConfigDict(json_schema_mode_override='validation')\n\n    print(ForceInputModel.model_json_schema(mode='serialization'))\n    '''\n    {\n        'properties': {\n            'a': {\n         ..."}, {"qid": "", "rank": 4, "path": "tests/test_main.py", "score": 0.6512774229049683, "span_start": null, "span_end": null, "passage": "The argument strict=True\n    # in model_validate_json method is not overwriting the one set with ConfigDict(strict=False)\n    # for sequence like types"}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.6246228218078613, "span_start": null, "span_end": null, "passage": "Args:\n                schema_or_field: The core schema to generate a JSON schema from Returns:\n                The generated JSON schema Raises:\n                TypeError: If an unexpected schema type..."}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.6175637245178223, "span_start": null, "span_end": null, "passage": "If `mode` is set this will only apply to that schema generation mode, allowing you\n    to set different json schemas for validation and serialization"}, {"qid": "", "rank": 7, "path": "pydantic/json_schema.py", "score": 0.6136972308158875, "span_start": null, "span_end": null, "passage": "keys of the \"definitions\" object that will eventually go into the JSON schema\n#       * by default, these look like \"MyModel\", though may change in the presence of collisions\n#       * eventually, we ..."}, {"qid": "", "rank": 8, "path": "pydantic/main.py", "score": 0.6077037453651428, "span_start": null, "span_end": null, "passage": "Args:\n            by_alias: Whether to use attribute aliases or not ref_template: The reference template schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n    ..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.6059540510177612, "span_start": null, "span_end": null, "passage": "By specifying a `json_schema_mode_override` though, this prevents the conflict between\n    the validation and serialization schemas (since both will use the specified schema), and so prevents the suff..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.6030687689781189, "span_start": null, "span_end": null, "passage": "Args:\n        models: A sequence of tuples of the form (model, mode) by_alias: Whether field aliases should be used as keys in the generated JSON Schema title: The title of the generated JSON Schema d..."}, {"qid": "", "rank": 11, "path": "tests/test_deprecated.py", "score": 0.6014280319213867, "span_start": null, "span_end": null, "passage": "Use `json_schema_extra` instead"}, {"qid": "", "rank": 12, "path": "pydantic/config.py", "score": 0.5995097160339355, "span_start": null, "span_end": null, "passage": "Defaults to `True`.\"\"\"\n\n    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n    \"\"\"A dict or callable to provide extra JSON schema properties Defaults to `None`.\"\"\"\n\n    json_encoders: di..."}, {"qid": "", "rank": 13, "path": "pydantic/json_schema.py", "score": 0.5967352390289307, "span_start": null, "span_end": null, "passage": "pprint(Model.model_json_schema())\n            '''\n            {\n                'properties': {\n                    'a': {\n                        'anyOf': [\n                            {'type': 'inte..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.5911175608634949, "span_start": null, "span_end": null, "passage": "This provides a way to set a JSON schema for types that would otherwise raise errors when producing a JSON schema,\n    such as Callable, or types that have an is-instance core schema, without needing ..."}, {"qid": "", "rank": 15, "path": "tests/test_fastapi_json_schema.py", "score": 0.5888124704360962, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def handle_invalid_for_json_schema(self, schema: CoreSchemaOrField, error_info: str) -> JsonSchemaValue:\n        # NOTE: I think it may be a good idea to rework this method to either not use ..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.5885541439056396, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n\n# ##### JSON Schema Generation #####\nDEFAULT_REF_TEMPLATE = '#/$defs/{model}'\n\"\"\"The default format string used to generate reference names.\"\"\"\n\n# There are three types of references relevant to..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.5877085328102112, "span_start": null, "span_end": null, "passage": "Examples should be a map of example names (strings)\n    to example values (any valid JSON) If `mode` is set this will only apply to that schema generation mode,\n    allowing you to add different examp..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/validators.py", "score": 0.5861608386039734, "span_start": null, "span_end": null, "passage": "The value provided for a ``const`` field must be equal to the default value\n    of the field This is to support the keyword of the same name in JSON\n    Schema"}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.5821210145950317, "span_start": null, "span_end": null, "passage": "please report it'\n    return schema_generator_instance.generate(cls.__pydantic_core_schema__, mode=mode)\n\n\ndef models_json_schema(\n    models: Sequence[tuple[type[BaseModel] | type[PydanticDataclass],..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5784330368041992, "span_start": null, "span_end": null, "passage": "Args:\n        schema_or_field: The schema data to generate a JSON schema from handler: The `GetCoreSchemaHandler` instance cls: The model-like class title: The title to set for the model's schema, def..."}], "latency_ms": 3.724813461303711, "gold_paths": ["pydantic/json_schema.py", "tests/test_json_schema.py"]}
{"qid": "lens_main_func_77b0e1cc", "query": "Address case where model_construct on a class which defines model_post_init fails with AttributeError: __pydantic_private__ when subsequently model_copy'd (#9168)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_model_construction.py", "score": 0.7105050086975098, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if getattr(self, '__pydantic_private__', None) is None:\n        pydantic_private = {}\n        for name, private_attr in self.__private_attributes__.items():\n            default = private_attr...."}, {"qid": "", "rank": 2, "path": "pydantic/main.py", "score": 0.6709030866622925, "span_start": null, "span_end": null, "passage": "__pydantic_post_init__: The name of the post-init method for the model, if defined __pydantic_root_model__: Whether the model is a `RootModel` __pydantic_serializer__: The pydantic-core SchemaSerializ..."}, {"qid": "", "rank": 3, "path": "pydantic/config.py", "score": 0.6605826616287231, "span_start": null, "span_end": null, "passage": "Pydantic prevents collisions between model attributes and `BaseModel`'s own methods by\n    namespacing them with the prefix `model_` ```py\n    import warnings\n\n    from pydantic import BaseModel\n\n    ..."}, {"qid": "", "rank": 4, "path": "pydantic/config.py", "score": 0.6603845357894897, "span_start": null, "span_end": null, "passage": "from ._internal._utils import is_model_class\n\n        if is_model_class(class_):\n            raise PydanticUserError(\n                f'Cannot use `with_config` on {class_.__name__} as it is a Pydanti..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_model_construction.py", "score": 0.659365177154541, "span_start": null, "span_end": null, "passage": "#     In the case that a classvar with a leading-'_' is defined via a ForwardRef (e.g., when using\n        #     `__future__.annotations`), we want to remove the private attribute which was detected _..."}, {"qid": "", "rank": 6, "path": "tests/test_main.py", "score": 0.6529430747032166, "span_start": null, "span_end": null, "passage": "The method then expects `BaseModel.__pydantic_extra__` isn't `None` Both this actions happen when\n    `model_config.extra` is set to `True` However, this behavior could be accidentally broken in a sub..."}, {"qid": "", "rank": 7, "path": "pydantic/fields.py", "score": 0.6513837575912476, "span_start": null, "span_end": null, "passage": "init: Whether the attribute should be included in the constructor of the dataclass Always `False` Returns:\n        An instance of [`ModelPrivateAttr`][pydantic.fields.ModelPrivateAttr] class Raises:\n ..."}, {"qid": "", "rank": 8, "path": "pydantic/main.py", "score": 0.6494677066802979, "span_start": null, "span_end": null, "passage": "This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n        and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n        `type...."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.6468966007232666, "span_start": null, "span_end": null, "passage": "'''\n    ```\n\n    While Pydantic will only emit a warning when an item is in a protected namespace but does not actually have a collision,\n    an error _is_ raised if there is an actual collision with ..."}, {"qid": "", "rank": 10, "path": "pydantic/root_model.py", "score": 0.6449447870254517, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __pydantic_root_model__ = True\n    __pydantic_private__ = None\n    __pydantic_extra__ = None\n\n    root: RootModelRootType\n\n    def __init_subclass__(cls, **kwargs):\n        extra = cls.model_..."}, {"qid": "", "rank": 11, "path": "pydantic/main.py", "score": 0.6405792832374573, "span_start": null, "span_end": null, "passage": "(This is due to the way `ModelMetaclass.__new__` works.)\n\n            Args:\n                **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n            Note:\n      ..."}, {"qid": "", "rank": 12, "path": "pydantic/main.py", "score": 0.6394635438919067, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.__pydantic_fields_set__\n\n    @classmethod\n    def model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -> Self:  # noqa: C901\n        \"\"\"Creates a new insta..."}, {"qid": "", "rank": 13, "path": "pydantic/main.py", "score": 0.6370452642440796, "span_start": null, "span_end": null, "passage": "Attributes:\n        __class_vars__: The names of classvars defined on the model __private_attributes__: Metadata about the private attributes of the model __signature__: The signature for instantiatin..."}, {"qid": "", "rank": 14, "path": "pydantic/dataclasses.py", "score": 0.6355175971984863, "span_start": null, "span_end": null, "passage": "\"\"\"\n        from ._internal._utils import is_model_class\n\n        if is_model_class(cls):\n            raise PydanticUserError(\n                f'Cannot create a Pydantic dataclass from {cls.__name__} ..."}, {"qid": "", "rank": 15, "path": "pydantic/main.py", "score": 0.630206286907196, "span_start": null, "span_end": null, "passage": "Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n        validated to form a valid model `self` is explicitly positional-only to allow `self` as a field name"}, {"qid": "", "rank": 16, "path": "pydantic/fields.py", "score": 0.6221676468849182, "span_start": null, "span_end": null, "passage": "Private attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner Private attributes are stored in `__private_attributes__` on the model Args:\n        d..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_model_construction.py", "score": 0.6216487884521484, "span_start": null, "span_end": null, "passage": "if bases:\n            base_field_names, class_vars, base_private_attributes = mcs._collect_bases_data(bases)\n\n            config_wrapper = ConfigWrapper.for_model(bases, namespace, kwargs)\n           ..."}, {"qid": "", "rank": 18, "path": "pydantic/main.py", "score": 0.6213722229003906, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n    @classmethod\n    def model_rebuild(\n        cls,\n        *,\n        force: bool = False,\n        raise_errors: bool = True,\n        _parent_namespace_depth: int = 2,\n        _typ..."}, {"qid": "", "rank": 19, "path": "tests/test_type_hints.py", "score": 0.6201028823852539, "span_start": null, "span_end": null, "passage": "pydantic.warnings.PydanticDeprecatedSince20: The `__fields__` attribute is deprecated,\n#      use `model_fields` instead"}, {"qid": "", "rank": 20, "path": "tests/test_main.py", "score": 0.6186145544052124, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    class BrokenExtraBaseModel(BaseModel):\n        def model_post_init(self, __context: Any) -> None:\n            super().model_post_init(__context)\n            object.__setattr__(self, '__pydant..."}], "latency_ms": 3.8008689880371094, "gold_paths": ["pydantic/main.py", "tests/test_main.py"]}
{"qid": "lens_main_func_6322b24d", "query": "Fix `strict` application to `function-after` with `use_enum_values` (#9279)", "results": [{"qid": "", "rank": 1, "path": "pydantic/config.py", "score": 0.5740549564361572, "span_start": null, "span_end": null, "passage": "note\n        If you have an `Optional[Enum]` value that you set a default for, you need to use `validate_default=True`\n        for said Field to ensure that the `use_enum_values` flag takes effect on ..."}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.4592733681201935, "span_start": null, "span_end": null, "passage": "```py\n    from enum import Enum\n    from typing import Optional\n\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class SomeEnum(Enum):\n        FOO = 'foo'\n        BAR = 'bar'\n        BAZ =..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/fields.py", "score": 0.45749685168266296, "span_start": null, "span_end": null, "passage": "Some arguments\n    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str`` :param default: since this is replacing the field\u2019s default, its first argument is used\n..."}, {"qid": "", "rank": 4, "path": "pydantic/config.py", "score": 0.4523352384567261, "span_start": null, "span_end": null, "passage": "print(user)\n    #> name='John Doe' age=20\n    ```\n\n    1 The field `'name'` has an alias `'full_name'` 2 The model is populated by the alias `'full_name'` 3 The model is populated by the field name `'..."}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.421419233083725, "span_start": null, "span_end": null, "passage": "\"\"\"\n        enum_type = schema['cls']\n        description = None if not enum_type.__doc__ else inspect.cleandoc(enum_type.__doc__)\n        if (\n            description == 'An enumeration.'\n        ): ..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/schema.py", "score": 0.4193190932273865, "span_start": null, "span_end": null, "passage": "'enum': [item.value for item in cast(Iterable[Enum], enum)],\n    }\n\n    add_field_type_to_schema(enum, schema_)\n\n    modify_schema = getattr(enum, '__modify_schema__', None)\n    if modify_schema:\n    ..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/main.py", "score": 0.41649091243743896, "span_start": null, "span_end": null, "passage": "import warnings\nfrom abc import ABCMeta\nfrom copy import deepcopy\nfrom enum import Enum\nfrom functools import partial\nfrom pathlib import Path\nfrom types import FunctionType, prepare_class, resolve_ba..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.41547513008117676, "span_start": null, "span_end": null, "passage": "# The most important use case for this is creating TypeVar bounds for generics that should\n        # be restricted to enums This is more consistent than it might seem at first, since you can only\n    ..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.40931200981140137, "span_start": null, "span_end": null, "passage": "value_ser_type = core_schema.plain_serializer_function_ser_schema(lambda x: x)\n\n    if cases:\n\n        def get_json_schema(schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:\n      ..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/fields.py", "score": 0.40816473960876465, "span_start": null, "span_end": null, "passage": "The `discriminator` is the name of this common field to shorten validation and improve generated schema\n    :param repr: show this field in the representation\n    :param **extra: any additional keywor..."}, {"qid": "", "rank": 11, "path": "pydantic/errors.py", "score": 0.4021261930465698, "span_start": null, "span_end": null, "passage": "Attributes:\n        message: A message describing the error code: An optional error code from PydanticErrorCodes enum"}, {"qid": "", "rank": 12, "path": "pydantic/v1/validators.py", "score": 0.39702337980270386, "span_start": null, "span_end": null, "passage": "Note: complete matching of argument type hints and return types is not performed\n    \"\"\"\n    if callable(v):\n        return v\n\n    raise errors.CallableError(value=v)\n\n\ndef enum_validator(v: Any) -> E..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_decorators.py", "score": 0.3953704535961151, "span_start": null, "span_end": null, "passage": "An error is raised if the function has an invalid signature Args:\n        serializer: The serializer function to check mode: The serializer mode, either 'plain' or 'wrap' Returns:\n        `info_arg` -..."}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.39077121019363403, "span_start": null, "span_end": null, "passage": "Defaults to `None` allow_inf_nan: Whether to allow infinity and NaN Defaults to `None`"}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.39075565338134766, "span_start": null, "span_end": null, "passage": "```py\nfrom pydantic import BaseModel, StrictInt, ValidationError\n\nclass StrictIntModel(BaseModel):\n    strict_int: StrictInt\n\ntry:\n    StrictIntModel(strict_int=3.14159)\nexcept ValidationError as e:\n ..."}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.3865129351615906, "span_start": null, "span_end": null, "passage": "Args:\n        strict: Whether to validate the value in strict mode Defaults to `None` gt: The value must be greater than this Defaults to `None` ge: The value must be greater than or equal to this Def..."}, {"qid": "", "rank": 17, "path": "pydantic/config.py", "score": 0.38597995042800903, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    ignored_types: tuple[type, ...]\n    \"\"\"A tuple of types that may occur as values of class attributes without annotations This is\n    typically used for custom descriptors (classes that behave..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_typing_extra.py", "score": 0.3796131908893585, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/schema.py", "score": 0.37129321694374084, "span_start": null, "span_end": null, "passage": "This is similar to the `model_process_schema` function, but applies to ``Enum`` objects \"\"\"\n    import inspect\n\n    schema_: Dict[str, Any] = {\n        'title': enum.__name__,\n        # Python assigns..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.3695871829986572, "span_start": null, "span_end": null, "passage": "\"\"\"\n    sig = signature(validator)\n\n    needs_values_kw = False\n\n    for param_num, (param_name, parameter) in enumerate(sig.parameters.items()):\n        if can_be_keyword(parameter) and param_name in..."}], "latency_ms": 3.615856170654297, "gold_paths": ["pydantic/_internal/_known_annotated_metadata.py", "tests/test_types.py"]}
{"qid": "lens_main_func_ae71183f", "query": "Fix `Secret` serialization schema, applicable for unions (#9240)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.6238575577735901, "span_start": null, "span_end": null, "passage": "# However, it still may make sense to apply the discriminator to this schema,\n            # as a way to get discriminated-union-style error messages, so we allow this here"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5500653386116028, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The input schema Returns:\n            The new core schema Raises:\n            TypeError:\n                - If `discriminator` is used with invalid union variant - If `discrim..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.546422004699707, "span_start": null, "span_end": null, "passage": "self._discriminator_alias: str | None = None\n\n        # `_should_be_nullable` indicates whether the converted union has `None` as an allowed value # If `None` is an acceptable value of the (possibly-w..."}, {"qid": "", "rank": 4, "path": "tests/test_discriminated_union.py", "score": 0.5288121700286865, "span_start": null, "span_end": null, "passage": "Even if the schema changes, the important\n    thing is that the core schema (and therefore JSON schema) produced has an actual discriminated union in it For more context, see: https://github.com/pydan..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5107210874557495, "span_start": null, "span_end": null, "passage": "This is done by:\n    * Validating that the input schema is compatible with the provided discriminator\n    * Introspecting the schema to determine which discriminator values should map to which union c..."}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.5085846185684204, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.5082271099090576, "span_start": null, "span_end": null, "passage": "[Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    tag: str\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n   ..."}, {"qid": "", "rank": 8, "path": "pydantic/types.py", "score": 0.5033538341522217, "span_start": null, "span_end": null, "passage": "# In this case, we do the same thing we do in\n            # `pydantic._internal._discriminated_union._ApplyInferredDiscriminator._apply_to_root`, namely,\n            # package the generated schema bac..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.5008041858673096, "span_start": null, "span_end": null, "passage": "By specifying a `json_schema_mode_override` though, this prevents the conflict between\n    the validation and serialization schemas (since both will use the specified schema), and so prevents the suff..."}, {"qid": "", "rank": 10, "path": "pydantic/functional_serializers.py", "score": 0.49814799427986145, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def dec(f: Callable[..., Any]) -> _decorators.PydanticDescriptorProxy[Any]:\n        dec_info = _decorators.ModelSerializerDecoratorInfo(mode=mode, return_type=return_type, when_used=when_used..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4977775812149048, "span_start": null, "span_end": null, "passage": "'\n            'Set `arbitrary_types_allowed=True` in the model_config to ignore this error'\n            ' or implement `__get_pydantic_core_schema__` on your type to fully support it.'\n            '\\n..."}, {"qid": "", "rank": 12, "path": "pydantic/functional_serializers.py", "score": 0.4925902485847473, "span_start": null, "span_end": null, "passage": "In particular, this means that when model subclasses are serialized, fields present in the subclass\n    but not in the original schema will be included"}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_generate_schema.py", "score": 0.48707225918769836, "span_start": null, "span_end": null, "passage": "See https://docs.pydantic.dev/{version_short()}/concepts/serialization/#custom-serializers for alternatives',\n            PydanticDeprecatedSince20,\n        )\n\n        # TODO: in theory we should chec..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.48479700088500977, "span_start": null, "span_end": null, "passage": "self._should_be_nullable = False\n\n        # `_is_nullable` is used to track if the final produced schema will definitely be nullable;\n        # we set it to True if the input schema is wrapped in a nu..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4833574891090393, "span_start": null, "span_end": null, "passage": "Args:\n        schema: The input schema discriminator: The name of the field which will serve as the discriminator definitions: A mapping of schema ref to schema Returns:\n        The new core schema Ra..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.48204246163368225, "span_start": null, "span_end": null, "passage": "Here, \"handling\" entails:\n        * Coalescing nested unions and compatible tagged-unions\n        * Tracking the presence of 'none' and 'nullable' schemas occurring as choices\n        * Validating tha..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.48045194149017334, "span_start": null, "span_end": null, "passage": "\"\"\"\n        null_schema = {'type': 'null'}\n        inner_json_schema = self.generate_inner(schema['schema'])\n\n        if inner_json_schema == null_schema:\n            return null_schema\n        else:\n..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4755723178386688, "span_start": null, "span_end": null, "passage": "import _core_utils\nfrom ._core_utils import (\n    CoreSchemaField,\n    collect_definitions,\n)\n\nif TYPE_CHECKING:\n    from ..types import Discriminator\n\nCORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_K..."}, {"qid": "", "rank": 19, "path": "pydantic/types.py", "score": 0.47422629594802856, "span_start": null, "span_end": null, "passage": "\"\n                    'Please use Secret[<type>], or subclass from Secret[<type>] instead.'\n                )\n\n        inner_schema = handler.generate_schema(inner_type)  # type: ignore\n\n        def v..."}, {"qid": "", "rank": 20, "path": "pydantic/json_schema.py", "score": 0.47377824783325195, "span_start": null, "span_end": null, "passage": "\"\"\"\n            # Generate the core-schema-type-specific bits of the schema generation:\n            json_schema: JsonSchemaValue | None = None\n            if self.mode == 'serialization' and 'serializ..."}], "latency_ms": 3.8471221923828125, "gold_paths": ["pydantic/types.py", "tests/test_types.py"]}
{"qid": "lens_main_func_6aab43e4", "query": "Fix `validation_alias` behavior with `model_construct` for `AliasChoices` and `AliasPath` (#9223)", "results": [{"qid": "", "rank": 1, "path": "tests/test_aliases.py", "score": 0.6179008483886719, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of'\n        ):\n\n            class Foo(BaseModel):\n                a: str\n\n                model_config = ConfigDict(alias_generator=AliasGenerator(**{alias_ki..."}, {"qid": "", "rank": 2, "path": "pydantic/aliases.py", "score": 0.6030170917510986, "span_start": null, "span_end": null, "passage": "\"\"\"\n        alias = self._generate_alias('alias', (str,), field_name)\n        validation_alias = self._generate_alias('validation_alias', (str, AliasChoices, AliasPath), field_name)\n        serializat..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_model_construction.py", "score": 0.5991255044937134, "span_start": null, "span_end": null, "passage": "# It would be nice to remove this error and still have things behave as expected, it's just\n                            # challenging because we are using a custom `__class_getitem__` to parametrize g..."}, {"qid": "", "rank": 4, "path": "pydantic/aliases.py", "score": 0.5907195806503296, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of `{allowed_types}`'\n                )\n        return alias\n\n    def generate_aliases(self, field_name: str) -> tuple[str | None, str | AliasPath | AliasChoi..."}, {"qid": "", "rank": 5, "path": "pydantic/fields.py", "score": 0.5900998115539551, "span_start": null, "span_end": null, "passage": "it should be `str`, `AliasChoices`, or `AliasPath`')\n\n    if serialization_alias in (_Unset, None) and isinstance(alias, str):\n        serialization_alias = alias\n\n    if validation_alias in (_Unset, ..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/mypy.py", "score": 0.5858480930328369, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not config.allow_population_by_field_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_..."}, {"qid": "", "rank": 7, "path": "pydantic/aliases.py", "score": 0.5858415961265564, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    alias: Callable[[str], str] | None = None\n    validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None\n    serialization_alias: Callable[[str], str] | None = None\n\n    ..."}, {"qid": "", "rank": 8, "path": "pydantic/mypy.py", "score": 0.5767202377319336, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not config.populate_by_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_extra:\n       ..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/main.py", "score": 0.5740426778793335, "span_start": null, "span_end": null, "passage": ":param __model_name: name of the created model\n    :param __config__: config class to use for the new model\n    :param __base__: base class for the new model to inherit from\n    :param __module__: mod..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_config.py", "score": 0.5696688890457153, "span_start": null, "span_end": null, "passage": "alias or first alias for \"field required\" errors) instead of field_names\n    # to construct error `loc`s, default `True`\n    loc_by_alias: bool\n    alias_generator: Callable[[str], str] | AliasGenerat..."}, {"qid": "", "rank": 11, "path": "tests/test_aliases.py", "score": 0.5682268738746643, "span_start": null, "span_end": null, "passage": "it should be `str`, `AliasChoices`, or `AliasPath`'\n    with pytest.raises(TypeError, match=m):\n\n        class Model(BaseModel):\n            x: str = Field(validation_alias=123)\n\n\ndef test_validation_..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5595231056213379, "span_start": null, "span_end": null, "passage": "TypeError:\n                - If `alias_generator` returns a disallowed type (must be str, AliasPath or AliasChoices) - If V1 style validator with `each_item=True` applied on a wrong field PydanticUser..."}, {"qid": "", "rank": 13, "path": "pydantic/aliases.py", "score": 0.558144211769104, "span_start": null, "span_end": null, "passage": "\"\"\"Support for alias configurations.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing import Any, Callable, Literal\n\nfrom pydantic_core import PydanticUndefined\n\nfrom ._internal ..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/main.py", "score": 0.5500069856643677, "span_start": null, "span_end": null, "passage": "\"\"\"\n    values = {}\n    errors = []\n    # input_data names, possibly alias\n    names_used = set()\n    # field names, never aliases\n    fields_set = set()\n    config = model.__config__\n    check_extra ..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.5464968681335449, "span_start": null, "span_end": null, "passage": "\"\"\"\n    from .main import BaseModel\n\n    schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n\n    if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockC..."}, {"qid": "", "rank": 16, "path": "tests/test_dataclasses.py", "score": 0.5464140176773071, "span_start": null, "span_end": null, "passage": "This is essentially a limitation of typing._GenericAlias"}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5459576845169067, "span_start": null, "span_end": null, "passage": "self.discriminator = discriminator\n\n        # `definitions` should contain a mapping of schema ref to schema for all schemas which might\n        # be referenced by some choice\n        self.definitions..."}, {"qid": "", "rank": 18, "path": "pydantic/main.py", "score": 0.5456754565238953, "span_start": null, "span_end": null, "passage": "\"\"\"\n        m = cls.__new__(cls)\n        fields_values: dict[str, Any] = {}\n        fields_set = set()\n\n        for name, field in cls.model_fields.items():\n            if field.alias is not None and ..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5295657515525818, "span_start": null, "span_end": null, "passage": "`model_name` is accepted for the purpose of producing useful error messages"}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.5261653661727905, "span_start": null, "span_end": null, "passage": "typ = self._api.analyze_simple_literal_type(stmt.rvalue, is_final=True)\n            if typ:\n                node.type = typ\n            else:\n                self._api.fail(\n                    'Need ..."}], "latency_ms": 3.8352012634277344, "gold_paths": ["pydantic/aliases.py", "pydantic/main.py", "tests/test_construction.py"]}
{"qid": "lens_main_func_60d77f02", "query": "Update `warnings` parameter for serialization utilities to allow raising a warning (#9166)", "results": [{"qid": "", "rank": 1, "path": "pydantic/json_schema.py", "score": 0.6833645105361938, "span_start": null, "span_end": null, "passage": "- 'non-serializable-default': A default value was skipped because it was not JSON-serializable detail: A string with additional details about the warning Returns:\n            The formatted warning mes..."}, {"qid": "", "rank": 2, "path": "pydantic/type_adapter.py", "score": 0.6359218955039978, "span_start": null, "span_end": null, "passage": "warnings: How to handle serialization errors False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationErro..."}, {"qid": "", "rank": 3, "path": "pydantic/warnings.py", "score": 0.5352908372879028, "span_start": null, "span_end": null, "passage": "This warning is raised when using experimental functionality in Pydantic It is raised to warn users that the functionality may change or be removed in future versions of Pydantic \"\"\""}, {"qid": "", "rank": 4, "path": "pydantic/main.py", "score": 0.5206717252731323, "span_start": null, "span_end": null, "passage": "exclude_none: Whether to exclude fields that have a value of `None` round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T] warnings: How to handle seriali..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_decorators.py", "score": 0.5182547569274902, "span_start": null, "span_end": null, "passage": "An error is raised if the function has an invalid signature Args:\n        serializer: The serializer function to check mode: The serializer mode, either 'plain' or 'wrap' Returns:\n        `info_arg` -..."}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.5173253417015076, "span_start": null, "span_end": null, "passage": "Args:\n        schema: The JSON schema to update updates: A dictionary of key-value pairs to set in the schema Returns:\n        The updated JSON schema \"\"\"\n    schema.update(updates)\n    return schema\n..."}, {"qid": "", "rank": 7, "path": "pydantic/type_adapter.py", "score": 0.501680850982666, "span_start": null, "span_end": null, "passage": "False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] serialize_as_any: Whether to serialize fie..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.5012872815132141, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n\nclass PydanticJsonSchemaWarning(UserWarning):\n    \"\"\"This class is used to emit warnings produced during JSON schema generation See the [`GenerateJsonSchema.emit_warning`][pydantic.json_schema.G..."}, {"qid": "", "rank": 9, "path": "tests/test_config.py", "score": 0.49659836292266846, "span_start": null, "span_end": null, "passage": "assert len(all_warnings) in [1, 2]\n        expected_warnings = [\n            'Support for class-based `config` is deprecated, use ConfigDict instead',\n        ]\n        if len(all_warnings) == 2:\n    ..."}, {"qid": "", "rank": 10, "path": "pydantic/main.py", "score": 0.4940936267375946, "span_start": null, "span_end": null, "passage": "False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] serialize_as_any: Whether to serialize fie..."}, {"qid": "", "rank": 11, "path": "pydantic/warnings.py", "score": 0.4889262616634369, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific warnings.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom .version import version_short\n\n__all__ = (\n    'PydanticDeprecatedSince20',\n    'PydanticDeprecationWarning'..."}, {"qid": "", "rank": 12, "path": "pydantic/json_schema.py", "score": 0.4876246452331543, "span_start": null, "span_end": null, "passage": "See\n            [Declaring a Dialect](https://json-schema.org/understanding-json-schema/reference/schema.html#id4)\n            in the JSON Schema documentation for more information about dialects igno..."}, {"qid": "", "rank": 13, "path": "pydantic/json_schema.py", "score": 0.47880005836486816, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    schema_dialect = 'https://json-schema.org/draft/2020-12/schema'\n\n    # `self.render_warning_message` will do nothing if its argument `kind` is in `ignored_warning_kinds`;\n    # this value can..."}, {"qid": "", "rank": 14, "path": "pydantic/functional_serializers.py", "score": 0.473768949508667, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def dec(f: Callable[..., Any]) -> _decorators.PydanticDescriptorProxy[Any]:\n        dec_info = _decorators.ModelSerializerDecoratorInfo(mode=mode, return_type=return_type, when_used=when_used..."}, {"qid": "", "rank": 15, "path": "pydantic/functional_serializers.py", "score": 0.4737456738948822, "span_start": null, "span_end": null, "passage": "Four signatures are supported:\n\n    - `(self, value: Any, info: FieldSerializationInfo)`\n    - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`\n    - `(value: Any..."}, {"qid": "", "rank": 16, "path": "pydantic/types.py", "score": 0.4709164500236511, "span_start": null, "span_end": null, "passage": "\"\n                    'Please use Secret[<type>], or subclass from Secret[<type>] instead.'\n                )\n\n        inner_schema = handler.generate_schema(inner_type)  # type: ignore\n\n        def v..."}, {"qid": "", "rank": 17, "path": "tests/test_warnings.py", "score": 0.4705057144165039, "span_start": null, "span_end": null, "passage": "Deprecated in Pydantic V2.1 to be removed in V3.0.'\n\n\ndef test_pydantic_deprecation_warning_2_0_migration_guide_link():\n    warning = PydanticDeprecationWarning('Warning message', since=(2, 0))\n\n    a..."}, {"qid": "", "rank": 18, "path": "pydantic/main.py", "score": 0.46985921263694763, "span_start": null, "span_end": null, "passage": "exclude_unset: Whether to exclude fields that have not been explicitly set exclude_defaults: Whether to exclude fields that are set to their default value exclude_none: Whether to exclude fields that ..."}, {"qid": "", "rank": 19, "path": "tests/test_serialize.py", "score": 0.4660811126232147, "span_start": null, "span_end": null, "passage": "\"\"\"\nNew tests for v2 of serialization logic"}, {"qid": "", "rank": 20, "path": "pydantic/functional_serializers.py", "score": 0.46569859981536865, "span_start": null, "span_end": null, "passage": "\"\"\"\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class SerializeAsAny:  # noqa: D101\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item,..."}], "latency_ms": 3.6683082580566406, "gold_paths": ["pydantic/main.py", "pydantic/root_model.py", "pydantic/type_adapter.py"]}
{"qid": "lens_main_func_99821e95", "query": "Add support for field level number to str coercion option (#9137)", "results": [{"qid": "", "rank": 1, "path": "pydantic/fields.py", "score": 0.6083093285560608, "span_start": null, "span_end": null, "passage": "(Only applies to dataclasses.)\n        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode) strict: If `True`, strict validation is applied..."}, {"qid": "", "rank": 2, "path": "pydantic/functional_validators.py", "score": 0.4772683084011078, "span_start": null, "span_end": null, "passage": "@overload\ndef field_validator(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal['wrap'],\n    check_fields: bool | None = ...,\n) -> Callable[[_V2WrapValidatorType], _V2WrapValidatorType]: .."}, {"qid": "", "rank": 3, "path": "pydantic/v1/class_validators.py", "score": 0.4692258834838867, "span_start": null, "span_end": null, "passage": "\"  # noqa: Q000\n            \"E.g usage should be `@validator('<field_name>', ...)`\"\n        )\n    elif not all(isinstance(field, str) for field in fields):\n        raise ConfigError(\n            \"vali..."}, {"qid": "", "rank": 4, "path": "pydantic/deprecated/class_validators.py", "score": 0.4418630599975586, "span_start": null, "span_end": null, "passage": "Args:\n        __field (str): The first field the validator should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one *fields (str): Ad..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4392145276069641, "span_start": null, "span_end": null, "passage": "'\n            f'\\nFor more details see https://docs.pydantic.dev/usage/schema/#unenforced-field-constraints'\n        )\n\n    return annotation\n\n\ndef get_annotation_with_constraints(annotation: Any, fie..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/fields.py", "score": 0.4385533928871155, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    __slots__ = (\n        'default',\n        'default_factory',\n        'alias',\n        'alias_priority',\n        'title',\n        'description',\n        'exclude',\n        'include',\n        'c..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/schema.py", "score": 0.4337022602558136, "span_start": null, "span_end": null, "passage": ":param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n..."}, {"qid": "", "rank": 8, "path": "pydantic/config.py", "score": 0.4302639067173004, "span_start": null, "span_end": null, "passage": "Defaults to `None`.\"\"\"\n\n    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None\n    \"\"\"A callable that takes a field's name and info and returns title for it Defaults to ..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_decorators.py", "score": 0.4259568452835083, "span_start": null, "span_end": null, "passage": "# In this case, we assume no info argument is present:\n        return False\n    n_positional = count_positional_required_params(sig)\n    if mode == 'wrap':\n        if n_positional == 3:\n            re..."}, {"qid": "", "rank": 10, "path": "pydantic/fields.py", "score": 0.42368167638778687, "span_start": null, "span_end": null, "passage": "It will be removed, use `exclude` instead', DeprecationWarning)\n\n    return FieldInfo.from_field(\n        default,\n        default_factory=default_factory,\n        alias=alias,\n        alias_priority=..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/mypy.py", "score": 0.41947466135025024, "span_start": null, "span_end": null, "passage": "\"\"\"\n        expr = stmt.rvalue\n        if isinstance(expr, TempNode):\n            # TempNode means annotation-only, so only non-required if Optional\n            value_type = get_proper_type(cls.info[l..."}, {"qid": "", "rank": 12, "path": "pydantic/v1/fields.py", "score": 0.4139529764652252, "span_start": null, "span_end": null, "passage": "Some arguments\n    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str`` :param default: since this is replacing the field\u2019s default, its first argument is used\n..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/fields.py", "score": 0.40868204832077026, "span_start": null, "span_end": null, "passage": "The `discriminator` is the name of this common field to shorten validation and improve generated schema\n    :param repr: show this field in the representation\n    :param **extra: any additional keywor..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/dataclasses.py", "score": 0.4072011411190033, "span_start": null, "span_end": null, "passage": "# for example if Extra.forbid is enabled, it would consider __pydantic_initialised__ an invalid extra property\n    if getattr(self, '__pydantic_initialised__'):\n        return\n    if getattr(self, '__..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_validators.py", "score": 0.4066545069217682, "span_start": null, "span_end": null, "passage": "# Additionally, we should be able to remove one of either this validator or the\n    # SequenceValidator in _std_types_schema.py (preferably this one, while porting over some logic) # Effectively, a re..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.40637069940567017, "span_start": null, "span_end": null, "passage": "# However, it still may make sense to apply the discriminator to this schema,\n            # as a way to get discriminated-union-style error messages, so we allow this here"}, {"qid": "", "rank": 17, "path": "pydantic/functional_serializers.py", "score": 0.4051428437232971, "span_start": null, "span_end": null, "passage": "Four signatures are supported:\n\n    - `(self, value: Any, info: FieldSerializationInfo)`\n    - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`\n    - `(value: Any..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/validators.py", "score": 0.40393996238708496, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if v != field.default:\n        raise errors.WrongConstantError(given=v, permitted=[field.default])\n\n    return v\n\n\ndef anystr_length_validator(v: 'StrBytes', config: 'BaseConfig') -> 'StrBytes..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/fields.py", "score": 0.4029887914657593, "span_start": null, "span_end": null, "passage": ":param const: this field is required and *must* take it's default value\n    :param gt: only applies to numbers, requires the field to be \"greater than\" The schema\n      will have an ``exclusiveMinimum..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_decorators.py", "score": 0.40158313512802124, "span_start": null, "span_end": null, "passage": "Attributes:\n        decorator_repr: A class variable representing the decorator string, '@field_serializer' fields: A tuple of field names the serializer should be called on mode: The proposed seriali..."}], "latency_ms": 3.620624542236328, "gold_paths": ["pydantic/_internal/_known_annotated_metadata.py", "pydantic/fields.py", "tests/test_fields.py"]}
{"qid": "lens_main_func_a01b9029", "query": "Updating JSON docs, adding `cache_strings` to `ConfigDict` (#9178)", "results": [{"qid": "", "rank": 1, "path": "pydantic/json_schema.py", "score": 0.6074298024177551, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n_MODE_TITLE_MAPPING: dict[JsonSchemaMode, str] = {'validation': 'Input', 'serialization': 'Output'}\n\n\n@deprecated(\n    '`update_json_schema` is deprecated, use a simple `my_dict.update(update_dic..."}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.6064127087593079, "span_start": null, "span_end": null, "passage": "!! warning \"Usage with `TypedDict`\"\n        Due to current limitations, attribute docstrings detection may not work as expected when using `TypedDict`\n        (in particular when multiple `TypedDict` ..."}, {"qid": "", "rank": 3, "path": "pydantic/json_schema.py", "score": 0.581637442111969, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    examples: dict[str, Any]\n    mode: Literal['validation', 'serialization'] | None = None\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, handler: GetJ..."}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.5507229566574097, "span_start": null, "span_end": null, "passage": "'\n                f'You must create a new instance of {type(self).__name__} to generate a new JSON schema.',\n                code='json-schema-already-used',\n            )\n\n        for key, mode, sche..."}, {"qid": "", "rank": 5, "path": "pydantic/json_schema.py", "score": 0.5465535521507263, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The schema Returns:\n            The generated JSON schema \"\"\"\n        items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])\n     ..."}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.5430775880813599, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema: JsonSchemaValue = {'type': 'object'}\n\n        keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\n        keys_pattern = keys_sc..."}, {"qid": "", "rank": 7, "path": "pydantic/config.py", "score": 0.5421800017356873, "span_start": null, "span_end": null, "passage": "model_config = ConfigDict(json_schema_mode_override='validation')\n\n    print(ForceInputModel.model_json_schema(mode='serialization'))\n    '''\n    {\n        'properties': {\n            'a': {\n         ..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.5414906144142151, "span_start": null, "span_end": null, "passage": "\"\"\"\n        cls = schema['cls']\n        config: ConfigDict = getattr(cls, '__pydantic_config__', cast('ConfigDict', {}))\n        title = config.get('title') or cls.__name__\n\n        with self._config_..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.5413547158241272, "span_start": null, "span_end": null, "passage": "Defaults to `True`.\"\"\"\n\n    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n    \"\"\"A dict or callable to provide extra JSON schema properties Defaults to `None`.\"\"\"\n\n    json_encoders: di..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.5337450504302979, "span_start": null, "span_end": null, "passage": "Args:\n        schema: The JSON schema to update updates: A dictionary of key-value pairs to set in the schema Returns:\n        The updated JSON schema \"\"\"\n    schema.update(updates)\n    return schema\n..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_config.py", "score": 0.533598780632019, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if config is None:\n        return ConfigDict()\n\n    if not isinstance(config, dict):\n        warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)\n        config = {k: getattr(config, k) for ..."}, {"qid": "", "rank": 12, "path": "pydantic/config.py", "score": 0.5266839861869812, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, ConfigDict\n\n    class Model(BaseModel):\n        a: str = 'a'\n\n        model_config = ConfigDict(json_schema_serialization_defaults_required=True)\n\n    print(M..."}, {"qid": "", "rank": 13, "path": "pydantic/json_schema.py", "score": 0.5205639004707336, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema \"\"\"\n        core_ref = CoreRef(schema['schema_ref'])\n        _, ref_json_schema = self.get_cache_defs_ref_schem..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/config.py", "score": 0.5191799998283386, "span_start": null, "span_end": null, "passage": "for k, v in config_dict.items():\n            setattr(Config, k, v)\n        return Config\n\n\ndef inherit_config(self_config: 'ConfigType', parent_config: 'ConfigType', **namespace: Any) -> 'ConfigType':..."}, {"qid": "", "rank": 15, "path": "tests/test_main.py", "score": 0.5151528716087341, "span_start": null, "span_end": null, "passage": "The argument strict=True\n    # in model_validate_json method is not overwriting the one set with ConfigDict(strict=False)\n    # for sequence like types"}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.5127963423728943, "span_start": null, "span_end": null, "passage": "# I believe this is true, but I am not 100% sure\n                required.append(name)\n\n        json_schema: JsonSchemaValue = {'type': 'object', 'properties': properties}\n        if required:\n       ..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.5108355283737183, "span_start": null, "span_end": null, "passage": "\"\"\"\n        core_mode_ref = (core_ref, self.mode)\n        maybe_defs_ref = self.core_to_defs_refs.get(core_mode_ref)\n        if maybe_defs_ref is not None:\n            json_ref = self.core_to_json_ref..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.5104161500930786, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, generate_json_schema: GenerateJsonSchema, handler_override: HandlerOverride | None) -> None:\n        self.generate_json_schema = generate_json_schema\n        self.handler =..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.5101372599601746, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema = {'type': 'string', 'format': 'base64url' if self._config.ser_json_bytes == 'base64' else 'binary'}\n        self.update_with_validations(json_schema, schema, self.ValidationsM..."}, {"qid": "", "rank": 20, "path": "pydantic/json_schema.py", "score": 0.5097900629043579, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema: dict[str, Any] = {'type': 'number'}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)\n        json_schema = {k: v for k, v in json_sch..."}], "latency_ms": 3.669261932373047, "gold_paths": ["pydantic/_internal/_config.py", "pydantic/config.py"]}
{"qid": "lens_main_func_a7d32534", "query": "Fix allow extra generic (#9193)", "results": [{"qid": "", "rank": 1, "path": "tests/test_dataclasses.py", "score": 0.5929271578788757, "span_start": null, "span_end": null, "passage": "This is essentially a limitation of typing._GenericAlias"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_model_construction.py", "score": 0.5372956395149231, "span_start": null, "span_end": null, "passage": "# It would be nice to remove this error and still have things behave as expected, it's just\n                            # challenging because we are using a custom `__class_getitem__` to parametrize g..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_core_utils.py", "score": 0.4590218663215637, "span_start": null, "span_end": null, "passage": "This `args_override` argument was added for the purpose of creating valid recursive references\n    when creating generic models without needing to create a concrete class"}, {"qid": "", "rank": 4, "path": "tests/test_generics.py", "score": 0.45283353328704834, "span_start": null, "span_end": null, "passage": "This is due to weird behavior with the WeakValueDictionary used for caching As part of the next batch of generics work, we should attempt to fix this if possible"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generics.py", "score": 0.4498669505119324, "span_start": null, "span_end": null, "passage": "Specifically, this works with standard typing generics and typing._GenericAlias"}, {"qid": "", "rank": 6, "path": "tests/test_generics.py", "score": 0.4297315180301666, "span_start": null, "span_end": null, "passage": "ModelWithType[MyInt]\n    ModelWithType[MyStr]\n\n\ndef test_generic_with_referenced_generic_type_constraints():\n    T = TypeVar('T', int, str)\n\n    class ModelWithType(BaseModel, Generic[T]):\n        # T..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/generics.py", "score": 0.42297619581222534, "span_start": null, "span_end": null, "passage": "# If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters"}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_utils.py", "score": 0.4141327142715454, "span_start": null, "span_end": null, "passage": "import _repr, _typing_extra\n\nif typing.TYPE_CHECKING:\n    MappingIntStrAny: TypeAlias = 'typing.Mapping[int, Any] | typing.Mapping[str, Any]'\n    AbstractSetIntStr: TypeAlias = 'typing.AbstractSet[int..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generics.py", "score": 0.41055408120155334, "span_start": null, "span_end": null, "passage": "from __future__ import annotations\n\nimport sys\nimport types\nimport typing\nfrom collections import ChainMap\nfrom contextlib import contextmanager\nfrom contextvars import ContextVar\nfrom types import pr..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generate_schema.py", "score": 0.41012105345726013, "span_start": null, "span_end": null, "passage": "This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game"}, {"qid": "", "rank": 11, "path": "pydantic/mypy.py", "score": 0.3952412009239197, "span_start": null, "span_end": null, "passage": "# Also, it is tricky to avoid eager expansion of Self types here (e.g because\n            # we serialize attributes)"}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_generics.py", "score": 0.39467954635620117, "span_start": null, "span_end": null, "passage": "# _GENERIC_TYPES_CACHE = DeepChainMap(GenericTypesCache(), LimitedDict())\n\n_GENERIC_TYPES_CACHE = GenericTypesCache()\n\n\nclass PydanticGenericMetadata(typing_extensions.TypedDict):\n    origin: type[Bas..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.3900846242904663, "span_start": null, "span_end": null, "passage": "Finally, this module makes liberal use of `# type: ignore[<code>]` pragmas This is because Hypothesis annotates `register_type_strategy()` with\n`(T, SearchStrategy[T])`, but in most cases we register ..."}, {"qid": "", "rank": 14, "path": "pydantic/fields.py", "score": 0.3883655071258545, "span_start": null, "span_end": null, "passage": "warning Deprecated\n                The `extra` kwargs is deprecated Use `json_schema_extra` instead Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo] The return annotation is `Any` so `F..."}, {"qid": "", "rank": 15, "path": "pydantic/v1/generics.py", "score": 0.38705089688301086, "span_start": null, "span_end": null, "passage": "if sys.version_info >= (3, 10) and origin_type is types.UnionType:  # noqa: E721\n            return _UnionGenericAlias(origin_type, resolved_type_args)\n        return origin_type[resolved_type_args]\n\n..."}, {"qid": "", "rank": 16, "path": "pydantic/main.py", "score": 0.38508766889572144, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if not issubclass(cls, typing.Generic):\n            raise TypeError('Concrete names should only be generated for generic models.')\n\n        # Any strings received should represent forward ..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.3848452568054199, "span_start": null, "span_end": null, "passage": "# It may be a good idea to do a recursive pass at the end of the generation to remove\n                # any redundant override keys"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generics.py", "score": 0.3831573724746704, "span_start": null, "span_end": null, "passage": "Raises:\n        TypeError: If the passed parameters count is not equal to generic model parameters count"}, {"qid": "", "rank": 19, "path": "pydantic/v1/types.py", "score": 0.3795676827430725, "span_start": null, "span_end": null, "passage": "_DEFINED_TYPES.add(typ)\n    return typ\n\n\nclass ConstrainedNumberMeta(type):\n    def __new__(cls, name: str, bases: Any, dct: Dict[str, Any]) -> 'ConstrainedInt':  # type: ignore\n        new_cls = cast..."}, {"qid": "", "rank": 20, "path": "pydantic/main.py", "score": 0.37543678283691406, "span_start": null, "span_end": null, "passage": "# This can happen if a `ValidationError` is raised during initialization and the instance's\n        # repr is generated as part of the exception handling Therefore, we use `getattr` here\n        # wit..."}], "latency_ms": 3.4296512603759766, "gold_paths": ["pydantic/_internal/_generate_schema.py", "tests/test_generics.py"]}
{"qid": "lens_main_func_fc0cb917", "query": "fix `model_construct` with `validation_alias` (#9144)", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/main.py", "score": 0.6599093079566956, "span_start": null, "span_end": null, "passage": ":param __model_name: name of the created model\n    :param __config__: config class to use for the new model\n    :param __base__: base class for the new model to inherit from\n    :param __module__: mod..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_model_construction.py", "score": 0.6429110765457153, "span_start": null, "span_end": null, "passage": "# It would be nice to remove this error and still have things behave as expected, it's just\n                            # challenging because we are using a custom `__class_getitem__` to parametrize g..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.642219603061676, "span_start": null, "span_end": null, "passage": "`model_name` is accepted for the purpose of producing useful error messages"}, {"qid": "", "rank": 4, "path": "pydantic/main.py", "score": 0.6100432872772217, "span_start": null, "span_end": null, "passage": "Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n            an error if extra values are passed, but they will be igno..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/main.py", "score": 0.6074069738388062, "span_start": null, "span_end": null, "passage": "@overload\ndef create_model(\n    __model_name: str,\n    *,\n    __config__: Optional[Type[BaseConfig]] = None,\n    __base__: Union[Type['Model'], Tuple[Type['Model'], ...]],\n    __module__: str = __name..."}, {"qid": "", "rank": 6, "path": "pydantic/aliases.py", "score": 0.6015486717224121, "span_start": null, "span_end": null, "passage": "\"\"\"\n        alias = self._generate_alias('alias', (str,), field_name)\n        validation_alias = self._generate_alias('validation_alias', (str, AliasChoices, AliasPath), field_name)\n        serializat..."}, {"qid": "", "rank": 7, "path": "tests/test_aliases.py", "score": 0.5970622301101685, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of'\n        ):\n\n            class Foo(BaseModel):\n                a: str\n\n                model_config = ConfigDict(alias_generator=AliasGenerator(**{alias_ki..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_model_construction.py", "score": 0.5903587341308594, "span_start": null, "span_end": null, "passage": "This logic must be called after class has been created since validation functions must be bound\n    and `get_type_hints` requires a class object Args:\n        cls: BaseModel or dataclass cls_name: The..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/main.py", "score": 0.5844922065734863, "span_start": null, "span_end": null, "passage": "\"\"\"\n    values = {}\n    errors = []\n    # input_data names, possibly alias\n    names_used = set()\n    # field names, never aliases\n    fields_set = set()\n    config = model.__config__\n    check_extra ..."}, {"qid": "", "rank": 10, "path": "pydantic/main.py", "score": 0.5824775695800781, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.__pydantic_fields_set__\n\n    @classmethod\n    def model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -> Self:  # noqa: C901\n        \"\"\"Creates a new insta..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_config.py", "score": 0.5764814615249634, "span_start": null, "span_end": null, "passage": "alias or first alias for \"field required\" errors) instead of field_names\n    # to construct error `loc`s, default `True`\n    loc_by_alias: bool\n    alias_generator: Callable[[str], str] | AliasGenerat..."}, {"qid": "", "rank": 12, "path": "pydantic/main.py", "score": 0.5654934644699097, "span_start": null, "span_end": null, "passage": "# TODO: Make sure validation fails if there are still undefined types, perhaps using MockValidator\n                    pass\n\n                submodel = _generics.create_generic_submodel(model_name, or..."}, {"qid": "", "rank": 13, "path": "tests/test_aliases.py", "score": 0.5631998777389526, "span_start": null, "span_end": null, "passage": "it should be `str`, `AliasChoices`, or `AliasPath`'\n    with pytest.raises(TypeError, match=m):\n\n        class Model(BaseModel):\n            x: str = Field(validation_alias=123)\n\n\ndef test_validation_..."}, {"qid": "", "rank": 14, "path": "pydantic/aliases.py", "score": 0.5631852149963379, "span_start": null, "span_end": null, "passage": "`{alias_kind}` generator must produce one of `{allowed_types}`'\n                )\n        return alias\n\n    def generate_aliases(self, field_name: str) -> tuple[str | None, str | AliasPath | AliasChoi..."}, {"qid": "", "rank": 15, "path": "pydantic/config.py", "score": 0.5597444772720337, "span_start": null, "span_end": null, "passage": "You may be able to resolve this warning by setting `model_config['protected_namespaces'] = ()`"}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.5580953359603882, "span_start": null, "span_end": null, "passage": "\"\"\"\n    from .main import BaseModel\n\n    schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n\n    if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockC..."}, {"qid": "", "rank": 17, "path": "pydantic/main.py", "score": 0.5556356310844421, "span_start": null, "span_end": null, "passage": "@overload\ndef create_model(\n    model_name: str,\n    /,\n    *,\n    __config__: ConfigDict | None = None,\n    __doc__: str | None = None,\n    __base__: type[ModelT] | tuple[type[ModelT], ...],\n    __mo..."}, {"qid": "", "rank": 18, "path": "pydantic/mypy.py", "score": 0.5549285411834717, "span_start": null, "span_end": null, "passage": "\"\"\"\n        info = self._cls.info\n        arguments = [\n            field.to_argument(\n                info,\n                typed=typed,\n                force_optional=requires_dynamic_aliases or is_..."}, {"qid": "", "rank": 19, "path": "pydantic/config.py", "score": 0.5532464981079102, "span_start": null, "span_end": null, "passage": "'''\n    ```\n\n    While Pydantic will only emit a warning when an item is in a protected namespace but does not actually have a collision,\n    an error _is_ raised if there is an actual collision with ..."}, {"qid": "", "rank": 20, "path": "pydantic/mypy.py", "score": 0.552251935005188, "span_start": null, "span_end": null, "passage": "error_invalid_config_value(name, self._api, arg)\n                return None\n            return ModelConfigData(forbid_extra=forbid_extra)\n        if name == 'alias_generator':\n            has_alias_g..."}], "latency_ms": 3.597259521484375, "gold_paths": ["pydantic/main.py", "tests/test_construction.py"]}
{"qid": "lens_main_func_b900fe2c", "query": "WIP: add feedback widget to docs with flarelytics integration (#9129)", "results": [{"qid": "", "rank": 1, "path": "docs/extra/feedback.js", "score": 0.3953951895236969, "span_start": null, "span_end": null, "passage": "var feedback = document.forms.feedback\nfeedback.hidden = false\n\nfeedback.addEventListener(\"submit\", function(ev) {\n  ev.preventDefault()\n\n  var data = ev.submitter.getAttribute(\"data-md-value\")\n  feed..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.28318193554878235, "span_start": null, "span_end": null, "passage": "\"\"\"\n    api.fail('Required dynamic aliases disallowed', context, code=ERROR_ALIAS)\n\n\ndef error_unexpected_behavior(\n    detail: str, api: CheckerPluginInterface | SemanticAnalyzerPluginInterface, cont..."}, {"qid": "", "rank": 3, "path": "docs/plugins/griffe_doclinks.py", "score": 0.2710287272930145, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n'\n            f'    [`{api_link}`][{api_link}]<br>'\n            f'{content[heading_end:]}'\n        )\n\n    return f'!!"}, {"qid": "", "rank": 4, "path": "tests/check_usage_docs.py", "score": 0.24999985098838806, "span_start": null, "span_end": null, "passage": "\"\"\"\nCheck that all `Usage docs` tags in docstrings link to the latest version of pydantic"}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_docs_extraction.py", "score": 0.24929216504096985, "span_start": null, "span_end": null, "passage": "try:\n            source, _ = inspect.getsourcelines(cls)\n        except OSError:\n            return {}\n    else:\n        source = _extract_source_from_frame(cls)\n\n    if not source:\n        return {}\n..."}, {"qid": "", "rank": 6, "path": "pydantic/errors.py", "score": 0.2459566593170166, "span_start": null, "span_end": null, "passage": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version imp..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_generate_schema.py", "score": 0.24579977989196777, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.23868323862552643, "span_start": null, "span_end": null, "passage": "Used internally by Pydantic, please do not rely on this implementation See `GetCoreSchemaHandler` for the handler API"}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_decorators.py", "score": 0.2363806664943695, "span_start": null, "span_end": null, "passage": "info: The decorator info Returns:\n            The new decorator instance"}, {"qid": "", "rank": 10, "path": "docs/plugins/griffe_doclinks.py", "score": 0.22980283200740814, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n' f'    [`{api_link}`][{api_link}]<br>\\n\\n' f'{content}')\n\n    heading = file_path.stem.replace('_', ' ').title()\n    return f'!!"}, {"qid": "", "rank": 11, "path": "pydantic/v1/mypy.py", "score": 0.22630499303340912, "span_start": null, "span_end": null, "passage": "This can be dropped if/when https://github.com/python/mypy/issues/7301 is merged\n    \"\"\"\n    info = ctx.cls.info\n\n    # First remove any previously generated methods with the same name\n    # to avoid ..."}, {"qid": "", "rank": 12, "path": "pydantic/types.py", "score": 0.2243824452161789, "span_start": null, "span_end": null, "passage": "warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.f..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_validate_call.py", "score": 0.2236761599779129, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nimport inspect\nfrom functools import partial\nfrom typing import Any, Awaitable, Callable\n\nimport pydantic_core\n\nfrom ..config import ConfigDict\nfrom..."}, {"qid": "", "rank": 14, "path": "docs/plugins/main.py", "score": 0.2211923748254776, "span_start": null, "span_end": null, "passage": "from __future__ import annotations as _annotations\n\nimport json\nimport logging\nimport os\nimport re\nimport textwrap\nfrom pathlib import Path\nfrom textwrap import indent\n\nimport autoflake\nimport pyupgra..."}, {"qid": "", "rank": 15, "path": "pydantic/experimental/pipeline.py", "score": 0.22106121480464935, "span_start": null, "span_end": null, "passage": "\"\"\"Experimental pipeline API functionality"}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_repr.py", "score": 0.2185206562280655, "span_start": null, "span_end": null, "passage": "\"\"\"Tools to provide pretty/human-readable display of objects.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport types\nimport typing\nfrom typing import Any\n\nimport typing_extensions\n\nfrom"}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.218169704079628, "span_start": null, "span_end": null, "passage": "This is used for any Annotated metadata so that we don't end up with conflicting\n    modifications to the definition schema Used internally by Pydantic, please do not rely on this implementation See `..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.2168308049440384, "span_start": null, "span_end": null, "passage": "\"\"\"\n        metadata = _core_metadata.CoreMetadataHandler(schema).metadata\n        prefer_positional = metadata.get('pydantic_js_prefer_positional_arguments')\n\n        arguments = schema['arguments_sc..."}, {"qid": "", "rank": 19, "path": "pydantic/warnings.py", "score": 0.2164030820131302, "span_start": null, "span_end": null, "passage": "This warning is raised when using experimental functionality in Pydantic It is raised to warn users that the functionality may change or be removed in future versions of Pydantic \"\"\""}, {"qid": "", "rank": 20, "path": "docs/plugins/griffe_doclinks.py", "score": 0.21623295545578003, "span_start": null, "span_end": null, "passage": "abstract \"Usage Documentation\"\\n    [{heading}](../{rel_file}#{slug})\\n'\n\n\ndef update_docstring(obj: GriffeObject) -> str:\n    return re.sub(\n        r'usage[\\- ]docs: ?https://docs\\.pydantic\\.dev/.+?..."}], "latency_ms": 3.6013126373291016, "gold_paths": ["docs/extra/feedback.js"]}
{"qid": "lens_main_func_3ad2018f", "query": "Remove `update_json_schema` (bad practice func) (#9125)", "results": [{"qid": "", "rank": 1, "path": "tests/test_deprecated.py", "score": 0.6697990298271179, "span_start": null, "span_end": null, "passage": "Use `json_schema_extra` instead"}, {"qid": "", "rank": 2, "path": "pydantic/json_schema.py", "score": 0.6132863759994507, "span_start": null, "span_end": null, "passage": "\"\"\"\n        items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])\n        json_schema = {'type': 'array', 'items': items_schema}\n        self.update_with_v..."}, {"qid": "", "rank": 3, "path": "pydantic/json_schema.py", "score": 0.5996997356414795, "span_start": null, "span_end": null, "passage": "\"\"\"\n        if '$ref' in json_schema:\n            schema_to_update = self.get_schema_from_definitions(JsonRef(json_schema['$ref']))\n            if schema_to_update is None:\n                raise Runti..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5909630060195923, "span_start": null, "span_end": null, "passage": "'\n                f'Use `__get_pydantic_json_schema__` instead{f\" in class `{cls_name}`\" if cls_name else \"\"}.',\n                code='custom-json-schema',\n            )\n\n    # handle GenericAlias' bu..."}, {"qid": "", "rank": 5, "path": "pydantic/fields.py", "score": 0.5891304016113281, "span_start": null, "span_end": null, "passage": "use `pattern` instead', code='removed-kwargs')\n\n    if extra:\n        warn(\n            'Using extra keyword arguments on `Field` is deprecated and will be removed.'\n            ' Use `json_schema_ext..."}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.5883175134658813, "span_start": null, "span_end": null, "passage": "Args:\n                schema_or_field: The core schema to generate a JSON schema from Returns:\n                The generated JSON schema Raises:\n                TypeError: If an unexpected schema type..."}, {"qid": "", "rank": 7, "path": "pydantic/json_schema.py", "score": 0.5861777067184448, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n_MODE_TITLE_MAPPING: dict[JsonSchemaMode, str] = {'validation': 'Input', 'serialization': 'Output'}\n\n\n@deprecated(\n    '`update_json_schema` is deprecated, use a simple `my_dict.update(update_dic..."}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.5861237645149231, "span_start": null, "span_end": null, "passage": "\"\"\"\n        # TODO: Need to read the default value off of model config or whatever\n        use_strict = schema.get('strict', False)  # TODO: replace this default False\n        # If your JSON schema fa..."}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.5797277688980103, "span_start": null, "span_end": null, "passage": "Defaults to `True`.\"\"\"\n\n    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n    \"\"\"A dict or callable to provide extra JSON schema properties Defaults to `None`.\"\"\"\n\n    json_encoders: di..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.5795924067497253, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._function_schema(schema)\n\n    def function_plain_schema(self, schema: core_schema.PlainValidatorFunctionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matc..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.578507661819458, "span_start": null, "span_end": null, "passage": "value_ser_type = core_schema.plain_serializer_function_ser_schema(lambda x: x)\n\n    if cases:\n\n        def get_json_schema(schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:\n      ..."}, {"qid": "", "rank": 12, "path": "pydantic/config.py", "score": 0.5778235197067261, "span_start": null, "span_end": null, "passage": "note\n        The `experimental_defer_build_mode` parameter is named with an underscore to suggest this is an experimental feature It may\n        be removed or changed in the future in a minor release ..."}, {"qid": "", "rank": 13, "path": "pydantic/json_schema.py", "score": 0.5765589475631714, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._common_set_schema(schema)\n\n    def _common_set_schema(self, schema: core_schema.SetSchema | core_schema.FrozenSetSchema) -> JsonSchemaValue:\n        items_schema = {} if 'item..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.5736426115036011, "span_start": null, "span_end": null, "passage": "return self.generate_inner(schema['schema'])\n\n        # function-plain\n        return self.handle_invalid_for_json_schema(\n            schema, f'core_schema.PlainValidatorFunctionSchema ({schema[\"func..."}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.5646165609359741, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._function_schema(schema)\n\n    def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema with ..."}, {"qid": "", "rank": 16, "path": "pydantic/fields.py", "score": 0.5643091797828674, "span_start": null, "span_end": null, "passage": "warning Deprecated\n                The `extra` kwargs is deprecated Use `json_schema_extra` instead Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo] The return annotation is `Any` so `F..."}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.5603703260421753, "span_start": null, "span_end": null, "passage": "if use_strict:\n            return self.generate_inner(schema['strict_schema'])\n        else:\n            return self.generate_inner(schema['lax_schema'])\n\n    def json_or_python_schema(self, schema: c..."}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.5599536895751953, "span_start": null, "span_end": null, "passage": "Args:\n        schema: The JSON schema to update updates: A dictionary of key-value pairs to set in the schema Returns:\n        The updated JSON schema \"\"\"\n    schema.update(updates)\n    return schema\n..."}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.5567625164985657, "span_start": null, "span_end": null, "passage": "\"\"\"\n        json_schema: dict[str, Any] = {'type': 'number'}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)\n        json_schema = {k: v for k, v in json_sch..."}, {"qid": "", "rank": 20, "path": "pydantic/main.py", "score": 0.5564501285552979, "span_start": null, "span_end": null, "passage": "Since this gets called by `BaseModel.model_json_schema` you can override the\n                `schema_generator` argument to that function to change JSON schema generation globally\n                for ..."}], "latency_ms": 3.6988258361816406, "gold_paths": ["pydantic/_internal/_std_types_schema.py", "pydantic/json_schema.py"]}
{"qid": "lens_main_func_7ac7881f", "query": "Fix discriminated union bug with unsubstituted type var (#9124)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.6035385131835938, "span_start": null, "span_end": null, "passage": "# However, it still may make sense to apply the discriminator to this schema,\n            # as a way to get discriminated-union-style error messages, so we allow this here"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generics.py", "score": 0.5312386155128479, "span_start": null, "span_end": null, "passage": "Thanks to caching internal to the `typing` module, it is not possible to distinguish between\n    List[Union[int, float]] and List[Union[float, int]] (and similarly for other \"parent\" origins besides L..."}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.5211644172668457, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The input schema Returns:\n            The new core schema Raises:\n            TypeError:\n                - If `discriminator` is used with invalid union variant - If `discrim..."}, {"qid": "", "rank": 4, "path": "pydantic/types.py", "score": 0.5130600333213806, "span_start": null, "span_end": null, "passage": "[Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    discriminator: str | Callable[[Any], Hashable]\n    \"\"\"The callable or field name for discriminating the type in a tagged..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_generics.py", "score": 0.5118693113327026, "span_start": null, "span_end": null, "passage": "Because we parse items as the first Union type that is successful, we get slightly more consistent behavior\n    if we make an effort to distinguish the ordering of items in a union It would be best if..."}, {"qid": "", "rank": 6, "path": "pydantic/_internal/_generics.py", "score": 0.5096372365951538, "span_start": null, "span_end": null, "passage": "\"\"\"\n    _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values)] = type_\n    if len(typevar_values) == 1:\n        _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values[0])] = type_\n    if..."}, {"qid": "", "rank": 7, "path": "pydantic/types.py", "score": 0.504901111125946, "span_start": null, "span_end": null, "passage": "This allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,\n    but without needing to have a single shared field across all the union choices This also makes i..."}, {"qid": "", "rank": 8, "path": "pydantic/deprecated/class_validators.py", "score": 0.4982713758945465, "span_start": null, "span_end": null, "passage": "V1Validator = Union[\n        _OnlyValueValidatorClsMethod,\n        _V1ValidatorWithValuesClsMethod,\n        _V1ValidatorWithValuesKwOnlyClsMethod,\n        _V1ValidatorWithKwargsClsMethod,\n        _V1V..."}, {"qid": "", "rank": 9, "path": "pydantic/type_adapter.py", "score": 0.4979025721549988, "span_start": null, "span_end": null, "passage": "As a workaround, you can explicitly\n            annotate your variable:\n\n            ```py\n            from typing import Union\n\n            from pydantic import TypeAdapter\n\n            ta: TypeAdapt..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4930126965045929, "span_start": null, "span_end": null, "passage": "self._discriminator_alias: str | None = None\n\n        # `_should_be_nullable` indicates whether the converted union has `None` as an allowed value # If `None` is an acceptable value of the (possibly-w..."}, {"qid": "", "rank": 11, "path": "pydantic/functional_validators.py", "score": 0.473892480134964, "span_start": null, "span_end": null, "passage": "_V2Validator = Union[\n        _V2ValidatorClsMethod,\n        _core_schema.WithInfoValidatorFunction,\n        _OnlyValueValidatorClsMethod,\n        _core_schema.NoInfoValidatorFunction,\n    ]\n\n    _V2W..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_generics.py", "score": 0.4731253385543823, "span_start": null, "span_end": null, "passage": "\"\"\"\n    # The _union_orderings_key is placed at the start here to ensure there cannot be a collision with an\n    # _early_cache_key, as that function will always produce a BaseModel subclass as the fi..."}, {"qid": "", "rank": 13, "path": "pydantic/types.py", "score": 0.47051793336868286, "span_start": null, "span_end": null, "passage": "Consider this example, which is much more performant with the use of `Discriminator` and thus a `TaggedUnion`\n    than it would be as a normal `Union`"}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.4654894769191742, "span_start": null, "span_end": null, "passage": "[Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    tag: str\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n   ..."}, {"qid": "", "rank": 15, "path": "tests/test_generics.py", "score": 0.46301501989364624, "span_start": null, "span_end": null, "passage": "ReferenceModel[MyInt]\n\n\ndef test_generic_with_referenced_generic_union_type_bound():\n    T = TypeVar('T', bound=Union[str, int])\n\n    class ModelWithType(BaseModel, Generic[T]):\n        some_type: Typ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.46243759989738464, "span_start": null, "span_end": null, "passage": "PydanticUserError:\n            - If a model in union doesn't have a discriminator field - If discriminator field has a non-string alias - If discriminator fields have different aliases - If discrimina..."}, {"qid": "", "rank": 17, "path": "tests/test_discriminated_union.py", "score": 0.4558018445968628, "span_start": null, "span_end": null, "passage": "import re\nimport sys\nfrom enum import Enum, IntEnum\nfrom types import SimpleNamespace\nfrom typing import Any, Callable, Generic, List, Optional, Sequence, TypeVar, Union\n\nimport pytest\nfrom dirty_equa..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/typing.py", "score": 0.4519736170768738, "span_start": null, "span_end": null, "passage": "if is_literal_type(type_):  # pragma: no cover\n            return all_literal_values(type_) == (None,)\n        return False\n\nelse:\n\n    def is_none_type(type_: Any) -> bool:\n        return type_ in NO..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4505040645599365, "span_start": null, "span_end": null, "passage": "#\n        # Rather than trying to do the most powerful inference possible, I think we should eventually\n        # expose a way to more-manually control the way the TaggedUnionSchema is constructed thr..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.4498967230319977, "span_start": null, "span_end": null, "passage": "This is done by:\n    * Validating that the input schema is compatible with the provided discriminator\n    * Introspecting the schema to determine which discriminator values should map to which union c..."}], "latency_ms": 3.5283565521240234, "gold_paths": ["pydantic/_internal/_generate_schema.py", "tests/test_discriminated_union.py"]}
{"qid": "lens_main_func_548feec7", "query": "Add benchmark decorators (#9123)", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.5845109224319458, "span_start": null, "span_end": null, "passage": "info: The decorator info Returns:\n            The new decorator instance"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_decorators.py", "score": 0.5012831687927246, "span_start": null, "span_end": null, "passage": "Attributes:\n        cls_ref: The class ref cls_var_name: The decorated function name func: The decorated function shim: A wrapper function to wrap V1 style function info: The decorator info"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_decorators.py", "score": 0.47007930278778076, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    cls_ref: str\n    cls_var_name: str\n    func: Callable[..., Any]\n    shim: Callable[[Any], Any] | None\n    info: DecoratorInfoType\n\n    @staticmethod\n    def build(\n        cls_: Any,\n        ..."}, {"qid": "", "rank": 4, "path": "pydantic/fields.py", "score": 0.45432910323143005, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def dec(f: Any) -> Any:\n        nonlocal description, deprecated, return_type, alias_priority\n        unwrapped = _decorators.unwrap_wrapped_function(f)\n\n        if description is None and un..."}, {"qid": "", "rank": 5, "path": "pydantic/v1/mypy.py", "score": 0.44986391067504883, "span_start": null, "span_end": null, "passage": "Teach mypy this by marking any function whose outermost decorator is a\n        `validator()` call as a classmethod"}, {"qid": "", "rank": 6, "path": "pydantic/deprecated/class_validators.py", "score": 0.44330817461013794, "span_start": null, "span_end": null, "passage": "allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n            the decorated function Defaults to False Returns:\n        Callable: A decorator that can be..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/mypy.py", "score": 0.4363865852355957, "span_start": null, "span_end": null, "passage": "r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    if is_classmethod:  # or is_staticmethod:\n        func.is_decorated = True\n        v = Var(na..."}, {"qid": "", "rank": 8, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.4361916184425354, "span_start": null, "span_end": null, "passage": "This makes our timing comparison incorrect\n        # However, the value must be different, otherwise *our* __dict__ == right.__dict__\n        # fast-path prevents our correct code from running\n       ..."}, {"qid": "", "rank": 9, "path": "pydantic/mypy.py", "score": 0.43501222133636475, "span_start": null, "span_end": null, "passage": "Teach mypy this by marking any function whose outermost decorator is a `validator()`,\n        `field_validator()` or `serializer()` call as a `classmethod`"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_decorators.py", "score": 0.4291808009147644, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    decorator_repr: ClassVar[str] = '@model_validator'\n    mode: Literal['wrap', 'before', 'after']\n\n\nDecoratorInfo: TypeAlias = \"\"\"Union[\n    ValidatorDecoratorInfo,\n    FieldValidatorDecoratorI..."}, {"qid": "", "rank": 11, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.42695099115371704, "span_start": null, "span_end": null, "passage": "This makes our timing comparison incorrect\n        # However, the value must be different, otherwise *our* __dict__ == right.__dict__\n        # fast-path prevents our correct code from running\n       ..."}, {"qid": "", "rank": 12, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.42685288190841675, "span_start": null, "span_end": null, "passage": "This makes our timing comparison incorrect\n        # However, the value must be different, otherwise *our* __dict__ == right.__dict__\n        # fast-path prevents our correct code from running\n       ..."}, {"qid": "", "rank": 13, "path": "pydantic/deprecated/class_validators.py", "score": 0.4264675974845886, "span_start": null, "span_end": null, "passage": "V1Validator = Union[\n        _OnlyValueValidatorClsMethod,\n        _V1ValidatorWithValuesClsMethod,\n        _V1ValidatorWithValuesKwOnlyClsMethod,\n        _V1ValidatorWithKwargsClsMethod,\n        _V1V..."}, {"qid": "", "rank": 14, "path": "pydantic/_internal/_decorators.py", "score": 0.424949049949646, "span_start": null, "span_end": null, "passage": "a partial object\n            return self.wrapped  # type: ignore[return-value]\n\n    def __set_name__(self, instance: Any, name: str) -> None:\n        if hasattr(self.wrapped, '__set_name__'):\n        ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generate_schema.py", "score": 0.424383282661438, "span_start": null, "span_end": null, "passage": "It ignores the check for a decorator if the decorator has `*` as field or `check_fields=False` Args:\n        decorators: An iterable of decorators fields: An iterable of fields name Raises:\n        Py..."}, {"qid": "", "rank": 16, "path": "pydantic/validate_call_decorator.py", "score": 0.4227133095264435, "span_start": null, "span_end": null, "passage": "Usage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)` Args:\n        func: The function to be decorated config: The configuration dictionary validate_return:..."}, {"qid": "", "rank": 17, "path": "pydantic/decorator.py", "score": 0.4215683341026306, "span_start": null, "span_end": null, "passage": "\"\"\"The `decorator` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_decorators.py", "score": 0.41816967725753784, "span_start": null, "span_end": null, "passage": "\"\"\"\n    sig = signature(unwrap_wrapped_function(function))\n    first = next(iter(sig.parameters.values()), None)\n    if first and first.name == 'self':\n        return True\n    return False\n\n\ndef ensur..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_decorators.py", "score": 0.4170840382575989, "span_start": null, "span_end": null, "passage": "Attributes:\n        decorator_repr: A class variable representing the decorator string, '@validator' fields: A tuple of field names the validator should be called on mode: The proposed validator mode ..."}, {"qid": "", "rank": 20, "path": "tests/benchmarks/test_north_star.py", "score": 0.41706782579421997, "span_start": null, "span_end": null, "passage": "\"\"\"\nAn integration-style benchmark of a model with a class of what should\n(hopefully) be some of the most common field types used in pydantic validation Used to gauge overall pydantic performance"}], "latency_ms": 3.5424232482910156, "gold_paths": ["tests/benchmarks/test_discriminated_unions.py", "tests/benchmarks/test_schema_build.py"]}
{"qid": "lens_main_func_3259d7c2", "query": "Add benchmark for schema build time with nested dataclass and model (#9121)", "results": [{"qid": "", "rank": 1, "path": "tests/benchmarks/test_fastapi_startup_generics.py", "score": 0.4965084195137024, "span_start": null, "span_end": null, "passage": "if j % 2 == 0 else type_default\n            fields[f'f{j}'] = (type_, default)\n        models.append(create_model(f'M1{i}', **fields))\n\n    # Crate varying outer models where some fields use the inner..."}, {"qid": "", "rank": 2, "path": "pydantic/json_schema.py", "score": 0.48611629009246826, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema \"\"\"\n        return self.generate_inner(schema['schema'])\n\n    def dataclass_field_schema(self, schema: core_sch..."}, {"qid": "", "rank": 3, "path": "pydantic/v1/main.py", "score": 0.4642508625984192, "span_start": null, "span_end": null, "passage": "Note: the data is not validated before creating\n            the new model: you should trust this data\n        :param deep: set to `True` to make a deep copy of the model\n        :return: new model ins..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/schema.py", "score": 0.46392568945884705, "span_start": null, "span_end": null, "passage": "Take a single ``model`` and generate the schema for its type only, not including additional\n    information as title, etc Also return additional schema definitions, from sub-models"}, {"qid": "", "rank": 5, "path": "pydantic/v1/schema.py", "score": 0.4628012776374817, "span_start": null, "span_end": null, "passage": "Take a single ``field`` and generate the schema for its type only, not including additional\n    information as title, etc Also return additional schema definitions, from sub-models"}, {"qid": "", "rank": 6, "path": "pydantic/json_schema.py", "score": 0.45746251940727234, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return {'type': 'string', 'format': 'time'}\n\n    def datetime_schema(self, schema: core_schema.DatetimeSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a datetim..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/schema.py", "score": 0.4544007480144501, "span_start": null, "span_end": null, "passage": "Take a single ``model`` and generate its schema Also return additional schema definitions, from sub-models The\n    sub-models of the returned schema will be referenced, but their definitions will not ..."}, {"qid": "", "rank": 8, "path": "tests/test_json_schema.py", "score": 0.4425238370895386, "span_start": null, "span_end": null, "passage": "'\n            'You must create a new instance of GenerateJsonSchema to generate a new JSON schema.'\n        ),\n    ):\n        generator.generate_definitions([(Model, 'validation', Model.__pydantic_cor..."}, {"qid": "", "rank": 9, "path": "pydantic/json_schema.py", "score": 0.43858712911605835, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema \"\"\"\n        if self._config.ser_json_timedelta == 'float':\n            return {'type': 'number'}\n        return..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 11, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 12, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 13, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 15, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 17, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 18, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 19, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 20, "path": "pydantic/json_schema.py", "score": 0.4359492063522339, "span_start": null, "span_end": null, "passage": "Args:\n            schema: The core schema Returns:\n            The generated JSON schema"}], "latency_ms": 3.483295440673828, "gold_paths": ["tests/benchmarks/test_schema_build.py"]}
{"qid": "lens_main_func_b9ec63fe", "query": "Ability to pass context to serialization (fix #7143) (#8965)", "results": [{"qid": "", "rank": 1, "path": "pydantic/functional_serializers.py", "score": 0.5467191934585571, "span_start": null, "span_end": null, "passage": "Four signatures are supported:\n\n    - `(self, value: Any, info: FieldSerializationInfo)`\n    - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`\n    - `(value: Any..."}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_generate_schema.py", "score": 0.5244083404541016, "span_start": null, "span_end": null, "passage": "See https://docs.pydantic.dev/{version_short()}/concepts/serialization/#custom-serializers for alternatives',\n            PydanticDeprecatedSince20,\n        )\n\n        # TODO: in theory we should chec..."}, {"qid": "", "rank": 3, "path": "pydantic/functional_serializers.py", "score": 0.5198586583137512, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def dec(f: Callable[..., Any]) -> _decorators.PydanticDescriptorProxy[Any]:\n        dec_info = _decorators.ModelSerializerDecoratorInfo(mode=mode, return_type=return_type, when_used=when_used..."}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.4991041421890259, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 5, "path": "tests/test_serialize.py", "score": 0.487842857837677, "span_start": null, "span_end": null, "passage": "def test_serialize_ignore_info_plain():\n    class MyModel(BaseModel):\n        x: int\n\n        @field_serializer('x')\n        def ser_x(v: Any) -> str:\n            return f'{v:,}'\n\n    assert MyModel(x..."}, {"qid": "", "rank": 6, "path": "pydantic/functional_serializers.py", "score": 0.48621994256973267, "span_start": null, "span_end": null, "passage": "@overload\ndef field_serializer(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal['wrap'],\n    return_type: Any = ...,\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-non..."}, {"qid": "", "rank": 7, "path": "pydantic/functional_serializers.py", "score": 0.4825935959815979, "span_start": null, "span_end": null, "passage": "@overload\ndef field_serializer(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal['plain'],\n    return_type: Any = ...,\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-no..."}, {"qid": "", "rank": 8, "path": "pydantic/type_adapter.py", "score": 0.4800201654434204, "span_start": null, "span_end": null, "passage": "warnings: How to handle serialization errors False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationErro..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_model_construction.py", "score": 0.47636038064956665, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __init__(self, obj: Any):\n        if obj is None:\n            # The object will be `None` upon deserialization if the serialized weakref\n            # had lost its underlying object"}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_decorators.py", "score": 0.46760672330856323, "span_start": null, "span_end": null, "passage": "An error is raised if the function has an invalid signature Args:\n        serializer: The serializer function to check mode: The serializer mode, either 'plain' or 'wrap' Returns:\n        `info_arg` -..."}, {"qid": "", "rank": 11, "path": "pydantic/functional_serializers.py", "score": 0.46387428045272827, "span_start": null, "span_end": null, "passage": "@overload\ndef model_serializer(\n    *,\n    mode: Literal['plain', 'wrap'] = ...,\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always',\n    return_type: Any = ...,\n) -..."}, {"qid": "", "rank": 12, "path": "pydantic/functional_serializers.py", "score": 0.4637763500213623, "span_start": null, "span_end": null, "passage": "\"\"\"\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class SerializeAsAny:  # noqa: D101\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item,..."}, {"qid": "", "rank": 13, "path": "tests/test_serialize.py", "score": 0.46203023195266724, "span_start": null, "span_end": null, "passage": "\"\"\"\nNew tests for v2 of serialization logic"}, {"qid": "", "rank": 14, "path": "tests/test_serialize.py", "score": 0.4603506624698639, "span_start": null, "span_end": null, "passage": "return f'{v:,}'\n\n    def ser_wrap(v: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo) -> Any:\n        return f'{nxt(v):,}'\n\n    class MyModel(BaseModel):\n        f1: int\n        f2: i..."}, {"qid": "", "rank": 15, "path": "pydantic/functional_serializers.py", "score": 0.4576360583305359, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def dec(\n        f: Callable[..., Any] | staticmethod[Any, Any] | classmethod[Any, Any, Any],\n    ) -> _decorators.PydanticDescriptorProxy[Any]:\n        dec_info = _decorators.FieldSerializer..."}, {"qid": "", "rank": 16, "path": "pydantic/functional_serializers.py", "score": 0.45688679814338684, "span_start": null, "span_end": null, "passage": "\"\"\"\n        schema = handler(source_type)\n        try:\n            return_type = _decorators.get_function_return_type(\n                self.func, self.return_type, handler._get_types_namespace()\n     ..."}, {"qid": "", "rank": 17, "path": "tests/test_serialize.py", "score": 0.4559454917907715, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nimport json\nimport re\nimport sys\nfrom enum import Enum\nfrom functools import partial, partialmethod\nfrom typing import Any, Callable, ClassVar, Dict, List, Optional, Pattern, Union\n\nimport pytest..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_model_construction.py", "score": 0.4523942470550537, "span_start": null, "span_end": null, "passage": "def __set__(self, obj: Any, value: Any) -> NoReturn:\n        raise AttributeError(self.field_name)\n\n\nclass _PydanticWeakRef:\n    \"\"\"Wrapper for `weakref.ref` that enables `pickle` serialization Cloudp..."}, {"qid": "", "rank": 19, "path": "pydantic/type_adapter.py", "score": 0.4500288665294647, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.serializer.to_python(\n            instance,\n            mode=mode,\n            by_alias=by_alias,\n            include=include,\n            exclude=exclude,\n            exclude_..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_serializers.py", "score": 0.44856852293014526, "span_start": null, "span_end": null, "passage": "def model_serializer(\n    f: Callable[..., Any] | None = None,\n    /,\n    *,\n    mode: Literal['plain', 'wrap'] = 'plain',\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] =..."}], "latency_ms": 3.6537647247314453, "gold_paths": ["pydantic/main.py", "pydantic/root_model.py", "tests/test_serialize.py"]}
{"qid": "lens_main_func_synthetic_0", "query": "authentication middleware", "results": [{"qid": "", "rank": 1, "path": "pydantic/networks.py", "score": 0.39640942215919495, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 2, "path": "pydantic/v1/env_settings.py", "score": 0.295764684677124, "span_start": null, "span_end": null, "passage": "This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),\n    Heroku and any 12 factor app design"}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.2797333300113678, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, SecretBytes\n\n    class User(BaseModel):\n        username: str\n        password: SecretBytes\n\n    user = User(username='scolvin', password=b'password1')\n    #>..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generate_schema.py", "score": 0.2786182463169098, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 5, "path": "pydantic/networks.py", "score": 0.2629280984401703, "span_start": null, "span_end": null, "passage": "* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host required\n\nAssuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export t..."}, {"qid": "", "rank": 6, "path": "tests/test_serialize_as_any.py", "score": 0.23290856182575226, "span_start": null, "span_end": null, "passage": "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\nimport pytest\nfrom typing_extensions import TypedDict\n\nfrom pydantic import BaseModel, ConfigDict, RootModel, SecretStr..."}, {"qid": "", "rank": 7, "path": "tests/test_types.py", "score": 0.22075237333774567, "span_start": null, "span_end": null, "passage": "# Use bytes that can't be decoded with UTF8 (https://github.com/pydantic/pydantic/issues/7971)\n    password = b'\\x89PNG\\r\\n\\x1a\\n'\n    f = Foobar(password=password, empty_password=b'')\n\n    # Assert c..."}, {"qid": "", "rank": 8, "path": "pydantic/types.py", "score": 0.21620193123817444, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, SecretStr\n\n    class User(BaseModel):\n        username: str\n        password: SecretStr\n\n    user = User(username='scolvin', password='password1')\n\n    print(..."}, {"qid": "", "rank": 9, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.21539553999900818, "span_start": null, "span_end": null, "passage": "Then there are the registration hooks below"}, {"qid": "", "rank": 10, "path": "tests/test_networks.py", "score": 0.2149895578622818, "span_start": null, "span_end": null, "passage": "import json\nfrom typing import Union\n\nimport pytest\nfrom pydantic_core import PydanticCustomError, Url\nfrom typing_extensions import Annotated\n\nfrom pydantic import (\n    AmqpDsn,\n    AnyUrl,\n    Base..."}, {"qid": "", "rank": 11, "path": "pydantic/networks.py", "score": 0.21283161640167236, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n\"\"\"\nClickHouseDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=['clickhouse+native', 'clickhouse+asynch'],\n        default_..."}, {"qid": "", "rank": 12, "path": "pydantic/networks.py", "score": 0.21048638224601746, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required (e.g., `rediss://:pass@localhost`)\n\"\"\"\nMongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=['mongodb', 'mongodb+srv'], default_por..."}, {"qid": "", "rank": 13, "path": "pydantic/networks.py", "score": 0.20758122205734253, "span_start": null, "span_end": null, "passage": "\"\"\"\nKafkaDsn = Annotated[Url, UrlConstraints(allowed_schemes=['kafka'], default_host='localhost', default_port=9092)]\n\"\"\"A type that will accept any Kafka DSN * User info required\n* TLD not required\n*..."}, {"qid": "", "rank": 14, "path": "pydantic/json_schema.py", "score": 0.19888192415237427, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 15, "path": "tests/test_types.py", "score": 0.19556903839111328, "span_start": null, "span_end": null, "passage": "assert f == f.model_copy()\n    copied_with_changes = f.model_copy()\n    copied_with_changes.password = SecretBytes(b'4321')\n    assert f != copied_with_changes\n\n\ndef test_secretbytes_equality():\n    a..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.19324791431427002, "span_start": null, "span_end": null, "passage": "When generating a schema for validation, we return the validation JSON schema for the first step in the chain For serialization, we return the serialization JSON schema for the last step in the chain ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/networks.py", "score": 0.18571603298187256, "span_start": null, "span_end": null, "passage": "\"\"\"\n        host, tld, host_type, rebuild = cls.validate_host(parts)\n\n        return cls(\n            None if rebuild else url,\n            scheme=parts['scheme'],\n            user=parts['user'],\n    ..."}, {"qid": "", "rank": 18, "path": "pydantic/types.py", "score": 0.1832720935344696, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 19, "path": "pydantic/types.py", "score": 0.18103569746017456, "span_start": null, "span_end": null, "passage": "\"\n                    'Please use Secret[<type>], or subclass from Secret[<type>] instead.'\n                )\n\n        inner_schema = handler.generate_schema(inner_type)  # type: ignore\n\n        def v..."}, {"qid": "", "rank": 20, "path": "pydantic/networks.py", "score": 0.1790163815021515, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n\"\"\"\nAmqpDsn = Annotated[Url, UrlConstraints(allowed_schemes=['amqp', 'amqps'])]\n\"\"\"A type that will accept any AMQP DSN * User info required\n* T..."}], "latency_ms": 3.406524658203125, "gold_paths": ["pydantic/class_validators.py"]}
{"qid": "lens_main_func_synthetic_1", "query": "error handling function", "results": [{"qid": "", "rank": 1, "path": "pydantic/v1/mypy.py", "score": 0.4845017194747925, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.4845017194747925, "span_start": null, "span_end": null, "passage": "In particular:\n        * Check whether the default and default_factory argument is specified * Output an error if both are specified * Retrieve the type of the argument which is specified, and use it ..."}, {"qid": "", "rank": 3, "path": "pydantic/plugin/__init__.py", "score": 0.46173983812332153, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return\n\n    def on_exception(self, exception: Exception) -> None:\n        \"\"\"Callback to be notified of validation exceptions Args:\n            exception: The exception raised during valid..."}, {"qid": "", "rank": 4, "path": "pydantic/deprecated/class_validators.py", "score": 0.45743316411972046, "span_start": null, "span_end": null, "passage": "allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n            the decorated function Defaults to False Returns:\n        Callable: A decorator that can be..."}, {"qid": "", "rank": 5, "path": "pydantic/types.py", "score": 0.44554662704467773, "span_start": null, "span_end": null, "passage": "\"\"\"\n    custom_error_type: str | None = None\n    \"\"\"Type to use in [custom errors](../errors/errors.md#custom-errors) replacing the standard discriminated union\n    validation errors"}, {"qid": "", "rank": 6, "path": "pydantic/deprecated/class_validators.py", "score": 0.43763405084609985, "span_start": null, "span_end": null, "passage": "Args:\n        pre (bool, optional): Whether this validator should be called before the standard\n            validators (else after) Defaults to False skip_on_failure (bool, optional): Whether to stop ..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_decorators.py", "score": 0.43132466077804565, "span_start": null, "span_end": null, "passage": "An error is raised if the function has an invalid signature Args:\n        validator: The validator function to inspect mode: The proposed validator mode Returns:\n        Whether the validator takes an..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/datetime_parse.py", "score": 0.4059426784515381, "span_start": null, "span_end": null, "passage": "Raise ValueError if the input is well formatted but not a valid time Raise ValueError if the input isn't well formatted, in particular if it contains an offset"}, {"qid": "", "rank": 9, "path": "pydantic/_migration.py", "score": 0.4009707570075989, "span_start": null, "span_end": null, "passage": "Args:\n        module: The module name Returns:\n        A callable that will raise an error if the object is not found \"\"\"\n    # This avoids circular import with errors.py from .errors import PydanticI..."}, {"qid": "", "rank": 10, "path": "pydantic/deprecated/class_validators.py", "score": 0.3981131315231323, "span_start": null, "span_end": null, "passage": "@overload\ndef root_validator(\n    *,\n    # if you specify `pre=True` then you don't need to specify\n    # `skip_on_failure`, in fact it is not allowed as an argument pre: Literal[True],\n    allow_reus..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/class_validators.py", "score": 0.39233332872390747, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if _func:\n        f_cls = _prepare_validator(_func, allow_reuse)\n        setattr(\n            f_cls, ROOT_VALIDATOR_CONFIG_KEY, Validator(func=f_cls.__func__, pre=pre, skip_on_failure=skip_on_..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_decorators.py", "score": 0.38997137546539307, "span_start": null, "span_end": null, "passage": "An error is raised if the function has an invalid signature Args:\n        serializer: The serializer function to check mode: The serializer mode, either 'plain' or 'wrap' Returns:\n        `info_arg` -..."}, {"qid": "", "rank": 13, "path": "pydantic/deprecated/decorator.py", "score": 0.3897230923175812, "span_start": null, "span_end": null, "passage": "@deprecated(\n    'The `validate_arguments` method is deprecated; use `validate_call` instead.',\n    category=None,\n)\ndef validate_arguments(func: Optional['AnyCallableT'] = None, *, config: 'ConfigTyp..."}, {"qid": "", "rank": 14, "path": "pydantic/plugin/__init__.py", "score": 0.38792684674263, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    on_enter: Callable[..., None]\n    \"\"\"`on_enter` is changed to be more specific on all subclasses\"\"\"\n\n    def on_success(self, result: Any) -> None:\n        \"\"\"Callback to be notified of succe..."}, {"qid": "", "rank": 15, "path": "pydantic/types.py", "score": 0.3863063454627991, "span_start": null, "span_end": null, "passage": "Also provides a way to label a union case in error messages When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\n    should be used to identify tha..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_typing_extra.py", "score": 0.38518959283828735, "span_start": null, "span_end": null, "passage": "'\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_typ..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/decorator.py", "score": 0.3836735785007477, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def validate(_func: 'AnyCallable') -> 'AnyCallable':\n        vd = ValidatedFunction(_func, config)\n\n        @wraps(_func)\n        def wrapper_function(*args: Any, **kwargs: Any) -> Any:\n     ..."}, {"qid": "", "rank": 18, "path": "pydantic/v1/datetime_parse.py", "score": 0.38291043043136597, "span_start": null, "span_end": null, "passage": "Raise ValueError if the input is well formatted but not a valid date Raise ValueError if the input isn't well formatted"}, {"qid": "", "rank": 19, "path": "tests/plugin/example_plugin.py", "score": 0.3814902603626251, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nm = MyModel(x='10')\nif m.x != 10:\n    raise ValueError('m.x should be 10')\n\nlog = []\n\n\nclass ValidatePythonHandler:\n    def on_e..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/validators.py", "score": 0.38114869594573975, "span_start": null, "span_end": null, "passage": "use a different JSON library like ujson\n    if isinstance(v, (str, bytes, bytearray)) and len(v) > max_str_int:\n        raise errors.IntegerError()\n\n    try:\n        return int(v)\n    except (TypeErro..."}], "latency_ms": 3.5037994384765625, "gold_paths": ["pydantic/datetime_parse.py"]}
{"qid": "lens_main_func_synthetic_2", "query": "data validation logic", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_decorators.py", "score": 0.5998122096061707, "span_start": null, "span_end": null, "passage": "\"\"\"Logic related to validators applied to models etc"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.5590737462043762, "span_start": null, "span_end": null, "passage": "\"\"\"Logic for V1 validators, e.g"}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.5535300970077515, "span_start": null, "span_end": null, "passage": "This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not You might want to enable this setting if you want to validate your data faster (basic..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/main.py", "score": 0.5242290496826172, "span_start": null, "span_end": null, "passage": "Raises ValidationError if the input data cannot be parsed to form a valid model"}, {"qid": "", "rank": 5, "path": "pydantic/v1/class_validators.py", "score": 0.5184290409088135, "span_start": null, "span_end": null, "passage": "def root_validator(\n    _func: Optional[AnyCallable] = None, *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False\n) -> Union['AnyClassMethod', Callable[[AnyCallable], 'AnyCla..."}, {"qid": "", "rank": 6, "path": "pydantic/deprecated/class_validators.py", "score": 0.5180598497390747, "span_start": null, "span_end": null, "passage": "each_item (bool, optional): For complex objects (sets, lists etc.) whether to validate\n            individual elements rather than the whole object Defaults to False always (bool, optional): Whether t..."}, {"qid": "", "rank": 7, "path": "pydantic/functional_validators.py", "score": 0.490131139755249, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 8, "path": "pydantic/functional_validators.py", "score": 0.4901310205459595, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 9, "path": "pydantic/functional_validators.py", "score": 0.4901310205459595, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 10, "path": "pydantic/functional_validators.py", "score": 0.4901310205459595, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 11, "path": "pydantic/types.py", "score": 0.4875437617301941, "span_start": null, "span_end": null, "passage": "Attributes:\n        strict: Whether to validate the field in strict mode"}, {"qid": "", "rank": 12, "path": "pydantic/functional_validators.py", "score": 0.4787942171096802, "span_start": null, "span_end": null, "passage": "Args:\n        field: The first field the `field_validator` should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one *fields: Addition..."}, {"qid": "", "rank": 13, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4781385660171509, "span_start": null, "span_end": null, "passage": "This serves as an auxiliary function for re-implementing that logic, by looping over a provided\n    collection of (v1-style) ValidatorDecoratorInfo's and checking if any of them have `always=True` We ..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/fields.py", "score": 0.47210925817489624, "span_start": null, "span_end": null, "passage": "The schema\n      will have an ``exclusiveMaximum`` validation keyword\n    :param le: only applies to numbers, requires the field to be \"less than or equal to\" The\n      schema will have a ``maximum`` ..."}, {"qid": "", "rank": 15, "path": "tests/test_validators_dataclass.py", "score": 0.46709373593330383, "span_start": null, "span_end": null, "passage": "from dataclasses import asdict, is_dataclass\nfrom typing import Any, List\n\nimport pytest\nfrom dirty_equals import HasRepr\n\nfrom pydantic import ValidationError, field_validator, model_validator\nfrom p..."}, {"qid": "", "rank": 16, "path": "pydantic/functional_validators.py", "score": 0.4627252221107483, "span_start": null, "span_end": null, "passage": "You can also use `SkipValidation[int]` as a shorthand for `Annotated[int, SkipValidation]` This can be useful if you want to use a type annotation for documentation/IDE/type-checking purposes,\n       ..."}, {"qid": "", "rank": 17, "path": "pydantic/_internal/_decorators_v1.py", "score": 0.4585873484611511, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if pre is True:\n        # mode='before' for pydantic-core\n        def _wrapper1(values: RootValidatorValues, _: core_schema.ValidationInfo) -> RootValidatorValues:\n            return validator..."}, {"qid": "", "rank": 18, "path": "tests/test_validators.py", "score": 0.4584934711456299, "span_start": null, "span_end": null, "passage": "c: int = 0\n\n        @field_validator('b')\n        @classmethod\n        def b_length(cls, v, info):\n            values = info.data\n            if 'a' in values and len(v) < values['a']:\n               ..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_generate_schema.py", "score": 0.4577138423919678, "span_start": null, "span_end": null, "passage": "(Or we can extend it and keep it if we add something equivalent\n    to the v1-validator `always` kwarg to `field_validator`.)\n    \"\"\"\n    for validator in validators:\n        if validator.info.always:..."}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.45469796657562256, "span_start": null, "span_end": null, "passage": "Args:\n        mode: A required string literal that specifies the validation mode It can be one of the following: 'wrap', 'before', or 'after' Returns:\n        A decorator that can be used to decorate ..."}], "latency_ms": 3.3812522888183594, "gold_paths": ["pydantic/decorator.py"]}
{"qid": "lens_main_func_synthetic_3", "query": "configuration parser", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_config.py", "score": 0.5214386582374573, "span_start": null, "span_end": null, "passage": "Args:\n        config_dict: The input config"}, {"qid": "", "rank": 2, "path": "pydantic/_internal/_config.py", "score": 0.4806288778781891, "span_start": null, "span_end": null, "passage": "old class-based config) or None Args:\n        config: The input config Returns:\n        A ConfigDict object created from config"}, {"qid": "", "rank": 3, "path": "pydantic/v1/config.py", "score": 0.4441946744918823, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\ndef get_config(config: Union[ConfigDict, Type[object], None]) -> Type[BaseConfig]:\n    if config is None:\n        return BaseConfig\n\n    else:\n        config_dict = (\n            co..."}, {"qid": "", "rank": 4, "path": "pydantic/mypy.py", "score": 0.4375761151313782, "span_start": null, "span_end": null, "passage": "It includes the config if config value is not `None`"}, {"qid": "", "rank": 5, "path": "pydantic/mypy.py", "score": 0.4257282614707947, "span_start": null, "span_end": null, "passage": "It reads configs from toml file and returns `None` if the file is not a toml file"}, {"qid": "", "rank": 6, "path": "pydantic/mypy.py", "score": 0.4155880808830261, "span_start": null, "span_end": null, "passage": "Attributes:\n        tracked_config_fields: A set of field configs that the plugin has to track their value"}, {"qid": "", "rank": 7, "path": "pydantic/v1/mypy.py", "score": 0.4154408276081085, "span_start": null, "span_end": null, "passage": "import sys\nfrom configparser import ConfigParser\nfrom typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as TypingType, Union\n\nfrom mypy.errorcodes import ErrorCode\nfrom mypy.nodes im..."}, {"qid": "", "rank": 8, "path": "pydantic/_internal/_config.py", "score": 0.40362459421157837, "span_start": null, "span_end": null, "passage": "The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        A..."}, {"qid": "", "rank": 9, "path": "pydantic/mypy.py", "score": 0.40287062525749207, "span_start": null, "span_end": null, "passage": "Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)\n        \"\"\"\n        if name not in self.tracked_config_fields:\n            return None\n   ..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/env_settings.py", "score": 0.3958711326122284, "span_start": null, "span_end": null, "passage": "\"\"\"\n        d: Dict[str, Any] = {}\n\n        if settings.__config__.case_sensitive:\n            env_vars: Mapping[str, Optional[str]] = os.environ\n        else:\n            env_vars = {k.lower(): v for..."}, {"qid": "", "rank": 11, "path": "pydantic/v1/networks.py", "score": 0.3952699303627014, "span_start": null, "span_end": null, "passage": "host1.db.net,host2.db.net\n    \"\"\"\n    global _multi_host_url_regex_cache\n    if _multi_host_url_regex_cache is None:\n        _multi_host_url_regex_cache = re.compile(\n            rf'{_scheme_regex}{_u..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_std_types_schema.py", "score": 0.3951604962348938, "span_start": null, "span_end": null, "passage": "\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport collections\nimport collections.abc\nimport dataclasses\nimport decimal\nimport inspect\nimport os\nimport typing\nfrom enum import Enum\nfrom f..."}, {"qid": "", "rank": 13, "path": "tests/mypy/outputs/1.4.1/pyproject-plugin_toml/pydantic_settings.py", "score": 0.3949432969093323, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 14, "path": "tests/mypy/outputs/1.4.1/mypy-plugin_ini/pydantic_settings.py", "score": 0.3949432969093323, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 15, "path": "tests/mypy/modules/pydantic_settings.py", "score": 0.392244815826416, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 16, "path": "tests/mypy/outputs/1.0.1/pyproject-plugin_toml/pydantic_settings.py", "score": 0.3895455002784729, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 17, "path": "tests/mypy/outputs/1.0.1/pyproject-default_toml/pydantic_settings.py", "score": 0.3895455002784729, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 18, "path": "tests/mypy/outputs/1.0.1/mypy-plugin_ini/pydantic_settings.py", "score": 0.3895455002784729, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 19, "path": "tests/mypy/outputs/1.0.1/mypy-default_ini/pydantic_settings.py", "score": 0.3895455002784729, "span_start": null, "span_end": null, "passage": "from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    foo: str\n\n\ns = Settings()\n\ns = Settings(foo='test', _case_sensitive=True, _env_prefix='test__', _env_..."}, {"qid": "", "rank": 20, "path": "pydantic/v1/class_validators.py", "score": 0.37866637110710144, "span_start": null, "span_end": null, "passage": "Unfortunately other approaches (eg return a partial of a function that builds the arguments) is slow,\n    hence this laborious way of doing things It's done like this so validators don't all need **kw..."}], "latency_ms": 3.547191619873047, "gold_paths": ["pydantic/env_settings.py"]}
{"qid": "lens_main_func_synthetic_4", "query": "logging utility", "results": [{"qid": "", "rank": 1, "path": "tests/plugin/example_plugin.py", "score": 0.2804566025733948, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nm = MyModel(x='10')\nif m.x != 10:\n    raise ValueError('m.x should be 10')\n\nlog = []\n\n\nclass ValidatePythonHandler:\n    def on_e..."}, {"qid": "", "rank": 2, "path": "pydantic/mypy.py", "score": 0.2609905004501343, "span_start": null, "span_end": null, "passage": "Attributes:\n        tracked_config_fields: A set of field configs that the plugin has to track their value"}, {"qid": "", "rank": 3, "path": "tests/plugin/test_plugin.py", "score": 0.24942190945148468, "span_start": null, "span_end": null, "passage": "import os\n\nimport pytest\n\npytestmark = pytest.mark.skipif(not os.getenv('TEST_PLUGIN'), reason='Test only with `TEST_PLUGIN` env var set.')\n\n\ndef test_plugin_usage():\n    from pydantic import BaseMode..."}, {"qid": "", "rank": 4, "path": "pydantic/config.py", "score": 0.24911940097808838, "span_start": null, "span_end": null, "passage": "Can be useful for debugging Defaults to `False` Note:\n        Python 3.10 and older don't support exception groups natively <=3.10, backport must be installed: `pip install exceptiongroup` Note:\n     ..."}, {"qid": "", "rank": 5, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.2438599020242691, "span_start": null, "span_end": null, "passage": "Args:\n        annotations: An iterable of annotations Returns:\n        An iterable of expanded annotations"}, {"qid": "", "rank": 6, "path": ".github/actions/people/people.py", "score": 0.23828181624412537, "span_start": null, "span_end": null, "passage": "\"\"\"\nimport requests\nimport logging\nimport subprocess\nimport sys\nfrom collections import Counter\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Any, Cont..."}, {"qid": "", "rank": 7, "path": "pydantic/_internal/_known_annotated_metadata.py", "score": 0.23670050501823425, "span_start": null, "span_end": null, "passage": "Args:\n        annotations: An iterable of annotations Returns:\n        A tuple contains a dict of known metadata and a list of unknown annotations"}, {"qid": "", "rank": 8, "path": "pydantic/types.py", "score": 0.23599322140216827, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return Annotated[  # pyright: ignore[reportReturnType]\n        date,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n    ]..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.23350569605827332, "span_start": null, "span_end": null, "passage": "(The list[list[str]] here\n            #   is the appropriate way to provide a list of fallback attributes to check for a discriminator value.)\n            discriminator: str | list[list[str | int]] = ..."}, {"qid": "", "rank": 10, "path": "pydantic/json_schema.py", "score": 0.23227393627166748, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n\nclass PydanticJsonSchemaWarning(UserWarning):\n    \"\"\"This class is used to emit warnings produced during JSON schema generation See the [`GenerateJsonSchema.emit_warning`][pydantic.json_schema.G..."}, {"qid": "", "rank": 11, "path": "pydantic/type_adapter.py", "score": 0.22860215604305267, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self.serializer.to_python(\n            instance,\n            mode=mode,\n            by_alias=by_alias,\n            include=include,\n            exclude=exclude,\n            exclude_..."}, {"qid": "", "rank": 12, "path": "pydantic/_internal/_generate_schema.py", "score": 0.22571232914924622, "span_start": null, "span_end": null, "passage": "The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is"}, {"qid": "", "rank": 13, "path": "pydantic/fields.py", "score": 0.22338402271270752, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    annotation: type[Any] | None\n    default: Any\n    default_factory: typing.Callable[[], Any] | None\n    alias: str | None\n    alias_priority: int | None\n    validation_alias: str | AliasPath |..."}, {"qid": "", "rank": 14, "path": "pydantic/types.py", "score": 0.22285661101341248, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return self._secret_value\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()\n\n    def __has..."}, {"qid": "", "rank": 15, "path": "pydantic/fields.py", "score": 0.2217009961605072, "span_start": null, "span_end": null, "passage": "\"\"\"\n        metadata: list[Any] = []\n        general_metadata = {}\n        for key, value in list(kwargs.items()):\n            try:\n                marker = FieldInfo.metadata_lookup[key]\n            ..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/env_settings.py", "score": 0.22084671258926392, "span_start": null, "span_end": null, "passage": "This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),\n    Heroku and any 12 factor app design"}, {"qid": "", "rank": 17, "path": "tests/test_main.py", "score": 0.22081750631332397, "span_start": null, "span_end": null, "passage": "with warnings.catch_warnings(record=True) as captured_warnings:\n        # Start capturing all warnings\n        warnings.simplefilter('always')\n\n        class ChildWithoutRedefinedField(BaseModel, Pare..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_schema_generation_shared.py", "score": 0.22007161378860474, "span_start": null, "span_end": null, "passage": "\"\"\"Types and utility functions used by various other internal tools.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import core_schema\nfrom..."}, {"qid": "", "rank": 19, "path": "pydantic/deprecated/config.py", "score": 0.22002172470092773, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n    def __getattr__(self, item: str) -> Any:\n        try:\n            obj = super().__getattribute__(item)\n            warnings.warn(_config.DEPRECATION_MESSAGE, DeprecationWarning)\n            r..."}, {"qid": "", "rank": 20, "path": "pydantic/_internal/_repr.py", "score": 0.21566623449325562, "span_start": null, "span_end": null, "passage": "\"\"\"Tools to provide pretty/human-readable display of objects.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport types\nimport typing\nfrom typing import Any\n\nimport typing_extensions\n\nfrom"}], "latency_ms": 3.4332275390625, "gold_paths": ["pydantic/error_wrappers.py"]}
{"qid": "lens_main_func_synthetic_5", "query": "cache management", "results": [{"qid": "", "rank": 1, "path": "pydantic/_internal/_generics.py", "score": 0.4638787508010864, "span_start": null, "span_end": null, "passage": "As a concrete example, this approach was necessary to make Model[List[T]][int] equal to Model[List[int]] The approach could be modified to not use two different cache keys at different points, but the..."}, {"qid": "", "rank": 2, "path": "pydantic/fields.py", "score": 0.42731449007987976, "span_start": null, "span_end": null, "passage": "This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached"}, {"qid": "", "rank": 3, "path": "pydantic/_internal/_generics.py", "score": 0.4175855815410614, "span_start": null, "span_end": null, "passage": "If we wanted to move to only using a single cache key per type, we would either need to always use the\n    slower/more computationally intensive logic associated with _late_cache_key, or would need to..."}, {"qid": "", "rank": 4, "path": "pydantic/_internal/_generics.py", "score": 0.3947770595550537, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return _GENERIC_TYPES_CACHE.get(_early_cache_key(parent, typevar_values))\n\n\ndef get_cached_generic_type_late(\n    parent: type[BaseModel], typevar_values: Any, origin: type[BaseModel], args: t..."}, {"qid": "", "rank": 5, "path": "tests/test_edge_cases.py", "score": 0.3929624557495117, "span_start": null, "span_end": null, "passage": "functools.cached_property,\n    which caches the computed values in the instance's __dict__\n    \"\"\"\n\n    class Model(BaseModel):\n        attr: int\n\n        @functools.cached_property\n        def cached..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/generics.py", "score": 0.3829973340034485, "span_start": null, "span_end": null, "passage": "\"\"\"\n\n        def _cache_key(_params: Any) -> CacheKey:\n            args = get_args(_params)\n            # python returns a list for Callables, which is not hashable\n            if len(args) == 2 and i..."}, {"qid": "", "rank": 7, "path": "pydantic/config.py", "score": 0.3782406449317932, "span_start": null, "span_end": null, "passage": "Enabling this setting should significantly improve validation performance while increasing memory usage slightly - `True` or `'all'` (the default): cache all strings\n    - `'keys'`: cache only diction..."}, {"qid": "", "rank": 8, "path": "pydantic/v1/generics.py", "score": 0.3744552731513977, "span_start": null, "span_end": null, "passage": "_generic_types_cache = GenericTypesCache()\n\n# _assigned_parameters is a Mapping from parametrized version of generic models to assigned types of parametrizations\n# as captured during construction of t..."}, {"qid": "", "rank": 9, "path": "pydantic/_internal/_generics.py", "score": 0.36918115615844727, "span_start": null, "span_end": null, "passage": "KT = TypeVar('KT')\nVT = TypeVar('VT')\n_LIMITED_DICT_SIZE = 100\nif TYPE_CHECKING:\n\n    class LimitedDict(dict, MutableMapping[KT, VT]):\n        def __init__(self, size_limit: int = _LIMITED_DICT_SIZE):..."}, {"qid": "", "rank": 10, "path": "pydantic/_internal/_generics.py", "score": 0.3630565404891968, "span_start": null, "span_end": null, "passage": "If it turns out that a different set of inputs to\n    __class_getitem__ resulted in the same inputs to the generic type creation process, we can still\n    return the cached type, and update the cache ..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_generics.py", "score": 0.3588726818561554, "span_start": null, "span_end": null, "passage": "#   Right now, to handle recursive generics, we some types must remain cached for brief periods without references #   By chaining the WeakValuesDict with a LimitedDict, we have a way to retain cachin..."}, {"qid": "", "rank": 12, "path": "tests/test_generics.py", "score": 0.3160807490348816, "span_start": null, "span_end": null, "passage": "# Make sure we can handle that special case\n    Simple = MyGenericModel[Callable[[int], str]]\n    models = []  # keep references to models to get cache size\n    models.append(Simple)\n\n    assert len(_..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/generics.py", "score": 0.31537753343582153, "span_start": null, "span_end": null, "passage": "_generic_types_cache[_cache_key(params)] = created_model\n        if len(params) == 1:\n            _generic_types_cache[_cache_key(params[0])] = created_model\n\n        # Recursively walk class type hin..."}, {"qid": "", "rank": 14, "path": "tests/test_generics.py", "score": 0.3142705261707306, "span_start": null, "span_end": null, "passage": "concrete = MyGeneric[Model]\n        _GENERIC_TYPES_CACHE.clear()\n        second_concrete = MyGeneric[Model]\n\n        class Model(BaseModel):  # same name, but type different, so it's not in cache\n    ..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_generics.py", "score": 0.31398287415504456, "span_start": null, "span_end": null, "passage": "Note that this is overly simplistic, and it's possible that two different cls/typevar_values\n    inputs would ultimately result in the same type being created in BaseModel.__class_getitem__ To handle ..."}, {"qid": "", "rank": 16, "path": "pydantic/_internal/_generics.py", "score": 0.29738160967826843, "span_start": null, "span_end": null, "passage": "\"\"\"\n    _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values)] = type_\n    if len(typevar_values) == 1:\n        _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values[0])] = type_\n    if..."}, {"qid": "", "rank": 17, "path": "pydantic/v1/generics.py", "score": 0.2920795977115631, "span_start": null, "span_end": null, "passage": "if sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[CacheKey, Type[BaseModel]]\n    AssignedParameters = WeakKeyDictionary[Type[B..."}, {"qid": "", "rank": 18, "path": "pydantic/_internal/_generics.py", "score": 0.28126686811447144, "span_start": null, "span_end": null, "passage": "\"\"\"\n    return cls, typevar_values, _union_orderings_key(typevar_values)\n\n\ndef _late_cache_key(origin: type[BaseModel], args: tuple[Any, ...], typevar_values: Any) -> GenericTypesCacheKey:\n    \"\"\"This..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_generics.py", "score": 0.2786717414855957, "span_start": null, "span_end": null, "passage": "(See https://github.com/python/cpython/issues/86483 for reference.)\n    \"\"\"\n    if isinstance(typevar_values, tuple):\n        args_data = []\n        for value in typevar_values:\n            args_data...."}, {"qid": "", "rank": 20, "path": "tests/benchmarks/basemodel_eq_performance.py", "score": 0.2754810154438019, "span_start": null, "span_end": null, "passage": "This makes our timing comparison incorrect\n        # However, the value must be different, otherwise *our* __dict__ == right.__dict__\n        # fast-path prevents our correct code from running\n       ..."}], "latency_ms": 3.3795833587646484, "gold_paths": ["pydantic/generics.py"]}
{"qid": "lens_main_func_synthetic_6", "query": "user permission check", "results": [{"qid": "", "rank": 1, "path": "tests/test_type_hints.py", "score": 0.24920554459095, "span_start": null, "span_end": null, "passage": ":param obj_type: Type to check\n    :param members: Explicit set of members to check, None to check all\n    :param exclude_members: Set of member names to exclude\n    :param recursion_limit: Recursion ..."}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.2246604859828949, "span_start": null, "span_end": null, "passage": "except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Transaction\n        user.hobbies.0\n          Input should be a valid string [type=string_type, input_value=1, i..."}, {"qid": "", "rank": 3, "path": "tests/pyright/pyright_example.py", "score": 0.22441989183425903, "span_start": null, "span_end": null, "passage": "\"\"\"\nThis file is used to test pyright's ability to check pydantic code"}, {"qid": "", "rank": 4, "path": "pydantic/v1/dataclasses.py", "score": 0.2240714430809021, "span_start": null, "span_end": null, "passage": "# for example if Extra.forbid is enabled, it would consider __pydantic_initialised__ an invalid extra property\n    if getattr(self, '__pydantic_initialised__'):\n        return\n    if getattr(self, '__..."}, {"qid": "", "rank": 5, "path": "pydantic/config.py", "score": 0.2212027758359909, "span_start": null, "span_end": null, "passage": "print(t)\n    #> user=User(hobbies=[1])\n\n    my_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\n    t = Transaction(user=my_sub_user)\n    print(t)\n    #> user=SubUser(hobbies=['scuba divin..."}, {"qid": "", "rank": 6, "path": "pydantic/v1/networks.py", "score": 0.20448219776153564, "span_start": null, "span_end": null, "passage": "Could be overridden to set default values for parts if missing\n        \"\"\"\n        scheme = parts['scheme']\n        if scheme is None:\n            raise errors.UrlSchemeError()\n\n        if cls.allowed..."}, {"qid": "", "rank": 7, "path": "pydantic/config.py", "score": 0.2014497071504593, "span_start": null, "span_end": null, "passage": "except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for User\n        name\n          Input should be a valid string [type=string_type, input_value=123, input_type=int]\n..."}, {"qid": "", "rank": 8, "path": "pydantic/config.py", "score": 0.19873249530792236, "span_start": null, "span_end": null, "passage": "#> user=User(hobbies=['scuba diving'])\n    ```\n\n    1 `revalidate_instances` is set to `'subclass-instances'` 2 This is not revalidated, since `my_user` is not a subclass of `User` 3 Using `'never'` w..."}, {"qid": "", "rank": 9, "path": ".github/actions/people/people.py", "score": 0.19859224557876587, "span_start": null, "span_end": null, "passage": "\"\"\"Use the github API to get lists of people who have contributed in various ways to Pydantic This logic is inspired by that of @tiangolo's\n[FastAPI people script](https://github.com/tiangolo/fastapi/..."}, {"qid": "", "rank": 10, "path": "pydantic/mypy.py", "score": 0.19710436463356018, "span_start": null, "span_end": null, "passage": "Note that you can still get proper type checking via: `model_config = ConfigDict(...)`, just\n                    # if you don't use an explicit string, the plugin won't be able to infer whether extra ..."}, {"qid": "", "rank": 11, "path": "tests/test_dataclasses.py", "score": 0.19651462137699127, "span_start": null, "span_end": null, "passage": "while working on one specific test"}, {"qid": "", "rank": 12, "path": "pydantic/deprecated/class_validators.py", "score": 0.19497543573379517, "span_start": null, "span_end": null, "passage": "allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n            the decorated function Defaults to False Returns:\n        Callable: A decorator that can be..."}, {"qid": "", "rank": 13, "path": "pydantic/errors.py", "score": 0.19302362203598022, "span_start": null, "span_end": null, "passage": "# 'u' refers to \"user errors\" - e.g errors caused by developers using pydantic, as opposed to validation errors"}, {"qid": "", "rank": 14, "path": "tests/mypy/outputs/1.0.1/pyproject-plugin-strict-equality_toml/strict_equality.py", "score": 0.19128715991973877, "span_start": null, "span_end": null, "passage": "from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    username: str\n\n\nuser = User(username='test')\nprint(user == 'test')\n# MYPY: error: Non-overlapping equality check (left operand type: \"User\",..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_decorators.py", "score": 0.1898493766784668, "span_start": null, "span_end": null, "passage": "\"\"\"\n    if ismethoddescriptor(f) or isdatadescriptor(f):\n        return f\n    else:\n        return property(f)"}, {"qid": "", "rank": 16, "path": "pydantic/v1/env_settings.py", "score": 0.18949556350708008, "span_start": null, "span_end": null, "passage": "\"\"\"\n    for f in dir_path.iterdir():\n        if f.name == file_name:\n            return f\n        elif not case_sensitive and f.name.lower() == file_name.lower():\n            return f\n    return None"}, {"qid": "", "rank": 17, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.18907251954078674, "span_start": null, "span_end": null, "passage": "Then there are the registration hooks below"}, {"qid": "", "rank": 18, "path": "pydantic/config.py", "score": 0.1872604638338089, "span_start": null, "span_end": null, "passage": "With `extra='forbid'`, an error is raised:\n\n    ```py\n    from pydantic import BaseModel, ConfigDict, ValidationError\n\n\n    class User(BaseModel):\n        model_config = ConfigDict(extra='forbid')\n\n  ..."}, {"qid": "", "rank": 19, "path": "pydantic/types.py", "score": 0.18605349957942963, "span_start": null, "span_end": null, "passage": "Returns:\n            The secret value"}, {"qid": "", "rank": 20, "path": "pydantic/config.py", "score": 0.18218880891799927, "span_start": null, "span_end": null, "passage": "hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n  ..."}], "latency_ms": 3.428936004638672, "gold_paths": ["pydantic/json.py"]}
{"qid": "lens_main_func_synthetic_7", "query": "database connection", "results": [{"qid": "", "rank": 1, "path": "pydantic/networks.py", "score": 0.34106701612472534, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n\"\"\"\nMariaDBDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=['mariadb', 'mariadb+mariadbconnector', 'mariadb+pymysql'],\n   ..."}, {"qid": "", "rank": 2, "path": "pydantic/networks.py", "score": 0.31917598843574524, "span_start": null, "span_end": null, "passage": "More: https://nats.io\n\"\"\"\nMySQLDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=[\n            'mysql',\n            'mysql+mysqlconnector',\n            'mysql+aiomysql',\n          ..."}, {"qid": "", "rank": 3, "path": "pydantic/networks.py", "score": 0.22603556513786316, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required (e.g., `rediss://:pass@localhost`)\n\"\"\"\nMongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=['mongodb', 'mongodb+srv'], default_por..."}, {"qid": "", "rank": 4, "path": "pydantic/networks.py", "score": 0.2009315937757492, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n\"\"\"\nAmqpDsn = Annotated[Url, UrlConstraints(allowed_schemes=['amqp', 'amqps'])]\n\"\"\"A type that will accept any AMQP DSN * User info required\n* T..."}, {"qid": "", "rank": 5, "path": "pydantic/networks.py", "score": 0.19880244135856628, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n* Supports multiple hosts\n\nIf further validation is required, these properties can be used by validators to enforce specific behaviour:\n\n```py\nf..."}, {"qid": "", "rank": 6, "path": "pydantic/types.py", "score": 0.18118780851364136, "span_start": null, "span_end": null, "passage": "This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not You might want to enable this setting if you want to validate your data faster (basic..."}, {"qid": "", "rank": 7, "path": "pydantic/networks.py", "score": 0.15610584616661072, "span_start": null, "span_end": null, "passage": "Attributes:\n        max_length: The maximum length of the url Defaults to `None` allowed_schemes: The allowed schemes Defaults to `None` host_required: Whether the host is required Defaults to `None` ..."}, {"qid": "", "rank": 8, "path": "tests/test_config.py", "score": 0.15343450009822845, "span_start": null, "span_end": null, "passage": "class MyModel(MyBaseModel): .."}, {"qid": "", "rank": 9, "path": "pydantic/networks.py", "score": 0.15254729986190796, "span_start": null, "span_end": null, "passage": "It is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices"}, {"qid": "", "rank": 10, "path": "pydantic/networks.py", "score": 0.15080851316452026, "span_start": null, "span_end": null, "passage": "\"\"\"\nKafkaDsn = Annotated[Url, UrlConstraints(allowed_schemes=['kafka'], default_host='localhost', default_port=9092)]\n\"\"\"A type that will accept any Kafka DSN * User info required\n* TLD not required\n*..."}, {"qid": "", "rank": 11, "path": "pydantic/networks.py", "score": 0.14779675006866455, "span_start": null, "span_end": null, "passage": "* TLD not required\n* Host required\n\"\"\"\nPostgresDsn = Annotated[\n    MultiHostUrl,\n    UrlConstraints(\n        host_required=True,\n        allowed_schemes=[\n            'postgres',\n            'postgre..."}, {"qid": "", "rank": 12, "path": "pydantic/type_adapter.py", "score": 0.14687412977218628, "span_start": null, "span_end": null, "passage": "module: The module that passes to plugin if provided !! note\n            You cannot use the `config` argument when instantiating a `TypeAdapter` if the type you're using has its own\n            config..."}, {"qid": "", "rank": 13, "path": "pydantic/v1/_hypothesis_plugin.py", "score": 0.1458510160446167, "span_start": null, "span_end": null, "passage": "Then there are the registration hooks below"}, {"qid": "", "rank": 14, "path": "pydantic/schema.py", "score": 0.13315574824810028, "span_start": null, "span_end": null, "passage": "\"\"\"The `schema` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)"}, {"qid": "", "rank": 15, "path": "pydantic/networks.py", "score": 0.1268721967935562, "span_start": null, "span_end": null, "passage": "* User info required\n* TLD not required\n* Host required\n\"\"\"\nClickHouseDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=['clickhouse+native', 'clickhouse+asynch'],\n        default_..."}, {"qid": "", "rank": 16, "path": "pydantic/v1/dataclasses.py", "score": 0.12407887727022171, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 17, "path": "pydantic/types.py", "score": 0.12357886135578156, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, SecretStr\n\n    class User(BaseModel):\n        username: str\n        password: SecretStr\n\n    user = User(username='scolvin', password='password1')\n\n    print(..."}, {"qid": "", "rank": 18, "path": "pydantic/networks.py", "score": 0.12052984535694122, "span_start": null, "span_end": null, "passage": "* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host required\n\nAssuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export t..."}, {"qid": "", "rank": 19, "path": "pydantic/_internal/_discriminated_union.py", "score": 0.11843137443065643, "span_start": null, "span_end": null, "passage": "`model_name` is accepted for the purpose of producing useful error messages"}, {"qid": "", "rank": 20, "path": "pydantic/types.py", "score": 0.117295041680336, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, SecretBytes\n\n    class User(BaseModel):\n        username: str\n        password: SecretBytes\n\n    user = User(username='scolvin', password=b'password1')\n    #>..."}], "latency_ms": 4.698991775512695, "gold_paths": ["pydantic/parse.py"]}
{"qid": "lens_main_func_synthetic_8", "query": "API response formatter", "results": [{"qid": "", "rank": 1, "path": "docs/plugins/griffe_doclinks.py", "score": 0.4681475758552551, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n'\n            f'    [`{api_link}`][{api_link}]<br>'\n            f'{content[heading_end:]}'\n        )\n\n    return f'!!"}, {"qid": "", "rank": 2, "path": "pydantic/main.py", "score": 0.4607886075973511, "span_start": null, "span_end": null, "passage": "Returns:\n            A JSON string representation of the model"}, {"qid": "", "rank": 3, "path": "pydantic/types.py", "score": 0.393799364566803, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        .. @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        \"\"\"Encode the data using the encoder Ar..."}, {"qid": "", "rank": 4, "path": "pydantic/json_schema.py", "score": 0.38462382555007935, "span_start": null, "span_end": null, "passage": "- 'serialization': Generate a JSON Schema for serializing data Returns:\n        The generated JSON Schema"}, {"qid": "", "rank": 5, "path": "pydantic/types.py", "score": 0.37448179721832275, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return base64.encodebytes(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64']:\n        \"\"\"Get the JSON format for the encoded data Returns:\n            The JSON form..."}, {"qid": "", "rank": 6, "path": "pydantic/types.py", "score": 0.3722488284111023, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return base64.urlsafe_b64encode(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64url']:\n        \"\"\"Get the JSON format for the encoded data Returns:\n            The ..."}, {"qid": "", "rank": 7, "path": "tests/test_utils.py", "score": 0.3675711154937744, "span_start": null, "span_end": null, "passage": "Given varied output, this test verifies that the content of the output is as expected,\n    Rather than doing robust formatting testing"}, {"qid": "", "rank": 8, "path": "pydantic/json_schema.py", "score": 0.3621373176574707, "span_start": null, "span_end": null, "passage": "Returns:\n            The generated JSON schema"}, {"qid": "", "rank": 9, "path": "pydantic/config.py", "score": 0.3483061194419861, "span_start": null, "span_end": null, "passage": "- `'iso8601'` will serialize timedeltas to ISO 8601 durations - `'float'` will serialize timedeltas to the total number of seconds \"\"\"\n\n    ser_json_bytes: Literal['utf8', 'base64']\n    \"\"\"\n    The en..."}, {"qid": "", "rank": 10, "path": "pydantic/v1/utils.py", "score": 0.34607845544815063, "span_start": null, "span_end": null, "passage": "Useful with Representation when you want to return a string\n    representation of something that valid (or pseudo-valid) python \"\"\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n\nclass Rep..."}, {"qid": "", "rank": 11, "path": "pydantic/_internal/_decorators.py", "score": 0.3368256688117981, "span_start": null, "span_end": null, "passage": "mode: The proposed serializer mode return_type: The type of the serializer's return value when_used: The serialization condition Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n   ..."}, {"qid": "", "rank": 12, "path": "docs/plugins/griffe_doclinks.py", "score": 0.33419644832611084, "span_start": null, "span_end": null, "passage": "api \"API Documentation\"\\n' f'    [`{api_link}`][{api_link}]<br>\\n\\n' f'{content}')\n\n    heading = file_path.stem.replace('_', ' ').title()\n    return f'!!"}, {"qid": "", "rank": 13, "path": "pydantic/functional_serializers.py", "score": 0.3237283229827881, "span_start": null, "span_end": null, "passage": "return_type: The return type for the function If omitted it will be inferred from the type annotation when_used: Determines when this serializer should be used Accepts a string with values `'always'`,..."}, {"qid": "", "rank": 14, "path": "pydantic/functional_serializers.py", "score": 0.3237283229827881, "span_start": null, "span_end": null, "passage": "return_type: The return type for the function If omitted it will be inferred from the type annotation when_used: Determines when this serializer should be used Accepts a string with values `'always'`,..."}, {"qid": "", "rank": 15, "path": "pydantic/_internal/_decorators.py", "score": 0.3217122554779053, "span_start": null, "span_end": null, "passage": "Attributes:\n        decorator_repr: A class variable representing the decorator string, '@field_serializer' fields: A tuple of field names the serializer should be called on mode: The proposed seriali..."}, {"qid": "", "rank": 16, "path": "pydantic/json_schema.py", "score": 0.3191167712211609, "span_start": null, "span_end": null, "passage": "# At the end of schema generation, we use these to produce a JSON schema with more human-readable\n        # definitions, which would also work better in a generated OpenAPI client, etc"}, {"qid": "", "rank": 17, "path": "tests/mypy/modules/generics.py", "score": 0.31632673740386963, "span_start": null, "span_end": null, "passage": "from typing import Any, Dict, Generic, Optional, TypeVar\n\nfrom pydantic import BaseModel\n\nTbody = TypeVar('Tbody')\n\n\nclass Response(BaseModel, Generic[Tbody]):\n    url: str\n    body: Tbody\n\n\nclass Jso..."}, {"qid": "", "rank": 18, "path": "pydantic/main.py", "score": 0.3149588108062744, "span_start": null, "span_end": null, "passage": "Args:\n            indent: Indentation to use in the JSON output If None is passed, the output will be compact include: Field(s) to include in the JSON output exclude: Field(s) to exclude from the JSON..."}, {"qid": "", "rank": 19, "path": "pydantic/v1/fields.py", "score": 0.31373900175094604, "span_start": null, "span_end": null, "passage": "env variables should be parsed as JSON"}, {"qid": "", "rank": 20, "path": "pydantic/types.py", "score": 0.3095223307609558, "span_start": null, "span_end": null, "passage": "Args:\n            data: The data to decode Returns:\n            The decoded data \"\"\"\n        return data.decode()\n\n    def encode_str(self, value: str) -> str:\n        \"\"\"Encode the data using the spe..."}], "latency_ms": 4.475593566894531, "gold_paths": ["pydantic/schema.py"]}
{"qid": "lens_main_func_synthetic_9", "query": "input sanitization", "results": [{"qid": "", "rank": 1, "path": "pydantic/plugin/__init__.py", "score": 0.34620538353919983, "span_start": null, "span_end": null, "passage": "\"\"\"\n        pass\n\n\nStringInput: TypeAlias = 'dict[str, StringInput]'\n\n\nclass ValidateStringsHandlerProtocol(BaseValidateHandlerProtocol, Protocol):\n    \"\"\"Event handler for `SchemaValidator.validate_s..."}, {"qid": "", "rank": 2, "path": "pydantic/config.py", "score": 0.34518489241600037, "span_start": null, "span_end": null, "passage": "'''\n    ```\n    \"\"\"\n\n    hide_input_in_errors: bool\n    \"\"\"\n    Whether to hide inputs when printing errors Defaults to `False` Pydantic shows the input value and type when it raises `ValidationError`..."}, {"qid": "", "rank": 3, "path": "pydantic/plugin/__init__.py", "score": 0.30362701416015625, "span_start": null, "span_end": null, "passage": "Args:\n            input: The input to be validated strict: Whether to validate the object in strict mode from_attributes: Whether to validate objects as inputs by extracting attributes context: The co..."}, {"qid": "", "rank": 4, "path": "pydantic/v1/datetime_parse.py", "score": 0.3019142746925354, "span_start": null, "span_end": null, "passage": "Raise ValueError if the input is well formatted but not a valid time Raise ValueError if the input isn't well formatted, in particular if it contains an offset"}, {"qid": "", "rank": 5, "path": "pydantic/v1/datetime_parse.py", "score": 0.2950981855392456, "span_start": null, "span_end": null, "passage": "Raise ValueError if the input is well formatted but not a valid date Raise ValueError if the input isn't well formatted"}, {"qid": "", "rank": 6, "path": "pydantic/plugin/__init__.py", "score": 0.28538405895233154, "span_start": null, "span_end": null, "passage": "Args:\n            input: The JSON data to be validated strict: Whether to validate the object in strict mode context: The context to use for validation, this is passed to functional validators self_in..."}, {"qid": "", "rank": 7, "path": "pydantic/v1/main.py", "score": 0.2766150236129761, "span_start": null, "span_end": null, "passage": "Raises ValidationError if the input data cannot be parsed to form a valid model"}, {"qid": "", "rank": 8, "path": "pydantic/v1/dataclasses.py", "score": 0.2763296365737915, "span_start": null, "span_end": null, "passage": "\"\"\"\nThe main purpose is to enhance stdlib dataclasses by adding validation\nA pydantic dataclass can be generated from scratch or from a stdlib one Behind the scene, a pydantic dataclass is just like a..."}, {"qid": "", "rank": 9, "path": "pydantic/types.py", "score": 0.2759941816329956, "span_start": null, "span_end": null, "passage": "It displays `b'**********'` instead of the string value on `repr()` and `str()` calls When the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\n    calls..."}, {"qid": "", "rank": 10, "path": "pydantic/types.py", "score": 0.2682495713233948, "span_start": null, "span_end": null, "passage": "Attributes:\n        strip_whitespace: Whether to remove leading and trailing whitespace to_upper: Whether to convert the string to uppercase to_lower: Whether to convert the string to lowercase strict..."}, {"qid": "", "rank": 11, "path": "pydantic/plugin/__init__.py", "score": 0.2681151330471039, "span_start": null, "span_end": null, "passage": "\"\"\"\n        return\n\n\nclass ValidatePythonHandlerProtocol(BaseValidateHandlerProtocol, Protocol):\n    \"\"\"Event handler for `SchemaValidator.validate_python`.\"\"\"\n\n    def on_enter(\n        self,\n       ..."}, {"qid": "", "rank": 12, "path": "pydantic/types.py", "score": 0.26461830735206604, "span_start": null, "span_end": null, "passage": "Also provides a way to label a union case in error messages When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\n    should be used to identify tha..."}, {"qid": "", "rank": 13, "path": "pydantic/color.py", "score": 0.2643057107925415, "span_start": null, "span_end": null, "passage": "Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg `<prefix>ffffff` (prefix..."}, {"qid": "", "rank": 14, "path": "pydantic/v1/schema.py", "score": 0.26041358709335327, "span_start": null, "span_end": null, "passage": "Otherwise we will end up with several allOf inside anyOf/oneOf"}, {"qid": "", "rank": 15, "path": "pydantic/v1/dataclasses.py", "score": 0.258832186460495, "span_start": null, "span_end": null, "passage": "# for example if Extra.forbid is enabled, it would consider __pydantic_initialised__ an invalid extra property\n    if getattr(self, '__pydantic_initialised__'):\n        return\n    if getattr(self, '__..."}, {"qid": "", "rank": 16, "path": "pydantic/config.py", "score": 0.25191208720207214, "span_start": null, "span_end": null, "passage": "```py\n    from pydantic import BaseModel, ValidationError\n\n    class Model(BaseModel):\n        a: str\n\n    try:\n        Model(a=123)\n    except ValidationError as e:\n        print(e)\n        '''\n     ..."}, {"qid": "", "rank": 17, "path": "pydantic/functional_validators.py", "score": 0.25046584010124207, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 18, "path": "pydantic/functional_validators.py", "score": 0.25046584010124207, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 19, "path": "pydantic/functional_validators.py", "score": 0.25046584010124207, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}, {"qid": "", "rank": 20, "path": "pydantic/functional_validators.py", "score": 0.2504658102989197, "span_start": null, "span_end": null, "passage": "Attributes:\n        func: The validator function"}], "latency_ms": 4.179716110229492, "gold_paths": ["pydantic/tools.py"]}
